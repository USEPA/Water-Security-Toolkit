#
import os, sys, datetime
import pyutilib.subprocess
import yaml, json
import time
import logging

import pywst.common.problem
import pywst.common.wst_config as wst_config
from pyutilib.misc.config import ConfigBlock
import pywst.common.wst_util as wst_util
import pywst.visualization.inp2svg as inp2svg
import pywst.booster_mip.models.ampl.booster_limit_solution
import pywst.booster_mip.models.ampl.booster_neutral_solution

from os.path import basename, splitext

import copy

has_pyepanet = False
try:
    import pyepanet
    has_pyepanet = True
except ImportError:
    pass

_epanet_flow_conversion = {}
if has_pyepanet:
    # USgalmin to m3/min
    _epanet_flow_conversion[pyepanet.EN_GPM] = \
        0.00378541178
    # ft3/s to m3/min
    _epanet_flow_conversion[pyepanet.EN_CFS] = \
        1.6990108
    # MillionUSgal/day to m3/min
    _epanet_flow_conversion[pyepanet.EN_MGD] = \
        2.62875818
    # MillionImperialgal/min to m3/min
    _epanet_flow_conversion[pyepanet.EN_IMGD] = \
        3.15700825
    # acre-ft/day to m3/min
    _epanet_flow_conversion[pyepanet.EN_AFD] = \
        0.856584609         
    # liters/s to m3/min
    _epanet_flow_conversion[pyepanet.EN_LPS] = \
        0.06
    # liters/min to m3/min
    _epanet_flow_conversion[pyepanet.EN_LPM] = \
        0.001
    # Megaliters/day to m3/min
    _epanet_flow_conversion[pyepanet.EN_MLD] = \
        0.6944444444444444444444
    # m3/hour to m3/min
    _epanet_flow_conversion[pyepanet.EN_CMH] = \
        0.01666666666666666666667
    # m3/day to m3/min
    _epanet_flow_conversion[pyepanet.EN_CMD] = \
        0.00069444444444444444444


def root_fname(f):
    return splitext(basename(f))[0]

class Problem(pywst.common.problem.Problem):
    
    results = { 'dateOfLastRun': '',
                'nodesToBooster': [],
                'nodesToBooster': [],
                'finalMetric': -999 }

    # Trying handle all possible ways we may encounter None coming from the yaml parser
    none_list = ['none','','None','NONE', None, [], {}] 
    time_detect = []
    node_names = []
    node_indices = []
    defLocs = {}
    epanetOkay = False

    def __init__(self):
        pywst.common.problem.Problem.__init__(self, 'booster_mip', ("network", "scenario", "booster mip", "solver", "configure", "boostersim", "eventDetection","boosterimpact"))
        self.filename = 'booster_mip.yml'
        self.epanetOkay = False
        try:
            enData = pyepanet.ENepanet()
        except:
            raise RuntimeError("EPANET DLL is missing or corrupt. Please reinstall PyEPANET.")
        self.epanetOkay = True

        self._epanet_flow_units = None

    def _loadPreferences(self):
        for key in defLocs.keys():
            if key == 'ampl':
                self.opts['configure']['ampl executable'] = defLocs[key]
            if key == 'pyomo':
                self.opts['configure']['pyomo executable'] = defLocs[key]

    def _get_converted_PD_options(self):
        cmds = []
        demand_percapita_m3pmin = \
            self.getBoosterOption('PD demand per capita') * \
            _epanet_flow_conversion[self._epanet_flow_units]
        cmds.extend(['--demand-percapita-m3pmin',
                     repr(demand_percapita_m3pmin)])
        # (LITERS / DAY) * (METERS^3 / LITER) * (MINUTES / DAY)
        ingestion_rate_m3pmin = \
            self.getBoosterOption('PD ingestion rate') * \
            .001 / \
            1440.
        cmds.extend(['--ingestion-rate-m3pmin',
                     repr(ingestion_rate_m3pmin)])
        return cmds

    def runBoosterimpact(self, booster_nodes, chl_wqm_file, tox_wqm_file, detection_scn_file, cntr=1):
        logger = logging.getLogger('wst.booster_mip.boosterimpact')
        
        cmd = ['boosterimpact']
        
        cmd.append('--disable-warnings')
 
        # Dissable merlion warnings
        if self.getScenarioOption('ignore merlion warnings') is True:
            cmd.append('--ignore-merlion-warnings')
        # The file defining the water quality model
        cmd.extend([
                '--tox-wqm', tox_wqm_file,
                '--booster-wqm', chl_wqm_file ])

        # The scenario file with detection times generated by eventDetection
        cmd.extend(['--dscn', detection_scn_file])

        # Prepend all output file names with this
        prefix = self.getConfigureOption('output prefix')
        if prefix is None:
            prefix = ''
        cmd.append('--output-prefix='+prefix)

        if self.getBoosterOption('objective') == 'PD':
            cmd.extend(self._get_converted_PD_options())
            cmd.extend(['--population-dosed-threshold-g',
                        repr(float(self.getBoosterOption('PD dose threshold')))])

        # Pass in any user user specified command line options directly to boosterimpact
        # This is useful for testing
        try:
            # this is fragile and will break if the options have spaces in quoted strings
            _opts = self.opts['boosterimpact']['options string'] or ""
            cmd.extend(_opts.split())
        except KeyError:
            pass
        except TypeError:
            pass

        # Create the booster spec file
        booster_spec_file = self._get_prefixed_filename('boosterimpact.boosters.spec')

        f = open(booster_spec_file,'w')
        #INPUT VALIDATION
        assert(self.getBoosterOption('strength') not in self.none_list)
        assert(self.getBoosterOption('duration') not in self.none_list)
        assert(self.getBoosterOption('response time') not in self.none_list)
        #assert(self.opts['internal']['nodeNames'] not in self.none_list)
        assert(self.node_names not in self.none_list)
        #
        # duration and response time are in minutes and WILL be converted to integers
        # These values will be converted to number of water quality timesteps in the boostersim
        # code. If the number of minutes is not a multiple of the water quality timestep
        # these values will be rounded (up or down) to correspond to the nearest water quality timestep 
        print >> f, 'DELAY_MINUTES:', int(self.getBoosterOption('response time'))
        print >> f, 'INJ_DURATION_MINUTES:', int(self.getBoosterOption('duration'))
        print >> f, 'SIM_DURATION_MINUTES:', int(self.getBoosterOption('duration'))+int(self.getBoosterOption('response time'))
        inj_type = self.getBoosterOption('type')
        inj_strength = self.getBoosterOption('strength')
        assert(inj_type in ['MASS','mass','FLOWPACED','flowpaced'])
        if inj_type in ['MASS', 'mass']:
            inj_type *= 0.001 # convert mg/min to g/min
        print >> f, 'INJ_TYPE:', inj_type
        print >> f, 'INJ_STRENGTH:', inj_strength
        print >> f, 'FEASIBLE_NODES:'
        if (booster_nodes == []):
            print >> f, "NONE"
        else:
            for node_name in booster_nodes:
                print >> f, node_name
        f.close()	    
        cmd.append(booster_spec_file)
        
        f = self._get_prefixed_filename('boosterimpact-'+str(cntr)+'.run')
        f = open(f,'w')
        f.write('%s\n' %(' '.join(cmd),))
        f.close()
        logger.info("Launching boosterimpact executable ...")
        out = self._get_prefixed_filename('boosterimpact-'+str(cntr)+'.out')
        sim_timelimit = None
        sub_logger = logging.getLogger('wst.booster_mip.boosterimpact.exec')
        sub_logger.setLevel(logging.DEBUG)
        fh = logging.FileHandler(out, mode='w')
        sub_logger.addHandler(fh)
        p = pyutilib.subprocess.run(cmd,timelimit=sim_timelimit,stdout=pywst.common.problem.LoggingFile(sub_logger))
        if (p[0]):
            raise RuntimeError("\nAn error occured when running the boosterimpact executable\n"
                               "Error Message: %s\n"
                               "Command: %s\n" % (p[1], (' '.join(cmd))))
        
        # Remove the possibly existing destination files before renaming
        # This is required for Windows operating systems
        try:
            os.remove(self._get_prefixed_filename('ScenarioImpacts-'+str(cntr)+'.txt'))
        except OSError:
            # the file did not exist
            pass
        try:
            os.remove(self._get_prefixed_filename('ScenarioImpacts_MC-'+str(cntr)+'.txt'))
        except OSError:
            # the file did not exist
            pass
        try:
            os.remove(self._get_prefixed_filename('ScenarioImpacts_PD-'+str(cntr)+'.txt'))
        except OSError:
            # the file did not exist
            pass
        try:
            os.remove(self._get_prefixed_filename('boosterimpact-'+str(cntr)+'.log'))
        except OSError:
            # the file did not exist
            pass
        try:
            os.rename(self._get_prefixed_filename('boosterimpact.log'), \
                      self._get_prefixed_filename('boosterimpact-'+str(cntr)+'.log'))
        except OSError:
            # the file did not exist
            pass

        impacts = {}
        detected_impacts = impacts['Detected'] = {}
        detected_impacts['label'] = []
        detected_impacts['weight'] = []
        detected_impacts['normalized weight'] = []
        detected_impacts['mass injected grams'] = []
        detected_impacts['response window mass injected grams'] = []
        detected_impacts['tank mass grams'] = []
        detected_impacts['mass balance'] = []
        undetected_impacts = impacts['UnDetected'] = {}
        undetected_impacts['label'] = []
        undetected_impacts['weight'] = []
        undetected_impacts['normalized weight'] = []
        undetected_impacts['mass injected grams'] = []
        undetected_impacts['tank mass grams'] = []
        undetected_impacts['mass balance'] = []
        discarded_impacts = impacts['Discarded'] = {}
        discarded_impacts['label'] = []
        discarded_impacts['weight'] = []
        discarded_impacts['normalized weight'] = []
        discarded_impacts['mass balance'] = []
        with open(self._get_prefixed_filename('ScenarioImpacts.txt'),'r') as f:
            for i in xrange(3):
                line = f.readline().strip().split()
                tag = line[0].strip()
                count = int(line[1])
                tag_impacts = impacts[tag]
                f.readline()
                if tag == 'Detected':
                    for i in xrange(count):
                        line = f.readline().split()
                        tag_impacts['label'].append(line[0].strip())
                        tag_impacts['weight'].append(float(line[1]))
                        tag_impacts['normalized weight'].append(float(line[2]))
                        tag_impacts['mass injected grams'].append(float(line[3]))
                        tag_impacts['response window mass injected grams'].append(float(line[4]))
                        tag_impacts['tank mass grams'].append(float(line[5]))
                        tag_impacts['mass balance'].append(float(line[6]))
                elif tag == 'UnDetected':
                    for i in xrange(count):
                        line = f.readline().split()
                        tag_impacts['label'].append(line[0].strip())
                        tag_impacts['weight'].append(float(line[1]))
                        tag_impacts['normalized weight'].append(float(line[2]))
                        tag_impacts['mass injected grams'].append(float(line[3]))
                        tag_impacts['tank mass grams'].append(float(line[4]))
                        tag_impacts['mass balance'].append(float(line[5]))
                elif tag == 'Discarded':
                    for i in xrange(count):
                        line = f.readline().split()
                        tag_impacts['label'].append(line[0].strip())
                        tag_impacts['weight'].append(float(line[1]))
                        tag_impacts['normalized weight'].append(float(line[2]))
                        tag_impacts['mass balance'].append(float(line[3]))
                f.readline()
        detected_impacts['mass consumed grams'] = []
        detected_impacts['pre-booster mass consumed grams'] = []
        undetected_impacts['mass consumed grams'] = []
        with open(self._get_prefixed_filename('ScenarioImpacts_MC.txt'),'r') as f:
            for i in xrange(3):
                line = f.readline().strip().split()
                tag = line[0].strip()
                count = int(line[1])
                tag_impacts = impacts[tag]
                f.readline()
                if tag == 'Detected':
                    for i in xrange(count):
                        line = f.readline().split()
                        tag_impacts['mass consumed grams'].append(float(line[1]))
                        tag_impacts['pre-booster mass consumed grams'].append(float(line[2]))
                elif tag == 'UnDetected':
                    for i in xrange(count):
                        line = f.readline().split()
                        tag_impacts['mass consumed grams'].append(float(line[1]))
                elif tag == 'Discarded':
                    for i in xrange(count):
                        line = f.readline()
                f.readline()
        detected_impacts['population dosed'] = []
        detected_impacts['pre-booster population dosed'] = []
        undetected_impacts['population dosed'] = []
        with open(self._get_prefixed_filename('ScenarioImpacts_PD.txt'),'r') as f:
            for i in xrange(3):
                line = f.readline().strip().split()
                tag = line[0].strip()
                count = int(line[1])
                tag_impacts = impacts[tag]
                f.readline()
                if tag == 'Detected':
                    for i in xrange(count):
                        line = f.readline().split()
                        tag_impacts['population dosed'].append(float(line[1]))
                        tag_impacts['pre-booster population dosed'].append(float(line[2]))
                elif tag == 'UnDetected':
                    for i in xrange(count):
                        line = f.readline().split()
                        tag_impacts['population dosed'].append(float(line[1]))
                elif tag == 'Discarded':
                    for i in xrange(count):
                        line = f.readline()
                f.readline()

        os.rename(self._get_prefixed_filename('ScenarioImpacts.txt'),
                  self._get_prefixed_filename('ScenarioImpacts-'+str(cntr)+'.txt'))
        os.rename(self._get_prefixed_filename('ScenarioImpacts_MC.txt'),
                  self._get_prefixed_filename('ScenarioImpacts_MC-'+str(cntr)+'.txt'))
        if self.getBoosterOption('objective') == 'PD':
            os.rename(self._get_prefixed_filename('ScenarioImpacts_PD.txt'),
                      self._get_prefixed_filename('ScenarioImpacts_PD-'+str(cntr)+'.txt'))

        return impacts

    def runBoostersim(self, tox_wqm_file, detection_scn_file):
        logger = logging.getLogger('wst.booster_mip.boostersim')
        
        cmd = ['boostersim']

        # The file defining the water quality model
        cmd.extend(['--tox-wqm', tox_wqm_file])
        cmd.extend(['--booster-inp', self.getNetworkOption('epanet file')])
        if(self.getBoosterOption('toxin decay coefficient') not in ['INP','Inp','inp']):
            cmd.extend(['--booster-decay-const', str(self.getBoosterOption('toxin decay coefficient'))])
        cmd.append('--booster-merlion-save-file='+self._get_prefixed_filename('booster-merlion.wqm'))
        chl_wqm_file = self._get_prefixed_filename('booster-merlion.wqm')

        # Optional arguments are simulation duration and water quality timestep, which will
        # override what is in the EPANET input file.
        if self.getNetworkOption('simulation duration') not in ['INP','Inp','inp']:
            cmd.append('--simulation-duration-minutes='+str(self.getNetworkOption('simulation duration')))
        if self.getNetworkOption('water quality timestep') not in ['INP','Inp','inp']:
            cmd.append('--quality-timestep-minutes='+str(self.getNetworkOption('water quality timestep')))

        # The scenario file with detection times generated by eventDetection
        cmd.extend(['--dscn', detection_scn_file])

        # Dissable merlion warnings
        if self.getScenarioOption('ignore merlion warnings') is True:
            cmd.append('--ignore-merlion-warnings')

        if self.getBoosterOption('objective') == 'PD':
            cmd.extend(self._get_converted_PD_options())

        # substitude integers for node names in output files
        cmd.append('--output-merlion-labels')
        # the above command will produce the following file
        label_map_file = "MERLION_LABEL_MAP.txt"

        # In the event that we are solving with the limiting reagent model we need to
        # disable the aggregation scenarios with identical detection times as well as disable
        # the actual booster station simulations, we only want to determine detection times.
        if self.getBoosterOption('model type') == 'LIMIT':
            cmd.extend(['--detections-only','--disable-scenario-aggregation'])

        # Prepend all output file names with this
        prefix = self.getConfigureOption('output prefix')
        if prefix is None:
            prefix = ''
        cmd.append('--output-prefix='+prefix)

        cmd.append('--booster-epanet-rpt-file='+self._get_prefixed_filename('booster-epanet.rpt'))

        #
        # Eventually we will use these options to write the data files in a more 
        # efficient format for pyomo or pysp
        if self.getBoosterOption('model format') == 'PYOMO':
            cmd.append('--output-PYOMO')
        elif self.getBoosterOption('model format') == 'PYSP':
            cmd.extend(['--output-PYSP','--disable-reduced-problem'])

        # Pass in any user user specified command line options directly to boostersim
        # This is useful for testing
        try:
            # this is fragile and will break if the options have spaces in quoted strings
            _opts = self.opts['boostersim']['options string'] or ''
            cmd.extend(_opts.split())
        except KeyError:
            pass
        except TypeError:
            pass

        # Create the booster spec file
        booster_spec_file = self._get_prefixed_filename('boostersim.boosters.spec')

        f = open(booster_spec_file,'w')
        #INPUT VALIDATION
        assert(self.getBoosterOption('strength') not in self.none_list)
        assert(self.getBoosterOption('duration') not in self.none_list)
        assert(self.getBoosterOption('response time') not in self.none_list)
        #assert(self.opts['internal']['nodeNames'] not in self.none_list)
        assert(self.node_names not in self.none_list)
        #
        # duration and response time are in minutes and WILL be converted to integers
        # These values will be converted to number of water quality timesteps in the boostersim
        # code. If the number of minutes is not a multiple of the water quality timestep
        # these values will be rounded (up or down) to correspond to the nearest water quality timestep 
        print >> f, 'DELAY_MINUTES:', int(self.getBoosterOption('response time'))
        print >> f, 'INJ_DURATION_MINUTES:', int(self.getBoosterOption('duration'))
        print >> f, 'SIM_DURATION_MINUTES:', int(self.getBoosterOption('duration'))+int(self.getBoosterOption('response time'))
        inj_type = self.getBoosterOption('type')
        inj_strength = self.getBoosterOption('strength')
        assert(inj_type in ['MASS','mass','FLOWPACED','flowpaced'])
        if inj_type in ['MASS', 'mass']:
            inj_type *= 0.001 # convert mg/min to g/min
        print >> f, 'INJ_TYPE:', inj_type
        print >> f, 'INJ_STRENGTH:', inj_strength
        print >> f, 'FEASIBLE_NODES:'
        #if len(self.getBoosterNodesList()) == 0:
        if len(self.node_names) == 0:
            # The boostersim code will default to using NZD if the 'FEASIBLE_NODES'
            # list is not specified in this file. However, we will still write this
            # parameter to the file to make things more explicit
            print >> f, 'NZD'
        else: 
            #for node_name in self.getBoosterNodesList():
            for node_name in self.node_names:
                print >> f, node_name
        f.close()	    
        cmd.append(booster_spec_file)

        boostersim_run = self._get_prefixed_filename('boostersim.run')
        f = open(boostersim_run,'w')
        f.write('%s\n' % (' '.join(cmd),))
        f.close()
        logger.info("Launching boostersim executable ...")
        out = self._get_prefixed_filename('boostersim.out')
        sim_timelimit = None
        sub_logger = logging.getLogger('wst.booster_mip.boostersim.exec')
        sub_logger.setLevel(logging.DEBUG)
        fh = logging.FileHandler(out, mode='w')
        sub_logger.addHandler(fh)
        p = pyutilib.subprocess.run(cmd,timelimit=sim_timelimit,stdout=pywst.common.problem.LoggingFile(sub_logger))
        if (p[0]):
            raise RuntimeError("\nAn error occured when running the boostersim executable\n"
                               "Error Message: %s\n"
                               "Command: %s\n" % (p[1],(' '.join(cmd))))

        id_to_name_nodemap = {}
        name_to_id_nodemap = {}
        f = open(self._get_prefixed_filename(label_map_file),'r')
        for line in f:
            t = line.split()
            id_to_name_nodemap[int(t[1])] = t[0]
            name_to_id_nodemap[t[0]] = int(t[1])
        f.close()
        
        f = open(self._get_prefixed_filename('boostersim.yml'),'r')
        boostersim_summary = yaml.load(f)
        f.close()

        return id_to_name_nodemap, name_to_id_nodemap, boostersim_summary, chl_wqm_file

    def runOptimization(self, id_to_name_nodemap, name_to_id_nodemap, boostersim_summary, chl_wqm_file, tox_wqm_file, detection_scn_file, alpha, max_stations, enablePDscaling, cntr=1):
        logger = logging.getLogger('wst.booster_mip.exec')
        
        logger.info('Running Optimization with: MAX BOOSTERS = '+str(max_stations)+', STOICHIOMETRIC RATIO = '+str(alpha))
        
        solve_timelimit = None
        p = (1,"There was a problem with the 'model type' or 'model format' options")

        Solution = {}
        Solution['detected scenarios'] = {}
        Solution['non-detected scenarios'] = {}
        Solution['discarded scenarios'] = {}
        Solution['all non-discarded scenarios'] = {}

        if self.getBoosterOption('model format') == 'AMPL':
            exe = self.getConfigureOption('ampl executable')
            inp = self._get_prefixed_filename('ampl-'+str(cntr)+'.run')
            out = self._get_prefixed_filename('ampl-'+str(cntr)+'.out')
            results_file = ''
            if self.getBoosterOption('model type') == 'NEUTRAL':
                logger.info('Adding Complete Neutralization model ...')
                results_file += self.createAmplRunNEUTRAL(name_to_id_nodemap, max_stations, self.getBoosterOption('objective'), inp, cntr)
            elif self.getBoosterOption('model type') == 'LIMIT':
                logger.info('Adding Limiting reactant model ...')	
                results_file += self.createAmplRunLIMIT(name_to_id_nodemap, alpha, max_stations, self.getBoosterOption('objective'), inp, cntr)
            cmd = [exe,inp]
            # Delete the possibly existing results file with the same name before-hand,
            # that way we'll know if AMPL failed
            try:
                os.remove(results_file)
            except OSError:
                # the file did not exist
                pass
            logger.info('Launching AMPL ...')
            sub_logger = logging.getLogger('wst.booster_mip.models.ampl')
            sub_logger.setLevel(logging.DEBUG)
            fh = logging.FileHandler(out, mode='w')
            sub_logger.addHandler(fh)
            p = pyutilib.subprocess.run(cmd,timelimit=solve_timelimit,stdout=pywst.common.problem.LoggingFile(sub_logger))
            if (p[0] or not os.path.isfile(results_file)):
                message = 'An error occured when running the optimization problem.\n Error Message: '+p[1]+'\n Command: '+(' '.join(cmd))+'\n'
                logger.error(message)
                raise RuntimeError(message)
            #try to load the results file
            f = open(results_file,'r')
            sol = yaml.load(f)
            f.close()
            if (sol['solve_result_num'] >= 100) or (sol['solve_result'] != 'solved') or (sol['solve_exitcode'] != 0):
                logger.warn('AMPL solver statuses indicate possible errors.\n' \
                            '     solve_result_num ='+str(sol['solve_result_num'])+'\n' \
                            '     solve_result     ='+str(sol['solve_result'])+'\n' \
                            '     solve_exitcode   ='+str(sol['solve_exitcode']))

        elif self.getBoosterOption('model format') == 'PYOMO':
            exe = self.getConfigureOption('pyomo executable')
            inp = self._get_prefixed_filename('pyomo-'+str(cntr)+'.run')
            out = self._get_prefixed_filename('pyomo-'+str(cntr)+'.out')
            results_file = ''
            cmd = [exe]
            arg_string = []
            if (self.getBoosterOption('model format') == 'PYOMO') and (self.getBoosterOption('model type') == 'LIMIT'):
                logger.info('Adding Limiting reactant model ...')
                arg_string, results_file = self.createPyomoRunLIMIT(name_to_id_nodemap, alpha, max_stations, self.getBoosterOption('objective'), inp, enablePDscaling, cntr)
            elif (self.getBoosterOption('model format') == 'PYOMO') and (self.getBoosterOption('model type') == 'NEUTRAL'):
                logger.info('Adding Complete Neutralization model ...')	
                arg_string, results_file = self.createPyomoRunNEUTRAL(name_to_id_nodemap, max_stations, self.getBoosterOption('objective'), inp, cntr)
            cmd.extend(arg_string)
            logger.info('Launching '+self.getBoosterOption('model format')+' ...')
            # Delete the possibly existing results file with the same name before-hand,
            # that way we'll know if Pyomo failed
            try:
                os.remove(results_file)
            except OSError:
                # the file did not exist
                pass
            sub_logger = logging.getLogger('wst.booster_mip.models.pyomo')
            sub_logger.setLevel(logging.DEBUG)
            fh = logging.FileHandler(out, mode='w')
            sub_logger.addHandler(fh)
            p = pyutilib.subprocess.run(cmd,timelimit=solve_timelimit,stdout=pywst.common.problem.LoggingFile(sub_logger))
            # for now we set the pyomo return code to 0, because the return code
            # likely does not make any sense.
            p[0] = 0
            if (p[0] or not os.path.isfile(results_file)):
                print p
                message = 'An error occured when running the optimization problem.\n Error Message: '+ p[1]+'\n Command: '+(' '.join(cmd))+'\n'
                logger.error(message)
                raise RuntimeError(message)
            #try to load the results file
            f = open(results_file,'r')
            sol = yaml.load(f)
            f.close()

        # Get Booster Nodes
        Solution['booster nodes'] = [id_to_name_nodemap[int(name)] for name in sol['booster ids']]

        # The complete neutralization model aggregates scenarios to
        # decrease model size; therefore we use the boosterimpact
        # module to determine individual impacts for the original
        # unaggregated scenarios
        impacts = self.runBoosterimpact(Solution['booster nodes'],
                                        chl_wqm_file,
                                        tox_wqm_file,
                                        detection_scn_file,
                                        cntr)

        Solution['detected scenarios'] = impacts['Detected']
        Solution['non-detected scenarios'] = impacts['UnDetected']
        Solution['discarded scenarios'] = impacts['Discarded']

        # Scenario counts
        Solution['detected scenarios']['count'] = len(impacts['Detected']['label'])
        Solution['non-detected scenarios']['count'] = len(impacts['UnDetected']['label'])
        Solution['discarded scenarios']['count'] = len(impacts['Discarded']['label'])
        Solution['all non-discarded scenarios']['count'] = \
            Solution['non-detected scenarios']['count'] + \
            Solution['detected scenarios']['count']
        Solution['total scenarios provided'] = \
            Solution['discarded scenarios']['count'] + \
            Solution['non-detected scenarios']['count'] + \
            Solution['detected scenarios']['count']

        # In the case of the limiting reagent model we can't
        # rely on the boosterimpact module to determine the detected
        # scenario impacts and toxin mass remaining in tanks because
        # complete neutralization is used for its calculations
        # We must extract these from the ampl or pyomo solution
        if self.getBoosterOption('model type') == 'LIMIT':
            this_solution_mc = Solution['detected scenarios']['mass consumed grams']
            this_solution_tank = Solution['detected scenarios']['tank mass grams']
            sol_mc = sol['mass consumed grams']
            sol_tank = sol['tank mass grams']
            for ndx, label in enumerate(Solution['detected scenarios']['label']):
                this_solution_mc[ndx] = sol_mc[label]
                this_solution_tank[ndx] = sol_tank[label]
            if self.getBoosterOption('objective') == 'PD':
                this_solution_pd = Solution['detected scenarios']['population dosed']
                sol_pd = sol['population dosed']
                for ndx, label in enumerate(Solution['detected scenarios']['label']):
                    this_solution_pd[ndx] = sol_pd[label]
        
        # Expected impacts
        Solution['detected scenarios']['expected mass consumed grams'] = \
            sum(normalized_weight * mass_consumed_grams for normalized_weight, mass_consumed_grams \
                in zip(Solution['detected scenarios']['normalized weight'],
                       Solution['detected scenarios']['mass consumed grams']))
        Solution['non-detected scenarios']['expected mass consumed grams'] = \
            sum(normalized_weight * mass_consumed_grams for normalized_weight, mass_consumed_grams \
                in zip(Solution['non-detected scenarios']['normalized weight'],
                       Solution['non-detected scenarios']['mass consumed grams']))
        Solution['all non-discarded scenarios']['expected mass consumed grams'] = \
            Solution['detected scenarios']['expected mass consumed grams'] * \
            sum(Solution['detected scenarios']['weight'])
        Solution['all non-discarded scenarios']['expected mass consumed grams'] += \
            Solution['non-detected scenarios']['expected mass consumed grams'] * \
            sum(Solution['non-detected scenarios']['weight'])
        Solution['all non-discarded scenarios']['expected mass consumed grams'] /= \
            sum(Solution['detected scenarios']['weight']) + \
            sum(Solution['non-detected scenarios']['weight'])
        if self.getBoosterOption('objective') == 'PD':
            Solution['detected scenarios']['expected population dosed'] = \
                sum(normalized_weight * population_dosed for normalized_weight, population_dosed \
                    in zip(Solution['detected scenarios']['normalized weight'],
                           Solution['detected scenarios']['population dosed']))
            Solution['non-detected scenarios']['expected population dosed'] = \
                sum(normalized_weight * population_dosed for normalized_weight, population_dosed \
                    in zip(Solution['non-detected scenarios']['normalized weight'],
                           Solution['non-detected scenarios']['population dosed']))
            Solution['all non-discarded scenarios']['expected population dosed'] = \
                Solution['detected scenarios']['expected population dosed'] * \
                sum(Solution['detected scenarios']['weight'])
            Solution['all non-discarded scenarios']['expected population dosed'] += \
                Solution['non-detected scenarios']['expected population dosed'] * \
                sum(Solution['non-detected scenarios']['weight'])
            Solution['all non-discarded scenarios']['expected population dosed'] /= \
                sum(Solution['detected scenarios']['weight']) + \
                sum(Solution['non-detected scenarios']['weight'])

        # THESE NUMBERS SHOULD MATCH
        """
        if (self.getBoosterOption('model type') == 'LIMIT') or (self.getBoosterOption('objective') == 'MC'):
            print sol['expected mass consumed grams'], Solution['detected scenarios']['expected mass consumed grams']
        if self.getBoosterOption('objective') == 'PD':
            print sol['expected population dosed'], Solution['detected scenarios']['expected population dosed']
        """

        if self.getBoosterOption('objective') == 'MC':
            objective = Solution['all non-discarded scenarios']['expected mass consumed grams']
        elif self.getBoosterOption('objective') == 'PD':
            objective = Solution['all non-discarded scenarios']['expected population dosed']

        # Summarize yaml options
        # ***** TODO *****: WE NEED TO AVOID A DEEPCOPY OF THE ENTIRE
        #                   OPTIONS DICTIONARY SO WE CAN REPORT TO THE
        #                   USER WHAT OPTIONS WERE NOT USED
        Solution['yaml options'] = copy.deepcopy(self.opts.value())
        Solution['yaml options']['booster mip']['max boosters'] = max_stations
        Solution['yaml options']['booster mip']['stoichiometric ratio'] = alpha

        Solution['CPU time'] = time.time() - self.startTime

        #self.printSolutionSummary(Solution)

        results_fname = self._get_prefixed_filename("booster_mip_"+str(cntr)+'.json')
        f = open(results_fname,'w')
        json.dump(Solution,f,indent=2)
        f.close()

        logfilename = logger.parent.parent.handlers[0].baseFilename
        outfilename = logger.parent.parent.handlers[0].baseFilename.replace('.log','_'+str(cntr)+'.yml')
        visymlfilename = logger.parent.parent.handlers[0].baseFilename.replace('.log','_'+str(cntr)+'_vis.yml')

        # Write output yml file
        config = wst_config.output_config()
        module_blocks = ("general","booster","scenarios")
        template_options = {
            'general':{
                'cpu time': round(time.time() - self.startTime,3),
                'directory': os.path.dirname(logfilename),
                'log file': os.path.basename(logfilename)},
            'booster':{
                'nodes': Solution['booster nodes'],
                'objective': objective}}
        """
            'scenarios':{
                'discarded': Solution['discarded scenarios'],
                'non-detected': Solution['non-detected scenarios'],
                'detected': Solution['detected scenarios']}}
        """
        self.saveOutput(outfilename, config, module_blocks, template_options)
        
        # Write output visualization yml file
        config = wst_config.master_config()
        module_blocks = ("network", "visualization", "configure")
        template_options = {
            'network':{
                'epanet file': os.path.abspath(self.opts['network']['epanet file'])},
            'visualization': {
                'layers': []},
            'configure': {
                'output prefix': os.path.abspath(self.opts['configure']['output prefix']+'_'+str(cntr))}}
        if self.opts['booster mip']['detection'] not in self.none_list: 
            if len(self.opts['booster mip']['detection']) > 0:
                template_options['visualization']['layers'].append({
                    'label': 'Sensor locations', 
                    'locations': self.opts['booster mip']['detection'],
                    'location type': 'node',  
                    'shape': 'square',             
                    'fill': {
                        'color': '#000099"',
                        'size': 15,
                        'opacity': 0},
                    'line': {
                        'color': '#000099',
                        'size': 2,
                        'opacity': 0.6}})
        if len(Solution['booster nodes']) > 0:
            template_options['visualization']['layers'].append({
                    'label': 'Booster locations', 
                    'locations': "['booster']['nodes'][i]",
                    'file': outfilename,
                    'location type': 'node',  
                    'shape': 'circle',             
                    'fill': {
                        'color': '#aa0000',
                        'size': 15,
                        'opacity': 0.6},
                    'line': {
                        'color': '#000099',
                        'size': 1,
                        'opacity': 0}})
        if visymlfilename != None:
            self.saveVisOutput(visymlfilename, config, module_blocks, template_options)    
        
        print visymlfilename
        
        # Run visualization
        cmd = ['wst', 'visualization', visymlfilename]
        p = pyutilib.subprocess.run(cmd) # logging information should not be printed to the screen
        
        # write out an html file (svg) of the network with booster results
        #self.writeVisualizationFile(cntr, Solution, outfilename, visfilename, visymlfilename)

        # print solution to screen
        logger.info("\nWST Normal Termination")
        logger.info("---------------------------")
        logger.info("Directory: "+os.path.dirname(logfilename))
        logger.info("Results file: "+os.path.basename(outfilename))
        logger.info("Log file: "+os.path.basename(logfilename))
        logger.info("Visualization configuration file: "+os.path.basename(visymlfilename)+'\n')
        
        return results_fname
    
    def printSolutionSummary(self,Solution):
        print 
        print "Solution Summary:"
        print "  Stoichiometric ratio: ", Solution['yaml options']['booster mip']['stoichiometric ratio']
        
        print "  Number of booster stations: ", len(Solution['booster nodes'])
        print "  Booster Station Nodes: ", len(Solution['booster nodes'])
        for node in Solution['booster nodes']:
            print "      - ", node
        if (len(Solution['booster nodes']) != Solution['yaml options']['booster mip']['max boosters']):
            print >> sys.stderr, ' '
            print >> sys.stderr, "WARNING: The list of optimal booster nodes returned had"
            print >> sys.stderr, "         fewer locations than what was specified by"
            print >> sys.stderr, "         'max boosters'. Errors may have occurred."
            print >> sys.stderr, ' '
        print
        print "  Total Number of Scenarios Provided: ", Solution['total scenarios provided']
        print "  Number of Scenarios Discarded: ", Solution['discarded scenarios']['count']
        print
        print "  Detected Scenarios: ", Solution['detected scenarios']['count']

        print "     (1) - Mass consumed within response window (grams):              ", sum(Solution['detected scenarios']['mass consumed grams'])
        if self.getBoosterOption('objective') == 'PD':
            print "         - Population dosed                                           ", sum(Solution['detected scenarios']['population dosed'])
        print "     (2) - Mass consumed before booster station(s) activate (grams):  ", sum(Solution['detected scenarios']['pre-booster mass consumed grams'])
        if self.getBoosterOption('objective') == 'PD':
            print "         - Population dosed before booster station(s) activate:       ", sum(Solution['detected scenarios']['pre-booster population dosed'])
        print "     (3) - Mass consumed after booster station(s) activate (grams):   ", sum(Solution['detected scenarios']['mass consumed grams'])-sum(Solution['detected scenarios']['pre-booster mass consumed grams'])
        print "     (4) - Mass Remaining in Tanks (grams):                           ", sum(Solution['detected scenarios']['tank mass grams'])
        print "     (5) - Mass injected within response window (grams):              ", sum(Solution['detected scenarios']['response window mass injected grams'])
        print "     (6) - Mass injected as defined by original scenarios (grams):    ", sum(Solution['detected scenarios']['mass injected grams'])
        print "         - Simulation Quality Check:"
        print "     (7) -       Average Mass Balance (%):  ", sum(Solution['detected scenarios']['mass balance'])/len(Solution['detected scenarios']['mass balance'])
        print "     (8) -               Scenario Min (%):  ", min(Solution['detected scenarios']['mass balance'])
        print "     (9) -               Scenario Max (%):  ", max(Solution['detected scenarios']['mass balance'])
        print
        print "  Non-detected Scenarios: ", Solution['non-detected scenarios']['count']
        print "    (10) - Mass injected as defined by original scenarios (grams):    ", sum(Solution['non-detected scenarios']['mass injected grams'])
        print "    (11) - Mass consumed within simulation time horizon (grams):      ", sum(Solution['non-detected scenarios']['mass consumed grams'])
        if self.getBoosterOption('objective') == 'PD':
            print "         - Population dosed within simulation time horizon:           ", sum(Solution['non-detected scenarios']['population dosed'])
        print 
        print "  All Non-discarded Scenarios: ", Solution['all non-discarded scenarios']['count']
        print "    (12) - Mass consumed (grams):                                     ", sum(Solution['non-detected scenarios']['mass injected grams'])+sum(Solution['detected scenarios']['mass consumed grams'])
        if self.getBoosterOption('objective') == 'PD':
            print "         - Population dosed                                           ", sum(Solution['non-detected scenarios']['population dosed'])+sum(Solution['detected scenarios']['population dosed'])
        print "    (13) - Mass consumed before booster station(s) activate (grams):  ", sum(Solution['non-detected scenarios']['mass injected grams'])+sum(Solution['detected scenarios']['pre-booster mass consumed grams'])
        if self.getBoosterOption('objective') == 'PD':
            print "         - Population dosed before booster station(s) activate:       ", sum(Solution['non-detected scenarios']['population dosed'])+sum(Solution['detected scenarios']['pre-booster population dosed'])
        print "    (14) - Mass consumed after booster station(s) activate (grams):   ", sum(Solution['detected scenarios']['mass consumed grams'])-sum(Solution['detected scenarios']['pre-booster mass consumed grams'])
        print "    (15) - Mass injected as defined by original scenarios (grams):    ", sum(Solution['non-detected scenarios']['mass injected grams'])+sum(Solution['detected scenarios']['mass injected grams'])
        print 
        print "  ** The response window is defined as the time from the"
        print "     start of a contamination scenario until the final"
        print "     time considered for that scenario, which is the"
        print "     detection time + response delay + booster injection duration."

    def run(self):
        # setup logger
        logger = logging.getLogger('wst.booster_mip')
        logger.info("WST booster_mip subcommand")
        logger.info("---------------------------")
        # set start time
        self.startTime = time.time()
        
        # validate input
        logger.info("Validating configuration file")
        self.validate()

        # open inp file, set feasible nodes
        try:
            enData = pyepanet.ENepanet()
            enData.ENopen(self.opts['network']['epanet file'],'tmp.rpt')
        except:
            raise RuntimeError("EPANET inp file not loaded using pyepanet")

        self._epanet_flow_units = enData.ENgetflowunits()

        self.node_names, self.node_indices = wst_util.feasible_nodes(\
            self.opts['booster mip']['feasible nodes'],\
            self.opts['booster mip']['infeasible nodes'], \
            self.opts['booster mip']['max boosters'], enData)
        enData.ENclose()
        
        # Convert units
        self.setBoosterOption('PD dose threshold', float(self.getBoosterOption('PD dose threshold'))/1000.0)

        # make sure the list consists of strings
        self.setBoosterOption('fixed nodes', [str(node) for node in self.getBoosterOption('fixed nodes')])
        for node in self.getBoosterOption('fixed nodes'):
            if node not in self.node_names:
                raise ValueError("Fixed node with name %s is not in the list of feasible nodes." % (node))
        
        # Flag to indicate toxin and booster injection scaling is enabled for PD objective 
        # TODO : In the future this scaling will need to be done in boostersim during data file generation
        enablePDscaling = False
        if self.getBoosterOption('objective') == 'PD':
            if self.opts['scenario']['tsi file'] in pywst.common.problem.none_list:
                if self.opts['scenario']['tsg file'] in pywst.common.problem.none_list:
                    # Scaling contaminant injection if 
                    toxin_strength = self.getScenarioOption('strength')
                    self.setScenarioOption('strength', (toxin_strength/10000)/self.getBoosterOption('PD dose threshold'))
                    booster_strength = self.getBoosterOption('strength')
                    self.setBoosterOption('strength', (booster_strength/10000)/self.getBoosterOption('PD dose threshold'))
                    self.setBoosterOption('PD dose threshold', 1.0/10000.0)
                    enablePDscaling = False
            else: 
                print >> sys.stderr, ' '
                print >> sys.stderr, "WARNING: Scenario scaling is currently not supported for tsg"
                print >> sys.stderr, "         or tsi files.: ",
                print >> sys.stderr, "         This may result in numerical issues when using PD objective."
                print >> sys.stderr, "         Providing scenario information directly in the YAML file is recommended."
                print >> sys.stderr, ' '


        # write tmp TSG file if ['scenario']['tsg file'] == none
        if self.opts['scenario']['tsi file'] in pywst.common.problem.none_list:
            if self.opts['scenario']['tsg file'] in pywst.common.problem.none_list:
                tmpTSGFile = self._get_tempfile('.tsg')
                wst_util.write_tsg(self.opts['scenario']['location'],\
                                   self.opts['scenario']['type'],\
                                   self.opts['scenario']['species'],\
                                   self.opts['scenario']['strength'],\
                                   self.opts['scenario']['start time'],\
                                   self.opts['scenario']['end time'],\
                                   tmpTSGFile)

                self.opts['scenario']['tsg file'] = tmpTSGFile
            # expand tsg file
            extTSGfile = wst_util.expand_tsg(self.opts)
            self.opts['scenario']['tsg file'] = extTSGfile
            
        # run eventDetection
        #tox_wqm_file, detection_scn_file = self.runEventDetection()
        tox_wqm_file = self._get_prefixed_filename('tox-merlion.wqm')
        detection_scn_file = self._get_prefixed_filename('EventAnalysis.dscn')
        raw_eventdetection_options = '--dscn '
        raw_eventdetection_options += '--merlion-save-file='+tox_wqm_file+' '
        raw_eventdetection_options += '--epanet-rpt-file='+self._get_prefixed_filename('tox-epanet.rpt')+' '
        if self.getBoosterOption('toxin decay coefficient') not in ['INP','Inp','inp']:
            raw_eventdetection_options += '--decay-const '+str(self.getBoosterOption('toxin decay coefficient'))+' '
        if self.getNetworkOption('simulation duration') not in ['INP','Inp','inp']:
            raw_eventdetection_options += '--simulation-duration-minutes='+str(self.getNetworkOption('simulation duration'))+' '
        if self.getNetworkOption('water quality timestep') not in ['INP','Inp','inp']:
            raw_eventdetection_options += '--quality-timestep-minutes='+str(self.getNetworkOption('water quality timestep'))+' '
        # Pass in any user user specified command line options directly to eventDetection
        # This is useful for testing
        try:
            raw_eventdetection_options += self.opts['eventDetection']['options string']+' '
        except KeyError:
            pass
        except TypeError:
            pass
        self.time_detect = wst_util.eventDetection_merlion(self.opts, 
                                                           self.getBoosterOption('detection'), 
                                                           raw_options_string=raw_eventdetection_options)
        
        id_to_name_nodemap, name_to_id_nodemap, boostersim_summary, chl_wqm_file = self.runBoostersim(tox_wqm_file, detection_scn_file)
        
        results = []

        # After simulations are performed with boostersim we can resolve the optimization problem
        # for a range of different alpha and max_stations values. This may save a significant amount of
        # computational time.
        solution_files = []
        failed_solves = []
        cntr = 1
        for a in self.getBoosterOption('stoichiometric ratio'):
            for m in self.getBoosterOption('max boosters'):
                try:
                    solution_files.append(self.runOptimization(id_to_name_nodemap, 
                                                               name_to_id_nodemap,
                                                               boostersim_summary, 
                                                               chl_wqm_file, 
                                                               tox_wqm_file, 
                                                               detection_scn_file,a,m,enablePDscaling, 
                                                               cntr))
                except RuntimeWarning as w:
                    failed_solves.append((a,m,w))
                cntr += 1

        if failed_solves != []:
            logger.warn('One or more failures occurred')
            for (alpha, max_boosters, warning) in failed_solves:
                logger.warn('\t"'+str(warning)+'": Max Boosters = '+str(max_boosters)+', Stoichiometric ratio = '+str(alpha))

        # remove temporary files if debug = 0
        if self.opts['configure']['debug'] == 0:
            pyutilib.services.TempfileManager.clear_tempfiles()
            if os.path.exists('./tmp.rpt'):
                os.remove('./tmp.rpt')
        
        return solution_files     
    
    def validate(self):
        output_prefix = self.getConfigureOption('output prefix')

        # This code is almost never executed because output prefix is
        # None when left blank in the yaml file
        if output_prefix == '':
            output_prefix = 'boost'
            self.setConfigureOption('output prefix',output_prefix)

        if self.getBoosterOption('model format') not in ['AMPL','PYOMO','PYSP']:
            raise IOError("Invalid model format: "+self.getBoosterOption('model format'))
        if self.getBoosterOption('model type') not in ['LIMIT','NEUTRAL']:
            raise IOError("Invalid model type: "+self.getBoosterOption('model type'))

        assert(self.getBoosterOption('toxin decay coefficient') not in self.none_list)
        assert(self.getBoosterOption('decon decay coefficient') not in self.none_list)
        assert(self.getBoosterOption('toxin decay coefficient') >= 0.0)
        assert(self.getBoosterOption('decon decay coefficient') >= 0.0)

        assert(self.getNetworkOption('simulation duration') not in self.none_list)
        assert(self.getNetworkOption('water quality timestep') not in self.none_list) 

        if self.getBoosterOption('objective') == 'PD':
            assert self.getBoosterOption('PD dose threshold') not in self.none_list
            assert self.getBoosterOption('PD dose threshold') >= 0.0
            assert self.getBoosterOption('PD demand per capita') not in self.none_list
            assert self.getBoosterOption('PD demand per capita') >= 0.0
            assert self.getBoosterOption('PD ingestion type') == 'demand'
            assert self.getBoosterOption('PD dose type') == 'total'

        assert(self.getBoosterOption('max boosters') not in self.none_list)
        Max_Stations = self.getBoosterOption('max boosters')
        PD_threshold = self.getBoosterOption('PD dose threshold')

        if Max_Stations.__class__ in [tuple,list]:
            if not all([(i.__class__ is int) and (i >= 0) for i in Max_Stations]):
                raise TypeError, "'max boosters' parameter must be a non-negative integer or a list of non-negative integers."               
        elif (Max_Stations.__class__ is int) and (Max_Stations >= 0):
            Max_Stations = [Max_Stations]
        else:
            raise TypeError, "'max boosters' parameter must be a non-negative integer or a list of non-negative integers."
        
        assert(self.getBoosterOption('stoichiometric ratio') not in self.none_list)
        Alpha = self.getBoosterOption('stoichiometric ratio')
        if Alpha.__class__ in [tuple,list]:
            if not all([(i >= 0.0) for i in Alpha]):
                raise TypeError, "'stoichiometric ratio' parameter must be a non-negative number or a list of non-negative numbers."               
            Alpha = [float(i) for i in Alpha]
        elif (Alpha >= 0.0):
            Alpha = [float(Alpha)]
        else:
            raise TypeError, "'stoichiometric ratio' parameter must be a non-negative number or a list of non-negative numbers."

        # This is indeed the representation of the complete neutralization model (alpha = 0.0)
        if self.getBoosterOption('model type') == 'NEUTRAL':
            Alpha = [0.0]
        # The limiting reagent model is not designed for alpha = 0.0
        if self.getBoosterOption('model type') == 'LIMIT':
            if not all([alpha > 0.0 for alpha in Alpha]):
                raise ValueError, "stoichiometric ratio must be > 0.0 when using the LIMIT model"
        
        # These are now lists
        self.opts['booster mip']['stoichiometric ratio'] = Alpha
        self.opts['booster mip']['max boosters'] = Max_Stations
        self.opts['booster mip']['PD dose threshold'] = PD_threshold

        return

    def createPyomoRunNEUTRAL(self,name_to_id_nodemap,max_stations,objective,filename,cntr=1):

        if objective == 'MC':
            pyomo_model_module = os.path.join(os.path.dirname(os.path.abspath(__file__)),'models','pyomo','booster_neutral')
        elif objective == 'PD':
            pyomo_model_module = os.path.join(os.path.dirname(os.path.abspath(__file__)),'models','pyomo','booster_neutral_PD')

        scenario_summary_module = self._get_prefixed_filename("SCENARIO_SUMMARY.dat")
        booster_candidates_module = self._get_prefixed_filename("BOOSTER_CANDIDATES.dat")
        controller_nodes_module = self._get_prefixed_filename("CONTROLLER_NODES.dat")
        impacts_module = self._get_prefixed_filename("IMPACTS.dat")

        wqm_headers_module = self._get_prefixed_filename("WQM_HEADERS.dat")
        population_dosage_module = self._get_prefixed_filename("POPULATION_DOSAGE.dat")
        scenario_scaling_module = self._get_prefixed_filename("SCENARIO_SCALING.dat")
        delta_index_module = self._get_prefixed_filename("DELTA_INDEX.dat")
        objective_terms_module = self._get_prefixed_filename("OBJECTIVE_TERMS.dat")

        f = open(self._get_prefixed_filename("pyomo-model-"+str(cntr)+".py"), 'w' )
        f.write("from pyomo.environ import *\n")
        f.write('import yaml\n')
        f.write('import cPickle\n')
        f.write("import imp\n")
        f.write("pm = imp.load_source(%r,%r)\n" % 
                (os.path.basename(pyomo_model_module), pyomo_model_module+".py"))
        f.write("SCENARIO_SUMMARY = imp.load_source(%r,%r)\n" % 
                (root_fname(scenario_summary_module), scenario_summary_module))
        f.write("BOOSTER_CANDIDATES = imp.load_source(%r,%r)\n" % 
                (root_fname(booster_candidates_module), booster_candidates_module))
        if objective == 'PD':
            if objective == 'PD':
                f.write("POPULATION_DOSAGE = imp.load_source(%r,%r)\n" %
                        (os.path.basename(population_dosage_module), population_dosage_module,))
                f.write("SCENARIO_SCALING = imp.load_source(%r,%r)\n" %
                        (os.path.basename(scenario_scaling_module), scenario_scaling_module,))
                f.write("WQM_HEADERS = imp.load_source(%r,%r)\n" %
                        (os.path.basename(wqm_headers_module), wqm_headers_module,))
                f.write("DELTA_INDEX = imp.load_source(%r,%r)\n" %
                        (os.path.basename(delta_index_module), delta_index_module,))
        if cntr == 1:
            #####
            #f.write("CONTROLLER_NODES = imp.load_source("+repr(os.path.basename(controller_nodes_module))+","+repr(controller_nodes_module+".dat")+")\n")
            # The above line is replaced by manual line-by-line parsing of the file to avoid the enormous memory spike that
            # the python parser will create with large source code files. The boostersim application writes the python files 
            # in such a way that line-by-line parsing will be efficient.
            f.write("f = open(%r,'r')\n" % (controller_nodes_module,))
            f.write("for  line in f:\n")
            f.write("    exec(line)\n")
            f.write("f.close()\n")
            f.write("from pyutilib.misc import Bunch\n")
            f.write("CONTROLLER_NODES = Bunch( S_CONTROLLER_BOOSTERS=S_CONTROLLER_BOOSTERS)\n")
            f.write("f = open(%r,'wb')\n" % (controller_nodes_module+".pickle",))
            f.write("cPickle.dump(CONTROLLER_NODES,f,cPickle.HIGHEST_PROTOCOL)\n")
            f.write("f.close()\n")
            #####
            #f.write("IMPACTS = imp.load_source("+repr(os.path.basename(impacts_module))+","+repr(impacts_module+".dat")+")\n")
            # The above line is replaced by manual line-by-line parsing of the file to avoid the enormous memory spike that
            # the python parser will create with large source code files. The boostersim application writes the python files 
            # in such a way that line-by-line parsing will be efficient.
            f.write("f = open(%r,'r')\n" % (impacts_module,))
            f.write("for  line in f:\n")
            f.write("    exec(line)\n")
            f.write("f.close()\n")
            f.write("from pyutilib.misc import Bunch\n")
            f.write("IMPACTS = Bunch(P_IMPACT=P_IMPACT)\n")
            #####
            f.write("f = open(%r,'wb')\n" % (impacts_module+".pickle",))
            f.write("cPickle.dump(IMPACTS,f,cPickle.HIGHEST_PROTOCOL)\n")
            f.write("f.close()\n")
            if objective == 'PD':
                #f.write("OBJECTIVE_TERMS = imp.load_source("+repr(os.path.basename(objective_terms_module))+","+repr(objective_terms_module+".dat")+")\n")
                # The above line is replaced by manual line-by-line parsing of the file to avoid the enormous memory spike that
                # the python parser will create with large source code files. The boostersim application writes the python files 
                # in such a way that line-by-line parsing will be efficient.
                f.write("f = open(%r,'r')\n" % (objective_terms_module,))
                f.write("for  line in f:\n")
                f.write("    exec(line)\n")
                f.write("f.close()\n")
                f.write("from pyutilib.misc import Bunch\n")
                f.write("OBJECTIVE_TERMS = Bunch(S_REDUCED_MAP=S_REDUCED_MAP)\n")
                #####
                f.write("f = open(%r,'wb')\n" % (objective_terms_module+".pickle",))
                f.write("cPickle.dump(OBJECTIVE_TERMS,f,cPickle.HIGHEST_PROTOCOL)\n")
                f.write("f.close()\n")
        else:
            f.write("f = open(%r,'rb')\n" % (impacts_module+".pickle",))
            f.write("IMPACTS = cPickle.load(f)\n")
            f.write("f.close()\n")
            f.write("f = open(%r,'rb')\n" % (controller_nodes_module+".pickle",))
            f.write("CONTROLLER_NODES = cPickle.load(f)\n")
            f.write("f.close()\n")
            if objective == 'PD':
                f.write("f = open(%r,'rb')\n" % (objective_terms_module+".pickle",))
                f.write("OBJECTIVE_TERMS = cPickle.load(f)\n")
                f.write("f.close()\n")
   
        if objective == 'MC':
            f.write("model = pm.define_model(SCENARIO_SUMMARY, BOOSTER_CANDIDATES, CONTROLLER_NODES, IMPACTS, "+str(max_stations)+")\n")
        elif objective == 'PD':
            f.write("model = pm.define_model(SCENARIO_SUMMARY, BOOSTER_CANDIDATES, CONTROLLER_NODES, IMPACTS, WQM_HEADERS, POPULATION_DOSAGE, DELTA_INDEX, OBJECTIVE_TERMS, SCENARIO_SCALING, "+str(max_stations)+","+str(self.getBoosterOption('PD dose threshold'))+")\n")
        # use pyomo postprocess module to calculate individual scenario impacts
        results_file = self._get_prefixed_filename("pyomo-results-"+str(cntr)+".yml")
        f.write("pyomo_postprocess = pm.create_solution_function(%r, %r)\n"
                % (results_file, objective))
        # use pyomo postprocess module to report solution
        results_file = self._get_prefixed_filename("pyomo-results-"+str(cntr)+".yml")
        if self.getBoosterOption('evaluate') is True:
            f.write("for b in model.S_BOOSTER_CANDIDATES:\n")
            f.write("    model.y_booster[b].value = 1\n")
            f.write("    model.y_booster[b].fixed = True\n")
            f.write("\n")
        elif len(self.getBoosterOption('fixed nodes')) != 0:
            for node in self.getBoosterOption('fixed nodes'):
                f.write("model.y_booster[{0!r}].value = 1\n".format(name_to_id_nodemap[str(node)]))
                f.write("model.y_booster[{0!r}].fixed = True\n".format(name_to_id_nodemap[str(node)]))
            f.write("\n")
        # use pyomo postprocess module to calculate individual scenario impacts
        results_file = self._get_prefixed_filename("pyomo-results-"+str(cntr)+".yml")
        f.write("pyomo_postprocess = pm.create_solution_function(%r, %r)\n"
                % (results_file, objective))
        f.close()
        pyomo_model = self._get_prefixed_filename("pyomo-model-"+str(cntr)+".py")

        cmd_string = [pyomo_model]

        cmd_string.append('--solver='+self.getSolverOption('type'))

        temp_solver_name = self.getSolverOption('type').upper()

        if temp_solver_name  == 'CPLEX':
             cmd_string.append("--solver-options="+ "mip_cuts_mircut=-1"+" ")
        elif temp_solver_name == 'CPLEXAMP':
             cmd_string.append("--solver-options="+ "mircuts=-1"+" ")


        if self.getSolverOption('problem writer') not in self.none_list:
            cmd_string.append('--solver-io='+self.getSolverOption('problem writer'))
        if self.getSolverOption('options') not in self.none_list:
            for (key,value) in self.getSolverOption('options').iteritems():
                if value in self.none_list:
                    # this is the case where an option does not accept a value
                    cmd_string.append("--solver-options="+key+"=\"\"")
                else:
                    cmd_string.append("--solver-options="+key+'='+str(value))

        cmd_string.extend(['--save-results', self._get_prefixed_filename('pyomo-save-file')])

        cmd_string.append('--stream-solver')

        fid = open(filename,'w')
        fid.write(self.getConfigureOption('pyomo executable')+' '+' '.join(cmd_string)+'\n')
        fid.close()

        return cmd_string, results_file

    def createAmplRunNEUTRAL(self,name_to_id_nodemap,max_stations,objective,filename,cntr=1):
        
        if objective == 'MC':
            ampl_model = os.path.join(os.path.dirname(os.path.abspath(__file__)),'models','ampl','booster_neutral.mod')
        elif objective == 'PD':
            ampl_model = os.path.join(os.path.dirname(os.path.abspath(__file__)),'models','ampl','booster_neutral_PD.mod')

        fid = open(filename,'wt')
        fid.write('option presolve 0;\n')
        fid.write('option substout 0;\n')
        fid.write('\n')
        
        fid.write('# Booster placement model\n')
        fid.write('model %s;\n'%ampl_model)
        fid.write('\n')
        
        fid.write('# Booster placement data\n')
        fid.write('data '+self._get_prefixed_filename('IMPACTS.dat')+'\n')
        fid.write('data '+self._get_prefixed_filename('CONTROLLER_NODES.dat')+'\n')
        fid.write('data '+self._get_prefixed_filename('SCENARIO_SUMMARY.dat')+'\n')
        fid.write('data '+self._get_prefixed_filename('BOOSTER_CANDIDATES.dat')+'\n')
        if objective == 'PD':
            fid.write('data '+self._get_prefixed_filename('WQM_HEADERS.dat')+'\n')
            fid.write('data '+self._get_prefixed_filename('POPULATION_DOSAGE.dat')+'\n')
            fid.write('data '+self._get_prefixed_filename('SCENARIO_SCALING.dat')+'\n')
            fid.write('data '+self._get_prefixed_filename('DELTA_INDEX.dat')+'\n')
            fid.write('data '+self._get_prefixed_filename('OBJECTIVE_TERMS.dat')+'\n')            
        fid.write('\n')

        assert(self.getBoosterOption('max boosters') not in self.none_list)	
        fid.write('let P_MAX_STATIONS := '+str(max_stations)+';\n')
        if objective == 'PD':
            fid.write('let P_DOSE_THRESHOLD_g := '+str(self.getBoosterOption('PD dose threshold'))+';\n')
        fid.write('\n')

        # Try to solve relaxed version first, this can be much faster
        fid.write('let {b in S_BOOSTER_CANDIDATES} y_booster[b].relax := 1;\n')
        
        if self.getBoosterOption('evaluate') is True:
            fid.write('# Fixing booster nodes\n')
            fid.write('for {b in S_BOOSTER_CANDIDATES} {\n')
            fid.write('  fix y_booster[b] := 1;\n')
            fid.write('}\n')
            fid.write('\n')
        elif len(self.getBoosterOption('fixed nodes')) != 0:
            fid.write('# Fixing booster nodes\n')
            for node in self.getBoosterOption('fixed nodes'):
                fid.write('fix y_booster[{0!r}] := 1;\n'.format(name_to_id_nodemap[str(node)]))
            fid.write('\n')

        fid.write('# Solve the problem\n')
        fid.write('option solver '+self.getSolverOption('type')+';\n')
        # HACK: Not sure what the correct label is for solvers other than
        # cplex and gurobi so I will throw an error if I encounter options.
        # The alternative is to ask the user for the solver executable and this
        # ampl specific label which would be weird. The solver configuration system
        # will likely be updated in the future so this should work for now.
        options_label = ''
        if self.getSolverOption('type') == 'cplexamp':
            options_label += 'cplex_options'
        elif self.getSolverOption('type') == 'gurobi_ampl':
            options_label += 'gurobi_options'
        
        if self.getSolverOption('options') not in self.none_list:
            if options_label != '':
                fid.write('option '+options_label+' \'')
                for (key,value) in self.getSolverOption('options').iteritems():
                    if value in self.none_list:
                        # this is the case where an option does not accept a value
                        fid.write(key+' ')
                    else:
                        fid.write(key+'='+str(value)+' ')
                fid.write('\';\n')
            else:
                print >> sys.stderr, ' '
                print >> sys.stderr, "WARNING: Solver options in AMPL are currently not handled for"
                print >> sys.stderr, "         the specified solver: ", self.getSolverOption('type')
                print >> sys.stderr, "         All solver options will be ignored."
                print >> sys.stderr, ' '
        fid.write('solve;\n')
        fid.write('option omit_zero_rows 1;\n')

        # Check that the solution was integral
        fid.write('let {b in S_BOOSTER_CANDIDATES} y_booster[b].relax := 0;\n')
        fid.write('for {b in S_BOOSTER_CANDIDATES} {\n')
        fid.write('    if (y_booster[b] > 0.001) && (y_booster[b] < 0.999) then {\n')
        fid.write('       solve;\n')
        fid.write('       break;\n')
        fid.write('    }\n')
        fid.write('}\n')
        
        fid.write('# Actual total mass consumed\n')
        if objective == 'MC':
            fid.write('display MASS_CONSUMED_g;\n\n')
        elif objective == 'PD':
            fid.write('display POPULATION_DOSED;\n\n')
        fid.write('# Booster nodes\n')
        fid.write('display y_booster;\n\n')
        
        fid.write('# Important exit codes to check\n')
        fid.write('display solve_result_num;\n')
        fid.write('display solve_result;\n')
        fid.write('display solve_exitcode;\n\n')
        
        fid.write('if (solve_exitcode != 0) || ((solve_result != "solved") and (solve_result != "solved?")) || (solve_result_num >= 200) then {\n')
        fid.write('    exit 1;\n')
        fid.write('}\n\n')

        results_file = self._get_prefixed_filename('ampl-results-'+str(cntr)+'.yml')
        
        fid.write(pywst.booster_mip.models.ampl.\
                  booster_neutral_solution.\
                  create_solution_script(results_file,
                                         objective))

        fid.close()

        return results_file

    def createPyomoRunLIMIT(self,name_to_id_nodemap,alpha,max_stations,objective,filename,enablePDscaling,cntr=1):
        
        if objective == 'MC':
            pyomo_model_module = os.path.join(os.path.dirname(os.path.abspath(__file__)),'models','pyomo','booster_limit_MC')
        elif objective == 'PD':
            pyomo_model_module = os.path.join(os.path.dirname(os.path.abspath(__file__)),'models','pyomo','booster_limit_PD')

        scenario_summary_module = self._get_prefixed_filename("SCENARIO_SUMMARY")
        wqm_module = self._get_prefixed_filename("WQM")
        wqm_headers_module = self._get_prefixed_filename("WQM_HEADERS")
        chl_wqm_module = self._get_prefixed_filename("BOOSTER_WQM")
        tox_wqm_module = self._get_prefixed_filename("TOXIN_WQM")
        demands_module = self._get_prefixed_filename("DEMANDS")
        tanks_module = self._get_prefixed_filename("TANK_VOLUMES")
        booster_candidates_module = self._get_prefixed_filename("BOOSTER_CANDIDATES.dat")
        booster_injection_module = self._get_prefixed_filename("BOOSTER_INJECTION")
        population_dosage_module = self._get_prefixed_filename("POPULATION_DOSAGE")
        toxin_injection_module = self._get_prefixed_filename("TOXIN_INJECTION")
        f = open(self._get_prefixed_filename("pyomo-model-"+str(cntr)+".py"),'w')
        f.write("from pyomo.environ import *\n")
        f.write('import yaml\n')
        f.write('import pickle\n')
        f.write("import imp\n")
        f.write("pm = imp.load_source(%r,%r)\n" % 
                (os.path.basename(pyomo_model_module), pyomo_model_module+".py",))
        f.write("SCENARIO_SUMMARY = imp.load_source(%r,%r)\n" %
                (os.path.basename(scenario_summary_module), scenario_summary_module+".dat",))
        #####
        #f.write("WQM = imp.load_source("+repr(os.path.basename(wqm_module))+","+repr(wqm_module+".dat")+")\n")
        # The above line is replaced by manual line-by-line parsing of the file to avoid the enormous memory spike that
        # the python parser will create with large source code files. The boostersim application writes the python files 
        # in such a way that line-by-line parsing will be efficient.
        if cntr == 1:
            f.write("f = open(%r,'r')\n" % (wqm_headers_module+".dat",))
            f.write("for  line in f:\n")
            f.write("    exec(line)\n")
            f.write("f.close()\n")
            f.write("f = open(%r,'r')\n" % (chl_wqm_module+".dat",))
            f.write("for  line in f:\n")
            f.write("    exec(line)\n")
            f.write("f.close()\n")
            f.write("f = open(%r,'r')\n" % (tox_wqm_module+".dat",))
            f.write("for  line in f:\n")
            f.write("    exec(line)\n")
            f.write("f.close()\n")
            f.write("from pyutilib.misc import Bunch\n")
            f.write("WQM = Bunch( P_MINUTES_PER_TIMESTEP=P_MINUTES_PER_TIMESTEP, \\\n")
            f.write("     S_NODES=S_NODES, \\\n")
            f.write("     S_TIMES=S_TIMES, \\\n")
            f.write("     S_CONC_MATRIX_CSR_INDEX_BOOSTER=S_CONC_MATRIX_CSR_INDEX_BOOSTER, \\\n")
            f.write("     P_CONC_MATRIX_CSR_BOOSTER=P_CONC_MATRIX_CSR_BOOSTER, \\\n")
            f.write("     P_INJ_MATRIX_DIAG_BOOSTER=P_INJ_MATRIX_DIAG_BOOSTER, \\\n")
            f.write("     S_CONC_MATRIX_CSR_INDEX_TOXIN=S_CONC_MATRIX_CSR_INDEX_TOXIN, \\\n")
            f.write("     P_CONC_MATRIX_CSR_TOXIN=P_CONC_MATRIX_CSR_TOXIN, \\\n")
            f.write("     P_INJ_MATRIX_DIAG_TOXIN=P_INJ_MATRIX_DIAG_TOXIN )\n")
            f.write("f = open(%r,'wb')\n" % (wqm_module+".pickle",))
            f.write("pickle.dump(WQM,f,pickle.HIGHEST_PROTOCOL)\n")
            f.write("f.close()\n")
        else:
            f.write("f = open(%r,'rb')\n" % (wqm_module+".pickle",))
            f.write("WQM = pickle.load(f)\n")
            f.write("f.close()\n")
        #####
        f.write("DEMANDS = imp.load_source(%r,%r)\n" % 
                (os.path.basename(demands_module), demands_module+".dat",))
        f.write("TANK_VOLUMES = imp.load_source(%r,%r)\n" % 
                (os.path.basename(tanks_module), tanks_module+".dat",))
        f.write("BOOSTER_CANDIDATES = imp.load_source(%r,%r)\n" %
                (root_fname(booster_candidates_module), booster_candidates_module))
        f.write("BOOSTER_INJECTION = imp.load_source(%r,%r)\n" %
                (os.path.basename(booster_injection_module), booster_injection_module+".dat",))
        if objective == 'PD':
            f.write("POPULATION_DOSAGE = imp.load_source(%r,%r)\n" %
                    (os.path.basename(population_dosage_module), population_dosage_module+".dat",))
        f.write("TOXIN_INJECTION = imp.load_source(%r,%r)\n" % 
                (os.path.basename(toxin_injection_module), toxin_injection_module+".dat"))
        if objective == 'MC':
            f.write("model = pm.define_MC_LIMIT_model(SCENARIO_SUMMARY, WQM, DEMANDS, TANK_VOLUMES, BOOSTER_CANDIDATES, BOOSTER_INJECTION, TOXIN_INJECTION, "+str(alpha)+","+str(max_stations)+")\n")
        elif objective == 'PD':
            f.write("model = pm.define_PD_LIMIT_model(SCENARIO_SUMMARY, WQM, DEMANDS, TANK_VOLUMES, BOOSTER_CANDIDATES, BOOSTER_INJECTION, TOXIN_INJECTION, POPULATION_DOSAGE, "+str(alpha)+","+str(max_stations)+","+str(self.getBoosterOption('PD dose threshold'))+","+str(enablePDscaling)+")\n")
        # use pyomo postprocess module to calculate individual scenario impacts
        results_file = self._get_prefixed_filename("pyomo-results-"+str(cntr)+".yml")
        f.write("pyomo_postprocess = pm.create_solution_function(%r, %r)\n"
                % (results_file, objective))
        # Fixed nodes
        if len(self.getBoosterOption('fixed nodes')) != 0:
            for node in self.getBoosterOption('fixed nodes'):
                f.write("model.y_booster[{0!r}].value = 1\n".format(name_to_id_nodemap[str(node)]))
                f.write("model.y_booster[{0!r}].fixed = True\n".format(name_to_id_nodemap[str(node)]))
            f.write("\n")

        pyomo_model = self._get_prefixed_filename("pyomo-model-"+str(cntr)+".py")

        cmd_string = [ pyomo_model ]

        cmd_string.append( '--solver='+self.getSolverOption('type') )

        temp_solver_name = self.getSolverOption('type').upper()

        if temp_solver_name  == 'CPLEX':
             cmd_string.append("--solver-options="+ "mip_cuts_mircut=-1"+" ")
        elif temp_solver_name == 'CPLEXAMP':
             cmd_string.append("--solver-options="+ "mircuts=-1"+" ")

        if self.getSolverOption('problem writer') not in self.none_list:
            cmd_string.append( '--solver-io='+self.getSolverOption('problem writer') )
        if self.getSolverOption('options') not in self.none_list:
            for (key,value) in self.getSolverOption('options').iteritems():
                if value in self.none_list:
                    # this is the case where an option does not accept a value
                    cmd_string.append( "--solver-options="+key+"=\"\"" )
                else:
                    cmd_string.append( "--solver-options="+key+'='+str(value) )
        
        pyomo_save_file = self._get_prefixed_filename('pyomo-save-file-'+str(cntr))
        cmd_string.extend([ '--save-results', self._get_prefixed_filename('pyomo-save-file') ])

        cmd_string.append( '--stream-solver' )

        fid = open(filename,'w')
        fid.write(self.getConfigureOption('pyomo executable')+' '+' '.join(cmd_string)+'\n')
        fid.close()

        return cmd_string, results_file

    def createAmplRunLIMIT(self,name_to_id_nodemap,alpha,max_stations,objective,filename,cntr=1):
        ampl_model = os.path.join(os.path.dirname(os.path.abspath(__file__)),'models','ampl','booster_limit.mod')
        ampl_model_preprocessor = os.path.join(os.path.dirname(os.path.abspath(__file__)),'models','ampl','booster_limit_preprocess.mod')

        fid = open(filename,'wt')
        fid.write('option presolve 0;\n')
        fid.write('option substout 0;\n')
        fid.write('\n')

        fid.write('# Booster placement model\n')
        fid.write('model %s;\n'%ampl_model)
        fid.write('\n')

        fid.write('# Booster placement data\n')
        fid.write('data '+self._get_prefixed_filename('WQM_HEADERS.dat')+'\n')
        fid.write('data '+self._get_prefixed_filename('BOOSTER_WQM.dat')+'\n')
        fid.write('data '+self._get_prefixed_filename('TOXIN_WQM.dat')+'\n')
        fid.write('data '+self._get_prefixed_filename('DEMANDS.dat')+'\n')
        fid.write('data '+self._get_prefixed_filename('TANK_VOLUMES.dat')+'\n')
        fid.write('data '+self._get_prefixed_filename('BOOSTER_CANDIDATES.dat')+'\n')
        fid.write('data '+self._get_prefixed_filename('TOXIN_INJECTION.dat')+'\n')
        fid.write('data '+self._get_prefixed_filename('BOOSTER_INJECTION.dat')+'\n')
        if objective == 'PD':
            fid.write('data '+self._get_prefixed_filename('POPULATION_DOSAGE.dat')+'\n')
        fid.write('data '+self._get_prefixed_filename('SCENARIO_SUMMARY.dat')+'\n')
        fid.write('\n')

        fid.write('# Max number of stations\n')
        fid.write('let P_MAX_STATIONS := %d;\n'%max_stations)
        fid.write('\n')

        fid.write('# Stoichiometric coefficient (chl/toxin)\n')
        fid.write('let P_ALPHA := %s;\n'%alpha)
        fid.write('\n')
        
        if self.getBoosterOption('evaluate') is True:
            fid.write('# Fixing booster nodes\n')
            fid.write('for {b in S_BOOSTER_CANDIDATES} {\n')
            fid.write('  fix y_booster[b] := 1;\n')
            fid.write('}\n')
            fid.write('\n')
        elif len(self.getBoosterOption('fixed nodes')) != 0:
            fid.write('# Fixing booster nodes\n')
            for node in self.getBoosterOption('fixed nodes'):
                fid.write('fix y_booster[{0!r}] := 1;\n'.format(name_to_id_nodemap[str(node)]))
            fid.write('\n')
        
        fid.write('# Solve the problem\n')
        fid.write('option solver '+self.getSolverOption('type')+';\n')
        # HACK: Not sure what the correct label is for solvers other than
        # cplex and gurobi so I will throw an error if I encounter options.
        # The alternative is to ask the user for the solver executable and this
        # ampl specific label which would be weird. The solver configuration system
        # will likely be updated in the future so this should work for now.
        options_label = ''
        if self.getSolverOption('type') == 'cplexamp':
            options_label += 'cplex_options'
        elif self.getSolverOption('type') == 'gurobi_ampl':
            options_label += 'gurobi_options'
        
        if self.getSolverOption('options') not in self.none_list:
            if options_label != '':
                fid.write('option '+options_label+' \'')
                for (key,value) in self.getSolverOption('options').iteritems():                
                    if value in self.none_list:
                        # this is the case where an option does not accept a value
                        fid.write(key+' ')
                    else:
                        fid.write(key+'='+str(value)+' ')
                fid.write('\';\n')
            else:
                print >> sys.stderr, ' '
                print >> sys.stderr, "WARNING: Solver options in AMPL are currently not handled for"
                print >> sys.stderr, "         the specified solver: ", self.getSolverOption('type')
                print >> sys.stderr, "         All solver options will be ignored."
                print >> sys.stderr, ' '

        if objective == 'MC':
            fid.write('objective MASS_CONSUMED_g;\n')
        else:
            fid.write('objective POPULATION_DOSED;\n')

        fid.write('commands %s;\n' % (ampl_model_preprocessor))

        fid.write('solve;\n')
        fid.write('option omit_zero_rows 1;\n')
        
        fid.write('# Actual total mass consumed\n')
        if objective == 'MC':
            fid.write('display MASS_CONSUMED_g;\n\n')
        else:
            fid.write('display POPULATION_DOSED;\n\n')
        fid.write('# Booster nodes\n')
        fid.write('display y_booster;\n\n')
        
        fid.write('# Important exit codes to check\n')
        fid.write('display solve_result_num;\n')
        fid.write('display solve_result;\n')
        fid.write('display solve_exitcode;\n\n')
        
        fid.write('if (solve_exitcode != 0) || ((solve_result != "solved") and (solve_result != "solved?")) || (solve_result_num >= 200) then {\n')
        fid.write('    exit 1;\n')
        fid.write('}\n\n')

        results_file = self._get_prefixed_filename('ampl-results-'+str(cntr)+'.yml')
        
        fid.write(pywst.booster_mip.models.ampl.\
                  booster_limit_solution.\
                  create_solution_script(results_file,
                                         objective))
  
        fid.close()

        return results_file

    def writeVisualizationFile(self, cntr, Solution, outfilename, visfilename, visymlfilename):
        inp_file = os.path.abspath(self.opts['network']['epanet file'])

        sensors = self.getBoosterOption("detection")
        sensors_list = []
        if sensors.__class__ is not list:
            if os.path.exists(sensors) and os.path.isfile(sensors):
                with open(sensors) as f:
                    for line in f:
                        line = line.strip().split()
                        if line != []:
                            sensors_list.append(line[0])
        else:
            sensors_list = sensors
        #
        if inp_file and len(inp_file) > 0:
            svg = inp2svg.inp2svg(inp_file)
            nlen = len(Solution['booster nodes'])
            for sensor in sensors_list:
                svg.addShapeOn("square", str(sensor), fs=15, fo=0, sc="#000099", sw=2, so=0.6)
            for i in range(0, nlen):
                node_name = Solution['booster nodes'][i]
                svg.addShapeOn("circle", node_name, fs=15, fc="#aa0000", fo=0.6, so=0)
            svg.setWidth(800)
            svg.setNodeSize(3)
            svg.setLinkSize(1)
            svg.addLayer("Sensor locations")
            svg.getLayer(0)["type"        ] = svg.LAYER_TYPE_NODE
            svg.getLayer(0)["shape"       ] = "Square"
            svg.getLayer(0)["fill color"  ] = "#000099"
            svg.getLayer(0)["fill opacity"] = 0
            svg.getLayer(0)["line size"   ] = 2
            svg.getLayer(0)["line color"  ] = "#000099"
            svg.getLayer(0)["line opacity"] = 0.6
            svg.addLayer("Booster locations")
            svg.getLayer(1)["type"        ] = svg.LAYER_TYPE_NODE
            svg.getLayer(1)["shape"       ] = "Circle"
            svg.getLayer(1)["fill color"  ] = "#aa0000"
            svg.getLayer(1)["fill opacity"] = 0.6
            svg.getLayer(1)["line size"   ] = 1
            svg.getLayer(1)["line color"  ] = "#aa0000"
            svg.getLayer(1)["line opacity"] = 0
            svg.setLegendColor("white")
            svg.setBackgroundColor("white")
            svg.setLegendXY(10,10)
            svg.showLegend()
            svg.writeFile(visfilename)
        else:
            print "EPANet file input requried for Visualization."
            inp_file = "<REQUIRED INPUT>"
        #
        f = open(visymlfilename, "w")
        f.write("# YML input file for custom Booster_mip Placement visualization\n")
        f.write("\n")
        #
        vis = {}
        vis["network"] = {}
        vis["network"]["epanet file"] = inp_file
        #
        vis["visualization"] = {}
        vis["visualization"]["nodes"] = {}
        vis["visualization"]["nodes"]["size"] = 3
        vis["visualization"]["links"] = {}
        vis["visualization"]["links"]["size"] = 1
        #
        vis["visualization"]["layers"] = []
        #
        vis["visualization"]["layers"].append({})
        vis["visualization"]["layers"][0]["label"       ] = "Sensor locations"
        vis["visualization"]["layers"][0]["shape"       ] = "square"
        vis["visualization"]["layers"][0]["fill"] = {}
        vis["visualization"]["layers"][0]["fill"]["color"  ] = "#000099" # "none"
        vis["visualization"]["layers"][0]["fill"]["size"   ] = 15
        vis["visualization"]["layers"][0]["fill"]["opacity"] = 0
        vis["visualization"]["layers"][0]["line"] = {}
        vis["visualization"]["layers"][0]["line"]["color"  ] = "#000099"
        vis["visualization"]["layers"][0]["line"]["size"   ] = 2
        vis["visualization"]["layers"][0]["line"]["opacity"] = 0.6
        vis["visualization"]["layers"][0]["locations"   ] = []
        for sensor in sensors_list:
            vis["visualization"]["layers"][0]["locations"].append(str(sensor))
        #
        vis["visualization"]["layers"].append({})
        vis["visualization"]["layers"][1]["label"       ] = "Booster locations"
        vis["visualization"]["layers"][1]["file"   ] = outfilename
        vis["visualization"]["layers"][1]["shape"       ] = "circle"
        vis["visualization"]["layers"][1]["fill"] = {}
        vis["visualization"]["layers"][1]["fill"]["color"  ] = "#aa0000"
        vis["visualization"]["layers"][1]["fill"]["size"   ] = 15
        vis["visualization"]["layers"][1]["fill"]["opacity"] = 0.6
        vis["visualization"]["layers"][1]["line"] = {}
        vis["visualization"]["layers"][1]["line"]["color"  ] = "#000099"
        vis["visualization"]["layers"][1]["line"]["size"   ] = 1
        vis["visualization"]["layers"][1]["line"]["opacity"] = 0
        vis["visualization"]["layers"][1]["locations"   ] = "['booster']['nodes'][i]"
        #
        vis["configure"] = {}
        vis["configure"]["output prefix"] = self._get_prefixed_filename(str(cntr))
        #
        yaml.dump(vis, f, default_flow_style=False)
        return

    # General Option SET functions
    def setNetworkOption(self, name, value):
        self.opts['network'][name] = value
        return

    def setScenarioOption(self, name, value):
        self.opts['scenario'][name] = value
        return
    
    def setSolverOption(self, name, value):
        self.opts['solver'][name] = value
        return

    def setBoosterOption(self, name, value):
        self.opts['booster mip'][name] = value
        return

    def setConfigureOption(self, name, value):
        self.opts['configure'][name] = value
        return

    # General Option GET functions
    def getBoosterNodesList(self):
        return self.opts['internal']['nodeNames']

    def getConfigureOption(self, name):
        return self.opts['configure'][name]

    def getBoosterOption(self, name):
        return self.opts['booster mip'][name]

    def getScenarioOption(self, name):
        return self.opts['scenario'][name]

    def getNetworkOption(self, name):
        return self.opts['network'][name]

    def getSolverOption(self, name):
        return self.opts['solver'][name]

    def getInternalOption(self, name):
        return self.opts['internal'][name]
