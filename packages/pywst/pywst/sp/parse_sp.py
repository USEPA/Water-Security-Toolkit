#  _________________________________________________________________________
#
#  TEVA-SPOT Toolkit: Tools for Designing Contaminant Warning Systems
#  Copyright (c) 2008 Sandia Corporation.
#  This software is distributed under the BSD License.
#  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
#  the U.S. Government retains certain rights in this software.
#  For more information, see the README file in the top software directory.
#  _________________________________________________________________________
#
# This python module contains functions to parse output generated by
# the TEVA-SPOT 'sp' command.
#

import os
import re

try: 
    from components import OrderedDict 
except ImportError: 
    from ordereddict import OrderedDict 

#
# Process the output log
#
def process_log(logfile,outfile):
    OUTPUT=open(outfile,"w")
    status = 1
    tstatus = "Normal"
    leak_flag=False
    valgrind_leaks="-1"
    valgrind_errors="-1"
    state = 1
    if os.path.exists(logfile):
       INPUT = open(logfile,"r")
       i=0
       for line in INPUT:
         i = i + 1
         words = re.split('[ \t]+',line.strip())
         if len(words) < 2:
            continue

         if state == 1:
            # pico
            if len(words)>=5 and words[2] == "Value" and words[3] == "=":
                status = 0
                print >>OUTPUT, "Value numeric/double " + words[4]

            elif len(words)>=3 and words[0] == "LP" and words[1] == "value=":
                status = 0
                print >>OUTPUT, "Value numeric/double " + words[2]

            # heuristic
            elif len(words)>=3 and words[0] == "Minimum" and words[1] == "cost=":
                status = 0
                print >>OUTPUT, "Value numeric/double " + words[2]
            # lagrangian
            elif len(words)>=5 and words[0] == "Best" and words[1] == "integer":
                status = 0
                print >>OUTPUT, "Value numeric/double " + words[4]

            elif len(words)>=3 and words[0] == "CPU" and words[1] == "RunTime=":
                print >>OUTPUT, "\"CPU RunTime\" numeric/double " + words[2]
    
            elif len(words)>=3 and words[0] == "CPU" and words[1] == "TotalTime=":
                print >>OUTPUT, "\"CPU TotalTime\" numeric/double " + words[2]

            elif len(words)>=3 and words[0] == "WallClock" and words[1] == "TotalTime=":
                print >>OUTPUT, "\"WallClock TotalTime\" numeric/double " + words[2]

            elif words[0] == "Created":
                print >>OUTPUT, "\"Subproblems Created\" numeric/integer " + words[1]

            elif words[0] == "Bounded":
                print >>OUTPUT, "\"Subproblems Bounded\" numeric/integer " + words[1]

            elif words[0] == "Split":
                print >>OUTPUT, "\"Subproblems Split\" numeric/integer " + words[1]

            elif words[0] == "Dead":
                print >>OUTPUT, "\"Subproblems Dead\" numeric/integer " + words[1]

            elif len(words)>=3 and words[0] == "Started" and words[1] == "Bounding":
                print >>OUTPUT, "\"Subproblems Started Bounding\" numeric/integer " + words[2]

            elif len(words)>=3 and words[0] == "Started" and words[1] == "Splitting":
                print >>OUTPUT, "\"Subproblems Started Splitting\" numeric/integer " + words[2]

            elif len(words)>=5 and words[0] == "Number" and words[3] == "Events:":
                print >>OUTPUT, "\"Number Contamination Events\" numeric/integer " + words[4]

            elif len(words)>=5 and words[0] == "Number" and words[3] == "Impacts:":
                print >>OUTPUT, "\"Number Contamination Impacts\" numeric/integer " + words[4]

            elif len(words)>=4 and words[0] == "Number" and words[2] == "variables:":
                print >>OUTPUT, "\"Number All IP Variables\" numeric/integer " + words[3]

         elif len(words)>=5 and words[0] == "Number" and words[2] == "integer":
            print >>OUTPUT, "\"Number Integer IP Variables\" numeric/integer " + words[4]

         elif len(words)>=4 and words[0] == "Number" and words[2] == "constraints:":
            print >>OUTPUT, "\"Number IP Constraints\" numeric/integer " + words[3]

         elif len(words)>=4 and words[0] == "Number" and words[2] == "nonzeros:":
            print >>OUTPUT, "\"Number IP Nonzeros\" numeric/integer " + words[3]

         elif len(words)>=7 and words[0] == "Valid" and words[2] == "Bound":
            print >>OUTPUT, "\"Valid Bound\" numeric/double " + words[6]

         elif words[0] == "RUN" and words[1] == "ABORTED:":
            tstatus = "Aborted"
            status = 1

         elif len(words)>=5 and words[0] == "Maximum" and words[1] == "memory":
            print >>OUTPUT, "\"Max-Memory\" numeric/integer " + words[3]

         #
         # Options for process tso2Impact output
         #
         elif len(words)>=3 and words[0] == "Number" and words[2][0:9] == "scenarios":
            print >>OUTPUT, "\"Number of Scenarios\" numeric/integer " + words[2][10:]

         elif len(words)>=6 and words[0] == "Node" and words[2][0:4] == "file":
            print >>OUTPUT, "\"NodeMap File\" text/string " + words[5][5:]

         elif len(words)>=5 and words[0] == "Impact" and words[2] == "written":
            print >>OUTPUT, "\"Impact File\" text/string " + words[4][5:]
            diffval = commands.getoutput("cd " + cwd + "; diff " + words[4][5:] + " " + etcdir + "Net3/" + ((words[4][5:]).split("/"))[1])
            if diffval == "":
                print >>OUTPUT, "ImpactDiffs numeric/integer 0"
            else:
                print >>OUTPUT, "ImpactDiffs numeric/integer 1"
                print >>OUTPUT, "ImpactDiffVal text/string \"\"\""
                print >>OUTPUT, diffval
                print >>OUTPUT, "\"\"\""
                status = 0

         elif len(words)>=4 and words[0] == "TSO" and words[2] == "Name:":
            print >>OUTPUT, "\"TSO File\" text/string " + words[3]

         #
         # Options for processing the sensor impact statistics
         #
         elif len(words) == 4 and words[0:2] == ["Number","of","sensors:"]:
            print >>OUTPUT, " ".join(words[0:2])+" numeric/integer "+words[3]
         elif len(words) == 4 and words[0:2] == ["Number","of","sensors:"]:
            print >>OUTPUT, " ".join(words[0:2]), "numeric/integer", words[3]

         #
         # When running under AMPL, the first set of valgrind statistics is the 
         # one's that we want
         #
         elif words[1] == "ERROR" and words[2] == "SUMMARY:" and valgrind_errors == "-1":
            valgrind_errors = words[3]
         elif leak_flag==True and words[1] == "definitely" and valgrind_leaks == "-1":
            valgrind_leaks = words[3]
            leak_flag=False
    
         elif words[1] == "LEAK" and words[2] == "SUMMARY:":
            leak_flag=True
    else:
        print "logfile " + logfile + " does not exist"

    #
    # Remove commas from valgrind #'s
    #
    p = re.compile( ',' )
    valgrind_errors = p.sub( "", valgrind_errors)
    valgrind_leaks = p.sub( "", valgrind_leaks)
    print >>OUTPUT, "\"Valgrind Errors\" numeric/integer " + valgrind_errors
    print >>OUTPUT, "\"Valgrind Leaks\" numeric/integer " + valgrind_leaks
    print >>OUTPUT, "TerminationStatus text/string " + tstatus
    print >>OUTPUT, "exit_status numeric/integer " + `status`
    OUTPUT.close()

def process_evalsensors(logfile,outfile=None):
    data = OrderedDict()
    if not outfile is None:
        OUTPUT=open(outfile,"w")
    if os.path.exists(logfile):
        INPUT = open(logfile,"r")
        state=0
        ifile = None
        data[ifile] = {}
        for line in INPUT:
            words = re.split('[ \t]+',line.strip())
            if state == 0:
                if words[:3] == ["Sensor","placement","id:"]:
                    state = 1
                else:
                    continue
            if state == 1:
                if line[0] == "-":
                    if not outfile is None:
                        print >>OUTPUT, ""
                    state = 0
                    continue
                if ":" in line:
                    value = line.split(":")[0]
                else:
                    value = ""
                if value == 'Impact File':
                    ifile = (line.split(":")[1]).strip()
                    data[ifile] = {}
                elif value != "Sensor placement id" and value != "":
                    if not outfile is None:
                        print >>OUTPUT, line,
                    try:
                        data[ifile][(value.split("(")[0]).strip()] = eval(line.split(":")[1])
                    except Exception:
                        data[ifile][(value.split("(")[0]).strip()] = (line.split(":")[1]).strip()
                    
        INPUT.close()
    if not outfile is None:
        OUTPUT.close()
    return data
