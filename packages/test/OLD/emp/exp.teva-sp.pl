#!/usr/bin/perl
#

#
# See if the first argument is '-I' which specifies an include path
# for the TestLib module
#
$ctr=0;
if ($ARGV[0] eq "-I") {
   unshift @INC, $ARGV[1];
   $ENV{'PATH'} = $ENV{'PATH'} . ":.:" . $ARGV[1];
   $ctr = 2;
   }
#
# See if the TESTLIBDIR environmental variable is set, which provides
# an include path for the TestLib module
#
$pwd = `pwd`;
chomp($pwd);
if ($ENV{TESTLIBDIR} ne "") {
   $tmp = $ENV{TESTLIBDIR};
   @words = split /[ ]+/, $tmp, $#tmp;
   foreach $word (@words) {
     unshift @INC, $word;
     }
   }
require TestLib;

#
# Statistics collected by the analyzeData call-back routine
#
# JWB 12/15/2005 
#
$final_seed="ERROR";
$final_sensorplacementid="ERROR";
$final_numberofsensors="ERROR";
$final_totalcost="ERROR";
$final_nodeids="ERROR";
$final_junctions="ERROR";
$final_impactfile="ERROR";
$final_numberscenarios="ERROR";
$final_minimpact="ERROR";
$final_meanimpact="ERROR";
$final_lowerquartile="ERROR";
$final_medianimpact="ERROR";
$final_upperquartile="ERROR";
$final_valueatrisk="ERROR";
$final_tce="ERROR";
$final_maximpact="ERROR";

@trial_seed=();
@trial_sensorplacementid=();
@trial_numberofsensors=();
@trial_totalcost=();
@trial_nodeids=();
@trial_junctions=();
@trial_impactfile=();
@trial_numberscenarios=();
@trial_minimpact=();
@trial_meanimpact=();
@trial_lowerquartile=();
@trial_medianimpact=();
@trial_upperquartile=();
@trial_valueatrisk=();
@trial_tce=();
@trial_maximpact=();
@trial_subsplitting=();

sub update_stats {
  push @trial_seed, $final_seed;
  push @trial_sensorplacementid, $final_sensorplacementid;
  push @trial_numberofsensors, $final_numberofsensors;
  push @trial_totalcost, $final_totalcost;
  push @trial_nodeids, $final_nodeids;
  push @trial_junctions, $final_junctions;
  push @trial_impactfile, $final_impactfile;
  push @trial_numberscenarios, $final_numberscenarios;
  push @trial_minimpact, $final_minimpact;
  push @trial_meanimpact, $final_meanimpact;
  push @trial_lowerquartile, $final_lowerquartile;
  push @trial_medianimpact, $final_medianimpact;
  push @trial_upperquartile, $final_upperquartile;
  push @trial_valueatrisk, $final_valueatrisk;
  push @trial_tce, $final_tce;
  push @trial_maximpact, $final_maximpact;
}

#
# A callback routine that is used to analyze an output file generated by
# PICO.
#
sub dummyAnalyzeData {
}

sub analyzeData {
    $final_seed=0;
    my $filename = @_[0];
    open (INPUT, $filename) || die "cannot open file $filename!";
    while ($line = <INPUT>) {
      chomp($line);
      @word = split /[ \t]+/, $line, $#line;
      if ($#word > 0) {
         #print "HERE $#word\n";
         if ($word[0] eq "") {
            shift @word;
         }
         if (($word[0] eq "Sensor") && ($word[1] eq "placement")) {
            $final_sensorplacementid = $word[3];
         }
         elsif (($word[0] eq "Number") && ($word[2] eq "sensors:")) {
            $final_numberofsensors = eval($word[3]);
         }
         elsif (($word[0] eq "Total") && ($word[1] eq "cost:")) {
            $final_totalcost = eval($word[2]);
         }
         elsif (($word[0] eq "Sensor") && ($word[2] eq "IDs:")) {
            $final_nodeids = join(' ',@word[3 .. ($#word-1)]);
         }
         elsif (($word[0] eq "Sensor") && ($word[1] eq "junctions:")) {
            $final_junctions = join(' ',@word[2 .. ($#word-1)]);
         }
         elsif (($word[0] eq "Impact") && ($word[1] eq "File:")) {
            $final_impactfile = $word[2];
         }
         elsif (($word[0] eq "Number") && ($word[3] eq "scenarios:")) {
            $final_numberscenarios = eval($word[4]);
         }
         elsif (($word[0] eq "Min") && ($word[1] eq "impact:")) {
            $final_minimpact = eval($word[2]);
         }
         elsif (($word[0] eq "Mean") && ($word[1] eq "impact:")) {
            $final_meanimpact = eval($word[2]);
         }
         elsif (($word[0] eq "Lower") && ($word[1] eq "quartile")) {
            $final_lowerquartile = eval($word[3]);
         }
         elsif (($word[0] eq "Median") && ($word[1] eq "impact:")) {
            $final_medianimpact = eval($word[2]);
         }
         elsif (($word[0] eq "Upper") && ($word[1] eq "quartile")) {
            $final_upperquartile = eval($word[3]);
         }
         elsif (($word[0] eq "Value") && ($word[1] eq "at")) {
            $final_valueatrisk = eval($word[6]);
         }
         elsif ($word[0] eq "TCE") {
            $final_tce = eval($word[3]);
	 }
         elsif (($word[0] eq "Max") && ($word[1] eq "impact:")) {
            $final_maximpact = eval($word[2]);
         }
         elsif ($word[0] eq "Seed:") {
            $final_seed = eval($word[1]);
         }
      }
    }
  if ($final_maximpact eq "ERROR") {
     @_[1] = "Fail";
     #print "THERE\n";
  }
  close(INPUT);
  update_stats();
}

$description="  <Description>ERROR</Description>\n";

#
# A callback that is used to print measurement information
#
sub dummyPrintMeasurements {
     print $description;
}

sub printMeasurements {
     print $description;
     $i = 0;
     while ($i <= $#trial_meanimpact) {
       print "  <Trial id=\"$i\" seed=\"$trial_seed[$i]\">\n";

       print "     <Value name=\"Sensor Placement ID\" type=\"numeric/integer\">$trial_sensorplacementid[$i]</Value>\n";
       print "     <Value name=\"Number Of Sensors\" type=\"numeric/integer\">$trial_numberofsensors[$i]</Value>\n";
       print "     <Value name=\"Total Cost\" type=\"numeric/double\">$trial_totalcost[$i]</Value>\n";
       print "     <Value name=\"Node Ids\">$trial_nodeids[$i]</Value>\n";
       print "     <Value name=\"Junctions\">$trial_junctions[$i]</Value>\n";
       print "     <Value name=\"Impact File\">$trial_impactfile[$i]</Value>\n";
       print "     <Value name=\"Number Of Scenarios\" type=\"number/integer\">$trial_numberscenarios[$i]</Value>\n";
       print "     <Value name=\"Min Impact\" type=\"numeric/double\">$trial_minimpact[$i]</Value>\n";
       print "     <Value name=\"LQuartile Impact\" type=\"numeric/double\">$trial_lowerquartile[$i]</Value>\n";
       print "     <Value name=\"Mean Impact\" type=\"numeric/double\">$trial_meanimpact[$i]</Value>\n";
       print "     <Value name=\"Median Impact\" type=\"numeric/double\">$trial_medianimpact[$i]</Value>\n";
       print "     <Value name=\"UQuartile Impact\" type=\"numeric/double\">$trial_upperquartile[$i]</Value>\n";
       print "     <Value name=\"VaR Impact\" type=\"numeric/double\">$trial_valueatrisk[$i]</Value>\n";
       print "     <Value name=\"TCE Impact\" type=\"numeric/double\">$trial_tce[$i]</Value>\n";
       print "     <Value name=\"Max Impact\" type=\"numeric/double\">$trial_maximpact[$i]</Value>\n";


  
     print "  </Trial>\n";
     $i = $i + 1;
   }
}


##
## MAIN ROUTINE
##
if (! @ARGV) {
   print "\n";
   print "exp.teva-sp.pl - teva-ap experiment driver \n";
   print "\n";
   print "usage:\n";
   print "\n";
   print "   exp.teva-sp.pl [options] <expname> <testname> <factor-id> <factor-value> [...]\n";
   print "\n";
   print "options:\n";
   print "\n";
   print "   --tso\t\tRun tevasim to create .tso.\n";
   print "\n";
   print "   -impact\t\tRun tso2Impact to create .impact files.\n";
   print "\n";
   print "   -sp\t\tRun sp to create .log file.\n";
   print "\n";
   print "   -debug\t\tPrint debugging information.\n";
   print "\n";
   print "notes:\n";
   print "\n";
   print "   This script is launched by 'runexp' to execute and process a\n";
   print "   single test from an experiment file.  The output of this test\n";
   print "   is stored in the file <expname>-<testname>.out, which can be\n";
   print "   reviewed after the test is performed.  This script generates an\n";
   print "   XML summary that is included in the <expname>.results.xml file\n";
   print "   by 'runexp'.\n";
   print "\n";
   print "   This script is not intended for interactive use.  Consequently,\n";
   print "   the processing of the command-line options is somewhat fragile.\n";
   print "   For example, it depends on the order in which the options are\n";
   print "   processed in this script!\n";
   print "\n";
   print "   This script assumes that the first factor is the test information,\n";
   print "   and the remaining factors specify command-line options.\n";
   exit;
}

#
# Process command line arguments
#
$testoptions = "";
$sp=0;
$sp_simple=0;
$tso=0;
$impact=0;
if ($ARGV[$ctr] eq "-tso") {
   $ctr += 1;
   $tso = 1;
}
if ($ARGV[$ctr] eq "-impact") {
   $ctr += 1;
   $impact = 1;
}
if ($ARGV[$ctr] eq "-sp") {
   $ctr += 1;
   $sp = 1;
}
if ($ARGV[$ctr] eq "-sp-simple") {
   $ctr += 1;
   $sp_simple = 1;
}
if (($ARGV[$ctr] eq "-debug") || ($ARGV[$ctr] eq "--debug")) {
   $ctr += 1;
   $debug = 1;
}

$description = TestLib::generate_description($ctr,@ARGV);
$expname = $ARGV[$ctr];
$ctr +=1;
$testname = $ARGV[$ctr];
$ctr +=1;
$ntrials = $ARGV[$ctr];
$ctr+=3;
if ($sp_simple == 1) {
   $goal = $ARGV[$ctr];
   $ctr+=3;
   $measure = $ARGV[$ctr];
   $ctr+=3;
}
while ($ctr <= $#ARGV) {
  $testoptions .= $ARGV[$ctr] . " ";
  $ctr+=3;
}
if ($debug == 1) {
   print "descr:   $description\n";
   print "expna:   $expname\n";
   print "testnam: $testname\n";
   print "ntrials: $ntrials\n";
   print "options: $testoptions\n";
   print "goal:    $goal\n";
   print "measure: $measure\n";
}
#
# Process experiment tag/value pairs
#
# This is a convention that is not explicitly supported by the 
# UTILIB testing 'runexp' utility, but this is a convenient way for
# structuring experiment testing.
#
$solnvalue = "unknown";
$tolerance = 1e-12;
$files = "";
%testparams = ();
$auxoptions = TestLib::process_testoptions($testoptions, \%testparams);
if (defined($testparams{"_optimum"})) {
   $solnvalue = $testparams{"_optimum"};
} elsif (defined($testparams{"_value"})) {
   $solnvalue = $testparams{"_value"};
}
foreach $word (TestLib::get_tokens($testparams{"_data"})) {
  $files = $files . $word . " ";
}
if ($debug == 1) {
   print "exp:       $expname\n";
   print "value:     $solnvalue\n";
   print "tolerance: $tolerance\n";
   print "data:      $files\n";
}

if (($sp == 1) || ($sp_simple == 1)) {
   #
   # Setup command line
   #
   if ($sp == 1) {
      $cmdline = "../../bin/sp --path=../../../bin --path=../../etc/mod --print-log $auxoptions";
   } else {
      if ($measure eq "default") {
         $objective = $goal;
      } else {
         $objective = $goal . "_" . $measure;
      }
      $cmdline = "../../bin/sp --path=../../../bin --path=../../etc/mod --print-log --objective=$objective $auxoptions --seed=\$seed";
   }
   #print "teva-sp.exp.pl: command is sp: ";

   if ($debug == 1) {
      print "SP:      $sp $sp_simple\n";
      print "OBJ:     $goal\n";
      print "OBJ:     $measure\n";
      print "OBJ:     $objective\n";
      print "CMDLINE: $cmdline\n";
   }

   #
   # Launch the test with the TestLib driver.
   #
   TestLib::run_experiments(\*STDOUT, $expname, $testname, $cmdline, $ntrials, \&analyzeData, \&printMeasurements, $auxoptions, \%testparams);
} elsif ($tso == 1) {
   #
   # Setup command line
   #
   #print "teva-sp.exp.pl: command is tevasim: ";
   #print "tevasim options: ";
   #print $auxoptions;
   $cmdline = "../../bin/tevasim $auxoptions";

   if ($debug == 1) {
      print "CMDLINE: $cmdline\n";
   }

   #
   # Launch the test with the TestLib driver.
   #
   TestLib::run_experiments(\*STDOUT, $expname, $testname, $cmdline, $ntrials, \&dummyAnalyzeData, \&dummyPrintMeasurements, $auxoptions, \%testparams);
} elsif ($impact == 1) {
   #
   # Setup command line
   #
   #print "teva-sp.exp.pl: command is tso2Impact: ";
   $cmdline = "../../bin/tso2Impact $auxoptions";

   if ($debug == 1) {
      print "CMDLINE: $cmdline\n";
   }

   #
   # Launch the test with the TestLib driver.
   #
   TestLib::run_experiments(\*STDOUT, $expname, $testname, $cmdline, $ntrials, \&dummyAnalyzeData, \&dummyPrintMeasurements, $auxoptions, \%testparams);
}
