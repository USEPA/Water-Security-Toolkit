/*  _________________________________________________________________________
 *
 *  TEVA-SPOT Toolkit: Tools for Designing Contaminant Warning Systems
 *  Copyright (c) 2008 Sandia Corporation.
 *  This software is distributed under the LGPL License.
 *  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
 *  the U.S. Government retains certain rights in this software.
 *  For more information, see the README file in the top software directory.
 *  _________________________________________________________________________
 */

#include <iostream>
#include "ProblemSolver.h"
#include "redefs.h"
using namespace NewSensorPlacement;

ProblemSolver::ProblemSolver(int argc, char **argv): 
  argc(argc),
  argv(argv)
{
  inputMode=3;
}

ProblemSolver::ProblemSolver(int argc, char **argv, int mode): 
  argc(argc),
  argv(argv),
  inputMode(mode)
{
}

ProblemSolver::~ProblemSolver() {
  delete instance;
  delete initialSolution;
  delete bestSolution;
  locations.clear();
  #ifdef OPTIMER
  delete [] facilityLocationConstraints;
  #endif
}


void ProblemSolver::checkImperfectArgc(){
 if((argc!=8)&&(argc!=9)&&(argc!=10)){ 
   std::cout << "***Incorrect invocation - Usage is: new_imperfect <configuration-file> <category-definition-input-file> <location-category-input-file> <num-samples> <random-seed> <impact-file-representation> <time-limit> [solution-file] [json-file]" << std::endl;
    exit(1);
  }   
  std::cout << "Executable: new_imperfect" << std::endl;
}



void ProblemSolver::checkArgc(){
  if((argc!=6)&&(argc!=7)&&(argc!=8))  {
    std::cout << "***Usage: new_randomsample <configuration-file> <num-samples> <random-seed> <impact-file-representation> <time-limit> [solution-file] [json-file]" << std::endl;
    exit(1);
  }
  std::cout << "Executable: new_randomsample" << std::endl;
}

void ProblemSolver::initialTime() {
  InitializeTiming();
  CPUSeconds_start = CPUSeconds();
  WallClockSeconds_start = WallClockSeconds();
}

void ProblemSolver::readConfig() {
  //////////////////////////////////////////////////////////////
  // all problem-specific (as opposed to algorithm-specific)  //
  // parameters are read from the SPProblem class, which is   //
  // an interface to the configuration text file generated by //
  // the 'sp' solver script.                                  //
  //////////////////////////////////////////////////////////////
  std::ifstream configFile(argv[1]);
  if(!configFile) {
    std::cout << "***Failed to open configuration file=" << argv[1] << std::endl;
    exit(1);
  }
  std::cout << "Reading configuration file=" << argv[1] << std::endl;
  std::cout << std::flush;
  // TNT: Added the flag to tell the SPProblem class to not
  // load the impact data (it will be loaded later.
  theProblem.read_config_file(configFile,false);
  configFile.close();
  std::cout << "Done. file=" << argv[1] << std::endl;
  std::cout << std::flush;
}


void ProblemSolver::setParameter(){  
  ///////////////////////////////////////////////////////
  // determine the objective, statistic, and number of //
  // facilities to open (i.e., sensors to place) from  //
  // the overall problem definition.                   //
  ///////////////////////////////////////////////////////
  numFacilitiesToOpen = -1;
  gamma = theProblem.gamma;
  for(size_t i=0;i<theProblem.goals.size();++i)  {
    SPGoalInfo &thisGoal=theProblem.goals[i];
    // only take the first goal
    if((thisGoal.objective_flag==true)&&(objective=="")){
      objective=thisGoal.goal;
      impactFileName=thisGoal.impact_file;
      statistic=thisGoal.measure.front();
    }
    else
      if((thisGoal.goal=="ns")&&(numFacilitiesToOpen==-1))
	numFacilitiesToOpen=int(rint(thisGoal.bound.front()));
  }
}


void ProblemSolver::setParamForSideConst() {
  gamma = theProblem.gamma;
  numFacilitiesToOpen = -1;
  for(size_t i=0;i<theProblem.goals.size();++i){
    SPGoalInfo &thisGoal=theProblem.goals[i];
      // only take the first goal that is flagged as an objective -
      // the rest will be treated as side-constraints (the error
      // should have been picked up in the sp driver script)
    if((thisGoal.objective_flag==true)&&(objective=="")){
      if(thisGoal.bound.size()>2) {
        std::cout << "***More than one side constraint bound was specified for the objective=" << objective << std::endl;
        exit(1);
      }

      objective=thisGoal.goal;
      impactFileName=thisGoal.impact_file;
      std::list<std::string>::const_iterator measureCurrIter=thisGoal.measure.begin();
      std::list<std::string>::const_iterator measureEndIter=thisGoal.measure.end();
      std::list<double>::const_iterator boundCurrIter=thisGoal.bound.begin();
      std::list<double>::const_iterator boundEndIter=thisGoal.bound.end();
      for(;measureCurrIter!=measureEndIter;++measureCurrIter,++boundCurrIter) {
        std::string thisMeasure=(*measureCurrIter);
        double thisBound=(*boundCurrIter);
        if(thisBound==SPGoalInfo::OBJECTIVE_GOAL_BOUND)
          statistic=thisMeasure;
        else {
          sideConstraintObjectives.push_back(thisGoal.goal);
          sideConstraintImpactFiles.push_back(thisGoal.impact_file);
          sideConstraintUpperBounds.push_back(thisBound);
          sideConstraintStatistics.push_back(thisMeasure);
        }
      }
    }
    else {
      if (thisGoal.goal=="ns"){
        if (numFacilitiesToOpen==-1)
          numFacilitiesToOpen=int(rint(thisGoal.bound.front()));
        else {
          std::cout << "***The number of sensors is muliply specified" << std::endl;
          exit(1);
        }
      }
      else {
        sideConstraintObjectives.push_back(thisGoal.goal);
        sideConstraintImpactFiles.push_back(thisGoal.impact_file);
        sideConstraintUpperBounds.push_back(thisGoal.bound.front());
        std::string thisStatistic(thisGoal.measure.front());
        sideConstraintStatistics.push_back(thisStatistic);
      }
    }
  }
} 


void ProblemSolver::validParameter() {
  /////////////////////////////////////////////////////////
  // validate the problem-specific parameters. shouldn't //
  // be necessary, but you never know...                 //
  /////////////////////////////////////////////////////////
  std::cout << "Max number of facilities to open=" << numFacilitiesToOpen << std::endl;
  if(numFacilitiesToOpen<0) {
    std::cout << "***The value of p must be >= 0" << std::endl;
    exit(1) ;
  }
  std::cout << "P=" << numFacilitiesToOpen << std::endl;
  if(objective==""){
    std::cout << "***No objective was specified" << std::endl;
    exit(1) ;
  }
  if(statistic==""){
    std::cout << "No statistic was specified" << std::endl;
    exit(1) ;
  }
  std::cout << "Objective=" << objective << std::endl;
}


void ProblemSolver::preLoadImpactFile() {
  ////////////////////////////////////////////////////////////////////
  // determine whether a sparse matrix (0) or dense matrix (1)      //
  // representation will be used to store the impact file coontents //
  ////////////////////////////////////////////////////////////////////
  // TNT: Added representation types 2 and 3
  if (inputMode==3)
    impactFileRepresentation = atoi(argv[6]); 
  else
    impactFileRepresentation = atoi(argv[4]);
  if((impactFileRepresentation!=0)&&
     (impactFileRepresentation!=1)&&
     (impactFileRepresentation!=2)&&
     (impactFileRepresentation!=3)) {
    std::cout << "***Unknown impact file representation=" << impactFileRepresentation << std::endl;
    exit(1) ;
  }
  std::cout << "Impact file representation=" << impactFileRepresentation << std::endl;
}

void ProblemSolver::loadImpactFile() {
  //////////////////////////
  // load the impact file //
  //////////////////////////
  std::cout << "Instance filename=" << impactFileName << std::endl;
  instance = new ProblemInstance;
  FILE *inputImpactFile=fopen(impactFileName.c_str(),"r");
  if(!inputImpactFile)
    std::cout << "***Failed to read problem instance=" << impactFileName << std::endl;
  if(impactFileRepresentation==0)
    instance->enableSparseRepresentation();
    // employ sparse storage scheme
  else if(impactFileRepresentation==1)
    instance->enableDenseRepresentation();
    // employ dense storage scheme
  else if(impactFileRepresentation==2)
    instance->enableFileBasedRepresentation();
    // employ dense storage scheme
  else if(impactFileRepresentation==3)
    instance->enableCachedRepresentation();
    // employ dense storage scheme

  // always needed for imperfect sensors
  if (inputMode==3){
    instance->enableArrivalSequenceStorage();
    instance->readImpact(inputImpactFile,numFacilitiesToOpen,theProblem.feasible_location,theProblem.reduced_repn_map);
  }
  else
    instance->readImpact(inputImpactFile,numFacilitiesToOpen,theProblem.feasible_location,theProblem.reduced_repn_map,false);

  fclose(inputImpactFile);
  // post-impact validations...
  if(numFacilitiesToOpen > instance->getM()) {
    numFacilitiesToOpen = instance->getM();
    instance->setP(numFacilitiesToOpen);
//std::cout << "***The value of p must be <= the number of potential facilities" << std::endl;
    //exit(1) ;
  }
  std::cout<<"Problem Define: n=" << (instance->getN())
           << ", p=" << (instance->getP())
           << ", m=" << (instance->getM())
           << ".\n";
}

  ///////////////////////////////////////////
  // load the side constraint impact files //
  ///////////////////////////////////////////
void ProblemSolver::loadSideFile() {
  for(size_t i=0;i<sideConstraintImpactFiles.size();i++){
    ProblemInstance* newInstance = new ProblemInstance;
    FILE *inputSideConstraintImpactFile=fopen(sideConstraintImpactFiles[i].c_str(),"r");
    if(!inputSideConstraintImpactFile)
      std::cout << "***Failed to read problem instance=" << sideConstraintImpactFiles[i] << std::endl;
    if(impactFileRepresentation==0)
      newInstance->enableSparseRepresentation();
    else
      newInstance->enableDenseRepresentation();
    newInstance->readImpact(inputSideConstraintImpactFile,numFacilitiesToOpen,theProblem.feasible_location,theProblem.reduced_repn_map, false);
    fclose(inputSideConstraintImpactFile);
    sideConstraintInstances.push_back(newInstance);
  }
}

  //////////////////////////////////////////////////////////////
  // verify that all of the side constraint impact files have //
  // the same dimensions as the primary objective impact file //
  //////////////////////////////////////////////////////////////
void ProblemSolver::validSideConst(){
  for(size_t i=0;i<sideConstraintInstances.size();i++){
    if(sideConstraintInstances[i]->getM()!=instance->getM()){
      std::cout << "***Mistmatch in number of facilities between optimization impact file and side-constraint impact file=" << sideConstraintImpactFiles[i] << std::endl;
      exit(1);
    }
    if(sideConstraintInstances[i]->getN()!=instance->getN()){
      std::cout << "***Mistmatch in number of customers between optimization impact file and side-constraint impact file=" << sideConstraintImpactFiles[i] << std::endl;
      exit(1);
    }
  }
  // only deal with one side constraint for now (it's hard enough to solve efficiently)...
  if(sideConstraintInstances.size()>1){
    std::cout << "***The heuristic presently supports specification of a single side constraints" << std::endl;
    exit(1);
  }
}



void ProblemSolver::loadFixs() {
  fixeds=theProblem.fixed_placements;
  // validate the fixed placements - ideally, SPProblem should
  // do this, but the combination of it and the sp script 
  // aren't ensuring this as of yet.
  for(size_t i=0;i<fixeds.size();++i) {
    if((fixeds[i]<=0)||(fixeds[i]>instance->getM())){
      std::cout << "***Illegal fixed node index specified, value=" << fixeds[i] << std::endl;
      exit(1) ;
    }
  }
  std::cout << "Fixed placements(" << fixeds.size() << ")=";
  for(size_t i=0;i<fixeds.size();++i)
    std::cout << fixeds[i] << " ";
  std::cout << std::endl;
}

void ProblemSolver::loadInvalids() {
  invalids=theProblem.invalid_placements;
  // validate the invalid placements - ideally, SPProblem should
  // do this, but the combination of it and the sp script aren't 
  // ensuring this as of yet.
  for(size_t i=0;i<invalids.size();++i) {
    if((invalids[i]<=0)||(invalids[i]>instance->getM())){
      std::cout << "***Illegal invalid node index specified, value=" << invalids[i] << std::endl;
      exit(1) ;	
    }
  }
  std::cout << "Invalid placements(" << invalids.size() << ")=";
  for(size_t i=0;i<invalids.size();++i)
    std::cout << invalids[i] << " ";
  std::cout << std::endl;
  int effectiveP(numFacilitiesToOpen-fixeds.size());
  if(effectiveP<0) {
    std::cout << "***The number of fixed sensor locations must be <= p" << std::endl;
    exit(1) ;
  }
  std::cout << "Effective P=" << effectiveP << std::endl;
}


void ProblemSolver::loadProbability(){
  std::ifstream detectionProbabilitiesInputFile(argv[2]);
  if(!detectionProbabilitiesInputFile)  {
    std::cout << "***Failed to open category definition input file=" << argv[2] << std::endl;
    exit(1);
  }
  int category;
  double probability;
  detectionProbabilitiesInputFile >> category >> probability;
  while(detectionProbabilitiesInputFile){
    if(rawDetectionProbability.find(category)!=rawDetectionProbability.end())
      std::cout << "Multiple entries for category=" << category << " were defined - all but the first are ignored" << std::endl;
    else
      rawDetectionProbability[category]=probability;
    detectionProbabilitiesInputFile >> category >> probability;
  }
  detectionProbabilitiesInputFile.close();
  std::cout << "Number of detection categories=" << rawDetectionProbability.size() << std::endl;
}

void ProblemSolver::loadLocationSensorMap(){
  /////////////////////////////////////////////////////////////
  // load the location->sensor map, which assigns a category //
  // to each potential sensor location                       //
  /////////////////////////////////////////////////////////////
  std::ifstream locationCategoryInputFile(argv[3]);
  if(!locationCategoryInputFile){
    std::cout << "***Failed to open location category input file=" << argv[3]  << std::endl;
    exit(1);
  }
  int location, category;
  locationCategoryInputFile >> location >> category;
  while(locationCategoryInputFile) {
    if(locationCategory.find(location)!=locationCategory.end())
      std::cout << "Multiple categories for location=" << location << " were defined - all but the first are ignored" << std::endl;
    else if(rawDetectionProbability.find(category)==rawDetectionProbability.end())
      std::cout << "Category=" << category << " (location=" << location << ") was not defined in the category definition input file" << std::endl;
    else
      locationCategory[location]=category;
    locationCategoryInputFile >> location >> category;
  }
  locationCategoryInputFile.close();
  std::cout << "Number of location-to-category entries=" << locationCategory.size() << std::endl;
  if(int(locationCategory.size())!=instance->getM()){
    std::cout << "A category must be assigned to each location" << std::endl;
    exit(1);
  }
}

void ProblemSolver::loadProbabilityComp(){
  // create a compiled version of the sensor location probability of detection
  detectionProbability = std::vector<double> (instance->getM()+1, 0.0);
  for(int i=1;i<=instance->getM();i++)
    detectionProbability[i]=rawDetectionProbability[locationCategory[i]];

}



void ProblemSolver::loadAlgParam() {
  if (inputMode == 3){
    numSamples = atoi(argv[4]);
    randomSeed = atoi(argv[5]);
    timeLimit = atof(argv[7]);
  }
  else {
    numSamples = atoi(argv[2]);
    randomSeed = atoi(argv[3]);
    timeLimit = atof(argv[5]);
  }
  if(numSamples<=0){
    std::cout << "***The number of samples must be >= 1" << std::endl;
    exit(1) ;
  }
  std::cout << "Number of requested samples=" << numSamples << std::endl;
  if(randomSeed<=0)
    {
      std::cout << "***The random number seed must be >= 1" << std::endl;
      exit(1) ;
    }
  srandom(randomSeed);
  std::cout << "Random number seed=" << randomSeed << std::endl;  
  if(timeLimit<0.0){
    std::cout << "***The time limit must be >= 0.0" << std::endl;
    exit(1) ;
  }
  std::cout << "WallClock Time Limit=" << timeLimit << std::endl;  
}
 
void ProblemSolver::setConstraints() { 
  // construct the facility location constraint vector. //
  // the array is 1-based, like the facility indices    //
  // 0=no constraints, free to place facility           //
  // 1=fixed facility location                          //
  // 2=invalid facility location                        //
  ////////////////////////////////////////////////////////
  #ifdef OPTIMER
    facilityLocationConstraints = new int[theProblem.num_nodes+1];
    for(size_t i=0;i<= theProblem.num_nodes;++i)
      facilityLocationConstraints[i]=0;
  #else
    facilityLocationConstraints = std::vector<int>(theProblem.num_nodes+1, 0);
  #endif
  for(size_t i=0;i<fixeds.size();++i)
    facilityLocationConstraints[fixeds[i]]=1;
  for(size_t i=0;i<invalids.size();++i){
    if(facilityLocationConstraints[invalids[i]]!=0)
      std::cout << "***WARNING - Over-riding fixed facility location index=" 
                << invalids[i] << " with an invalid constraint" << std::endl;
    facilityLocationConstraints[invalids[i]]=2;
  }
}

void ProblemSolver::getNodeArrival(){
 /////////////////////////////////////////////////////////////////////
  // compile the node arrival sequences into a map-based lookup form //
  /////////////////////////////////////////////////////////////////////
  nodeArrivalSequence=std::vector<std::vector<std::pair<int,double> > >((static_cast<ProblemInstance*>(instance))->arrivalSequences());
  //std::map<int,double> myMap;
  //nodeArrivalTime = std::vector<std::map<int,double> >(instance->getN()+1, myMap);
  nodeArrivalTime = std::vector<std::map<int,double> >(instance->getN()+1);
  for(int i=1;i<=instance->getN();i++){
    const std::vector<std::pair<int,double> > &thisSequence(nodeArrivalSequence[i]);
    for(size_t j=0;j<thisSequence.size();j++)
      nodeArrivalTime[i][thisSequence[j].first]=thisSequence[j].second;
  }
}

void ProblemSolver::setSearchStart() {
  std::cout << "Starting iterated descent" << std::endl;
  runtime_start = CPUSeconds();
  minCost = DBL_MAX;
  sumCosts = 0.0;
  maxCost = 0.0;
  initialCost = 0.0;
  std::cout.setf(std::ios_base::fixed,std::ios_base::floatfield);
  std::cout.precision(2);
}

void ProblemSolver::setSolutionType(){
  if (inputMode==3){
    bestSolution = new MeanSolution(instance, false);
    initialSolution = new MeanSolution(instance, true);
  }
  else{
  if (statistic == "mean"){
    bestSolution = new MeanSolution(instance, false);
    initialSolution = new MeanSolution(instance, true);
  }
  else if (statistic == "worst"){
    bestSolution = new WorstSolution(instance);
    initialSolution = new WorstSolution(instance);
  }
  else if (statistic == "var"){
    bestSolution = new VarSolution(instance);
    initialSolution = new VarSolution(instance);
  }
  else if (statistic == "tce"){
    bestSolution = new TceSolution(instance);
    initialSolution = new TceSolution(instance);
  }
  else {
      std::cout << "Unknown performance statistic=" << statistic << std::endl << std::endl;
      abort();
  }
  }
  std::cout << "Performance statistic=" << statistic << std::endl << std::endl;
}

void ProblemSolver::loadAll() {

  if (inputMode==3)
    checkImperfectArgc();
  else
    checkArgc();
  readConfig();
  if (inputMode==2)
    setParamForSideConst();
  else
    setParameter(); 
  validParameter();
  preLoadImpactFile();
  loadImpactFile();
  if (inputMode==2){
    loadSideFile();
    validSideConst();
  }
  loadFixs();
  loadInvalids();
  if (inputMode==3){
    loadProbability();
    loadLocationSensorMap();
    loadProbabilityComp();
    getNodeArrival();
  }
  loadAlgParam();
  setConstraints();
  setSolutionType();
}

void ProblemSolver::initializeSolution() {
  initialSolution->reset();
  InitialSolution myIniSol;
  std::cout << "Initializing for statistic " << statistic << std::endl;
  if(statistic=="mean")
    myIniSol.GreedySampling(initialSolution, numFacilitiesToOpen, 2, facilityLocationConstraints);
  else
    myIniSol.GreedyWorst(initialSolution,numFacilitiesToOpen,facilityLocationConstraints);
  initialCost = initialSolution->cost(gamma);
}


int ProblemSolver::runProcess()
{
  initialTime();  // start time;
    if (argc == 8)
        jsonOutputFile.open(argv[7]);
    jsonOutputFile << "{" << std::endl;
    jsonOutputFile << "\"solutions\": [" << std::endl;

  loadAll(); // load all necessary files;
  if(instance->getImpactCache() != NULL) {
    instance->getImpactCache()->setNodeMajor();
  }
  if (inputMode==2) {
    mySideIns = new SideConstraintInstance(instance, initialSolution, statistic, facilityLocationConstraints, gamma, sideConstraintStatistics, sideConstraintInstances, sideConstraintSolutions, sideConstraintUpperBounds); }
  else if (inputMode==3) {
    myImperfect = new ImperfectInstance(*initialSolution, nodeArrivalSequence, nodeArrivalTime, facilityLocationConstraints, detectionProbability);
  }
  setSearchStart(); // set statistics;
  // If we're only picking one facility, we'll be greedy (and optimal), so
  // no need to iterate.
  if (numFacilitiesToOpen == 1) numSamples=1;
  for(int i=1;i<=numSamples;++i){ // run numSamples;
    //WallClockIter_start = WallClockSeconds();
    if((i%STATUS_INTERVAL)==0)
      std::cout << "Generated " << i << " samples so far" << std::endl;
    WallClockIter_start = WallClockSeconds();
    //std::cout << "runProcess - inputMode=" << inputMode << std::endl;
    if (inputMode==2)
      mySideIns->runSearch(initialCost);
    else if (inputMode==3)
      myImperfect->runSearch(initialCost, localOptimumCost);
    else {
      initializeSolution();
      if (numFacilitiesToOpen > 1)
	initialSolution->descend(gamma, facilityLocationConstraints);
    }
    
    //std::cout << "Iteration #" << i << " " << (WallClockSeconds()-WallClockIter_start) << std::endl;;
    printResult(i);
    updateBestSol();
    updateCost();
    if (timeLimit > 0.0) {
      std::cout << "Iteration #" << i << " " << (WallClockSeconds()-WallClockIter_start) << std::endl;;
      if ((WallClockSeconds() - WallClockSeconds_start) > timeLimit) break;
    }
    std::cout.flush();
  }
    if (argc == 8) {
        jsonOutputFile << std::endl << "]" << std::endl;
        jsonOutputFile << "}" << std::endl;
        jsonOutputFile.close();
    }
  printFinalStat();
  return 0;
}

void ProblemSolver::getLocation(ProblemSolution* theSolution) {
  int numFacs=initialSolution->getNumP();
  locations.clear();
  locations.reserve(numFacs);
  for(int j=1;j<=numFacs;j++)
    locations.push_back(initialSolution->getFacility(j));
  std::sort(locations.begin(),locations.end());
}

void ProblemSolver::printResult(int i) {
  if (inputMode!=3)
    localOptimumCost=initialSolution->cost(gamma);
  getLocation(initialSolution);
  std::cout << std::setw(4) << i << " [" << initialCost << "] -> [" << localOptimumCost << "]  Solution=[ ";
  for(size_t j=0;j<locations.size();j++)
    std::cout << locations[j] << " ";	  
  std::cout << "]";
  if(statistic=="worst")
    std::cout << " #-wc-scenarios=" << ((WorstSolution*) initialSolution)->numWorstCaseScenarios();
  if (inputMode==2){
  for(size_t j=0;j<sideConstraintObjectives.size();j++) {
    sideConstraintSolutions[j]->setSolution(*initialSolution);
    double sideConstraintEvaluation=sideConstraintSolutions[j]->cost(gamma);
    std::cout << sideConstraintObjectives[j] << "_" << sideConstraintStatistics[j] << "=" << sideConstraintEvaluation << " (ub=";
    std::cout << sideConstraintUpperBounds[j] << ") ";
  }
  }
}

void ProblemSolver::updateBestSol() {
  if(localOptimumCost<minCost){
    minCost=localOptimumCost;
    bestSolution->setSolution(*initialSolution);
    printBestToFile();
  }
  std::cout << std::endl;
}

void ProblemSolver::printBestToFile() {
  static bool first_json_solution = true;
  // output facility locations to file, if requested
  int num;
  if (inputMode==3)
    num=8;
  else
    num =6;
  if(argc>=(num+1)) {
    getLocation(bestSolution);
    int numFacs=initialSolution->getNumP();
    std::ofstream facilityOutputFile(argv[num]);
    if(!facilityOutputFile) {
      std::cerr << "***Failed to open facility output file=" << argv[num] << std::endl;
      exit(1) ;
    }
    facilityOutputFile << "#" << std::endl;
    facilityOutputFile << "# Generated by GRASP solver interface" << std::endl;
    facilityOutputFile << "#" << std::endl;
    facilityOutputFile << rand() << " "; // the ID
    facilityOutputFile << numFacs << " "; // the number of sensors
    for(size_t i=0;i<locations.size();++i)
      facilityOutputFile << locations[i] << " ";	  
    facilityOutputFile << std::endl;
    facilityOutputFile.close();
    std::cout << " <<<Best solution written to file=" << argv[num] << ">>>";
  }
  if(argc==(num+2)) {
                if (!first_json_solution) jsonOutputFile << "," << std::endl;
                first_json_solution = false;
                jsonOutputFile << "  {" << std::endl;
                jsonOutputFile << "  \"value\": " << minCost << "," << std::endl;
                jsonOutputFile << "  \"ids\": [ ";
                bool first=true;
                for (size_t i = 0; i < locations.size(); ++i)
                {
                    if (!first)
                        jsonOutputFile << ", ";
                    jsonOutputFile << locations[i];
                    first = false;
                }
                jsonOutputFile << " ]" << std::endl;
                jsonOutputFile << "  }";
  }
}

void ProblemSolver::updateCost() {
  sumCosts+=localOptimumCost;
  if(localOptimumCost>maxCost)
    maxCost=localOptimumCost;
}

void ProblemSolver::printFinalStat() {
  std::cout << std::endl;
  std::cout << "CPU RunTime=         " << (CPUSeconds() - runtime_start) << std::endl;
  std::cout << "CPU TotalTime=       " << (CPUSeconds() - CPUSeconds_start) << std::endl;
  std::cout << "WallClock TotalTime= " << (WallClockSeconds() - WallClockSeconds_start) << std::endl;
  std::cout << std::endl;
  std::cout << "Summary statistics" << std::endl;
  std::cout << "Minimum cost= " << minCost << std::endl;
  std::cout << "Average cost= " << sumCosts/double(numSamples) << std::endl;
  std::cout << "Maximum cost= " << maxCost << std::endl;
  std::cout << std::endl;
}






