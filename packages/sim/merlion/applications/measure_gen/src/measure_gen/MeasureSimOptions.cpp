#include <measure_gen/MeasureSimOptions.hpp>
#include <string>
#include <iostream>
#include <vector>
#include <cstdlib>

MeasureGenOptions::~MeasureGenOptions() 
{
   registered_options.clear(); 
}

MeasureGenOptions::MeasureGenOptions()
   :
   logging(false),
   disable_warnings(false),
   required_args(3),
   output_merlion_labels(false),
   print_concentrations(false),
   ignore_merlion_warnings(false),
   epanet_output_filename("epanet.rpt"),
   merlion_save_filename(""),
   inp_filename(""),
   wqm_filename(""),
   tsg_filename(""),
   tsi_filename(""),
   scn_filename(""),
   sensor_filename(""),
   nodemap_filename(""),
   output_prefix(""),
   tsi_species_id(-1),
   start_time_sensing(-1),
   stop_time_sensing(""),
   measurements_per_hour(-1),
   sim_duration_min(-1),
   qual_step_min(-1),
   threshold(0.0),
   sigma(-1.0f),
   seed(-1.0f),
   decay_k(-1.0f),
   FNR(0.0f),
   FPR(0.0f)
{

   std::stringstream descr;
   descr << "measuregen [options] " <<
            "<Required Network Option> " <<
            "<Required Scenario Option> " << 
            "<sensor-file> ";
   option_parser_.add_usage(descr.str());
   descr.str(std::string());
   descr << "A utility for measurement file generation. " << 
            "Measures are obtained by forward simulation " <<
            "of water distribution systems. The MEASURE.dat file generated can be used to perform source inversion. ";
   option_parser_.description = descr.str();
   option_parser_.version("measuregen 1.0");
   option_parser_.alias("version","v");
   
   // Add Epilog 
   option_parser_.epilog  = "The measuregen command perform a forward simulation and print a node-time-concentration list.";
   option_parser_.epilog += " This executable uses Merlion to perform water quality simulations ";
   // Add arguments
   option_parser_.add_argument("sensor node file", "A file with a list of sensor node names.");
   
   // Add Optional Arguments
   std::string cat_string;
   ////////////////// Required Network Option
   cat_string = "Required Network Option";
   // inp  
   descr.str(std::string());
   descr << "EPANET network file.";
   option_parser_.add("inp",inp_filename, descr.str());
   option_parser_.categorize("inp",cat_string);
   // wqm 
   descr.str(std::string());
   descr << "Merlion wqm file.";
   option_parser_.add("wqm",wqm_filename, descr.str());
   option_parser_.categorize("wqm",cat_string); 
  
   ////////////////// Required Scenario Option
   cat_string = "Required Scenario Option";
   // tsg
   descr.str(std::string());
   descr << "TSG file for specifying the injection incidents.";
   option_parser_.add("tsg",tsg_filename, descr.str());
   option_parser_.categorize("tsg",cat_string);
   // tsi
   descr.str(std::string());
   descr << "TSI file for specifying the injection incidents.";
   option_parser_.add("tsi",tsi_filename, descr.str());
   option_parser_.categorize("tsi",cat_string);
   // tsi-species-id
   descr.str(std::string());
   descr << "(*optional) The single TSI species id to use in each scenario by Merlion. "
         << "All other species will be ignored. If this option is not used and multiple "
         << "species ids are detected in the TSI file, an error will be thrown.";
   option_parser_.add("tsi-species-id",tsi_species_id, descr.str());
   option_parser_.categorize("tsi-species-id",cat_string);
   // scn 
   descr.str(std::string());
   descr << "SCN file for specifying the injection incidents.";
   option_parser_.add("scn",scn_filename, descr.str());
   option_parser_.categorize("scn",cat_string); 

  
   ////////////////// Save File Options
   cat_string = "Save Options";
   // epanet-rpt-file  
   descr.str(std::string());
   descr << "Output file generated by EPANET during hydraulic " <<
            "simulations." ;
   option_parser_.add("epanet-rpt-file",epanet_output_filename, descr.str());
   option_parser_.categorize("epanet-rpt-file",cat_string);
   // merlion-save-file  
   descr.str(std::string());
   descr << "Text file defining the Merlion water quality model.";
   option_parser_.add("merlion-save-file",merlion_save_filename, descr.str());
   option_parser_.categorize("merlion-save-file",cat_string);
  
   ////////////////// EPANET Input File Options
   cat_string = "EPANET Input File Options";
   // simulation-duration-minutes  
   descr.str(std::string());
   descr << "Length of simulation period to build Merlion water " << 
            "quality model. When specified, this value will " << 
            "override what is in the EPANET input file."; 
   option_parser_.add("simulation-duration-minutes",sim_duration_min, descr.str());
   option_parser_.categorize("simulation-duration-minutes",cat_string);
   // quality-timestep-minutes  
   descr.str(std::string());
   descr << "Size of water quality timestep used by Merlion to " << 
            "perform water quality simulations. When specified, " << 
            "this value will override what is in the EPANET " << 
            "input file.";
   option_parser_.add("quality-timestep-minutes",qual_step_min, descr.str());
   option_parser_.categorize("quality-timestep-minutes",cat_string);
  
   ////////////////// Label Options
   cat_string = "Label Options";
   // custom-label-map  
   descr.str(std::string());
   descr << "Simple file mapping EPANET node names to custom " <<
            "labels. All data files will be written using these " << 
            "custom labels.";
   option_parser_.add("custom-label-map",nodemap_filename, descr.str());
   option_parser_.categorize("custom-label-map",cat_string);
  
   // output-merlion-labels  
   descr.str(std::string());
   descr << "Node names will be translated into integer node IDs " <<
            "to reduce file sizes for large networks. A node map " <<
            "is provided to map node IDs back to node names " <<
            "(MERLION_LABEL_MAP.txt). This option is overridden  " <<
            "by the --custome-label-map flag.";
   option_parser_.add("output-merlion-labels",output_merlion_labels, descr.str());
   option_parser_.categorize("output-merlion-labels",cat_string); 
   
   ////////////////// Printed file Options
   cat_string = "Time options";
   // number of measures-per-hour
   descr.str(std::string());
   descr << "Number of measurements wanted to be taken per hour (default = 60)";
   option_parser_.add("measures-per-hour",measurements_per_hour, descr.str());
   option_parser_.categorize("measures-per-hour",cat_string);

   // Start inversion time
   descr.str(std::string());
   descr << "Time to start taking measurements(minutes) ";
   option_parser_.add("start-sensing-time",start_time_sensing, descr.str());
   option_parser_.categorize("start-sensing-time",cat_string);
   
   // Stop inversion time
   descr.str(std::string());
   descr << "Time to stop taking measurements(minutes)";
   option_parser_.add("stop-sensing-time",stop_time_sensing, descr.str());
   option_parser_.categorize("stop-sensing-time",cat_string);
   
   // To print concentrations rather than binary values
   descr.str(std::string());
   descr << "Concentration values will be printed in the measurement file";
   option_parser_.add("concentrations",print_concentrations, descr.str());
   option_parser_.categorize("concentrations",cat_string);
  
   //Threshold
   descr.str(std::string()); 
   descr << "Concentrations above this value will be positive measurements " << 
            "The default value is 0.0"; 
   option_parser_.add("threshold",threshold, descr.str());
   option_parser_.categorize("threshold",cat_string);

   //Reaction decay constant
   descr.str(std::string()); 
   descr << "First-order decay coefficient(1/min)." << 
            "The default value is taken from INP file"; 
   option_parser_.add("decay-const",decay_k, descr.str());
   option_parser_.categorize("decay-const",cat_string);
   
   ////////////////// Noise options
   cat_string = "Noise options";
   // scale
   descr.str(std::string());
   descr << "Scaling value to add noise to the base demand ";
   option_parser_.add("scale",sigma, descr.str());
   option_parser_.categorize("scale",cat_string);
   
   // seed
   descr.str(std::string());
   descr << "Seed to generate the random number used at the moment of adding noise. ";
   option_parser_.add("seed",seed, descr.str());
   option_parser_.categorize("seed",cat_string);
   
   // FNR
   descr.str(std::string());
   descr << "Common False Negative Rate for all sensors";
   option_parser_.add("FNR",FNR, descr.str());
   option_parser_.categorize("FNR",cat_string);
   
   // FPR
   descr.str(std::string());
   descr << "Common False Positive Rate for all sensors";
   option_parser_.add("FPR",FPR, descr.str());
   option_parser_.categorize("FPR",cat_string);
   
   ////////////////// Data Output Options
   cat_string = "Data Format Options";
   // output-prefix  
   descr.str(std::string());
   descr << "Prepend all output filenames with a string.";
   option_parser_.add("output-prefix",output_prefix, descr.str());
   option_parser_.categorize("output-prefix", cat_string);

   //////// Others
   cat_string = "Other Options";
   // ignore-merlion-warnings 
   descr.str(std::string());
   descr << "Ignore warnings about unsupported features of Merlion.";
   option_parser_.add("ignore-merlion-warnings",ignore_merlion_warnings, descr.str());
   option_parser_.categorize("ignore-merlion-warnings",cat_string);
   // enable-logging
   descr.str(std::string());
   descr << "Generates a logfile with verbose runtime information.";
   option_parser_.add("enable-logging",logging, descr.str());
   option_parser_.categorize("enable-logging",cat_string);
   // disable-warnings 
   descr.str(std::string());
   descr << "Disables printing of warning statements to stderr.";
   option_parser_.add("disable-warnings",disable_warnings, descr.str());
   option_parser_.categorize("disable-warnings",cat_string);
}

void MeasureGenOptions::print_summary(std::ostream& out)
{
   out << "\nSummary of Input Options\n";
   option_parser_.write_values(out);
   out << ";\n";
   out << std::endl;  
}

bool MeasureGenOptions::isDefault(std::string option_name) {
   return !option_parser_.initialized(option_name);
}

void MeasureGenOptions::parse_inputs(int argc, char** argv)
{
   // Parse the arguments
   utilib::OptionParser::args_t args = option_parser_.parse_args(argc,argv);

   

   // check for help or version request and exit  
   if (option_parser_.help_option()) {
      option_parser_.write(std::cout);
      exit(0);
   }
   if (option_parser_.version_option()) {
      option_parser_.print_version(std::cout);
      exit(0);
   }
      utilib::OptionParser::args_t::iterator curr = args.begin();
   ++curr;
   if (curr == args.end()) {
      option_parser_.write(std::cout);
      std::cerr << std::endl;
      std::cerr << "ERROR: Missing sensor file argument." << std::endl;
      std::cerr << std::endl;
      exit(1);
   }
   sensor_filename=*curr++;
   if (curr != args.end()) {
      std::cerr << std::endl;
      std::cerr << "WARNING: Extra command line arguments were detected after final argument." << std::endl;
      std::cerr << "         Optional arguments must go before required arguments, otherwise" << std::endl;
      std::cerr << "         they will be ignored." << std::endl;
      std::cerr << std::endl;
   }
}
