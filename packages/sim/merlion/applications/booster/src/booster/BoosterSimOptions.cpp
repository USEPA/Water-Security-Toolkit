#include "BoosterSimOptions.hpp"

#include <string>
#include <iostream>
#include <cstdlib>
#include <sstream>

BoosterSimOptions::BoosterSimOptions()
   :
   BoosterOptions(),
   report_scenario_timing(false),
   no_reduce(false),
   disable_scenario_aggregation(false),
   output_PYOMO(false),
   output_PYSP(false),
   detections_only(false),
   disable_reduced_problem(false),
   determine_single_impacts(false),
   scenario_weights_filename(""),
   chl_epanet_output_filename("booster-epanet.rpt"),
   tox_epanet_output_filename("tox-epanet.rpt"),
   chl_merlion_save_filename(""),
   tox_merlion_save_filename(""),
   tox_inp_filename(""),
   tox_wqm_filename(""),
   chl_inp_filename(""),
   chl_wqm_filename(""),
   tsg_filename(""),
   tsi_filename(""),
   scn_filename(""),
   dscn_filename(""),
   sensor_filename(""),
   booster_filename(""),
   wqm_inverse_filename(""),
   tsi_species_id(-1),
   max_rhs(1),
   postprocess_passes(2),
   detection_interval_min(-1),
   postprocess_tol(0.00001),
   detection_tol_gpm3(0.0f),
   zero_conc_tol_gpm3(0.0f),
   chl_decay_k(-1.0f),
   tox_decay_k(-1.0f),
   demand_percapita_m3pmin(0.0),
   ingestion_rate_m3pmin(0.0)
{
   std::stringstream descr;
   descr << "boostersim [Options] " << 
      "<Required Network Option> " << 
      "<Required Scenario Option> " << 
      "<Detection Option> " << 
      "<booster-spec-file>";
   option_parser_.add_usage(descr.str());
   descr.str(std::string());
   descr << "A utility for rapid scenario data generation " << 
      "used to determine optimal booster station locations " <<
      "in water distribution systems.";
   option_parser_.description = descr.str();
   option_parser_.version("boostersim 1.0");
   option_parser_.alias("version","v");

   // Add Epilog 
   option_parser_.epilog  = "The boostersim command is used to generate scenarios for finding optimal booster station locations ";
   option_parser_.epilog += "in water distribution systems. This executable uses Merlion to perform water quality simulations ";
   option_parser_.epilog += "on a scenario ensemble and generates the required data files to solve an optimization problem. ";

   // Add arguments
   option_parser_.add_argument("booster specifications file","A file defining booster station specifications.");

   // Add Optional Arguments
   std::string cat_string;
   ////////////////// Required Network Option
   cat_string = "Required Network Option (t-tox, 1-booster)";
   // tox-inp
   descr.str(std::string());
   descr << "EPANET network file for toxin.";
   option_parser_.add("tox-inp",tox_inp_filename, descr.str());
   option_parser_.categorize("tox-inp",cat_string);
   // tox-wqm 
   descr.str(std::string());
   descr << "Merlion wqm file for toxin.";
   option_parser_.add("tox-wqm",tox_wqm_filename, descr.str());
   option_parser_.categorize("tox-wqm",cat_string);
   // booster-inp  
   descr.str(std::string());
   descr << "EPANET network file for boosters.";
   option_parser_.add("booster-inp",chl_inp_filename, descr.str());
   option_parser_.categorize("booster-inp",cat_string);
   // booster-wqm 
   descr.str(std::string());
   descr << "Merlion wqm file for boosters.";
   option_parser_.add("booster-wqm",chl_wqm_filename, descr.str());
   option_parser_.categorize("booster-wqm",cat_string);

   ////////////////// EPANET Input File Options
   cat_string = "EPANET Input File Options";
   // booster-decay-const
   descr.str(std::string()); 
   descr << "First-order decay coefficient for booster agent(1/min)." << 
            "The default value is equal to bulk reaction k in INP file"; 
   option_parser_.add("booster-decay-const",chl_decay_k, descr.str());
   option_parser_.categorize("booster-decay-const",cat_string);
   // tox-decay-const
   descr.str(std::string()); 
   descr << "First-order decay coefficient for toxin(1/min). " << 
            "The default value is equal to bulk reaction k in INP file"; 
   option_parser_.add("tox-decay-const",tox_decay_k, descr.str());
   option_parser_.categorize("tox-decay-const",cat_string);
   // booster-epanet-rpt-file  
   descr.str(std::string());
   descr << "Output file generated by EPANET during hydraulic " <<
      "simulations for booster agent model." ;
   option_parser_.add("booster-epanet-rpt-file",chl_epanet_output_filename, descr.str());
   option_parser_.categorize("booster-epanet-rpt-file",cat_string);
   // tox-epanet-rpt-file  
   descr.str(std::string());
   descr << "Output file generated by EPANET during hydraulic " <<
      "simulations for toxin model." ;
   option_parser_.add("tox-epanet-rpt-file",tox_epanet_output_filename, descr.str());
   option_parser_.categorize("tox-epanet-rpt-file",cat_string);
   // booster-merlion-save-file  
   descr.str(std::string());
   descr << "Text file defining the Merlion water quality model for the boosters.";
   option_parser_.add("booster-merlion-save-file",chl_merlion_save_filename, descr.str());
   option_parser_.categorize("booster-merlion-save-file",cat_string);
   // tox-merlion-save-file  
   descr.str(std::string());
   descr << "Text file defining the Merlion water quality model for the toxin.";
   option_parser_.add("tox-merlion-save-file",tox_merlion_save_filename, descr.str());
   option_parser_.categorize("tox-merlion-save-file",cat_string);

   ////////////////// Detection Option
   cat_string = "Detection Option (**Required for TSG, TSI, or SCN file)";
   // sensors
   descr.str(std::string());
   descr << "**A file with a list of sensor node names and/or grab sample node-times.";
   option_parser_.add("sensors",sensor_filename, descr.str());
   option_parser_.categorize("sensors",cat_string);
   // wqm-inverse
   descr.str(std::string());
   descr << "**A Merlion water quality model reduced inverse file.";
   option_parser_.add("wqm-inverse",wqm_inverse_filename, descr.str());
   option_parser_.categorize("wqm-inverse",cat_string);
   // detection-tol-gpm3
   descr.str(std::string());
   descr << "Concentration threshold for required for detection. " <<
      "Defaults to using the sparsity tolerance used by the Merlion " <<
      "water quality model (smallest possible value).";
   option_parser_.add("detection-tol-gpm3",detection_tol_gpm3, descr.str());
   option_parser_.categorize("detection-tol-gpm3",cat_string);
   // detection-interval-minutes
   descr.str(std::string());
   descr << "An interval in minutes over which all detection times are " <<
      "rounded to.";
   option_parser_.add("detection-interval-minutes",detection_interval_min, descr.str());
   option_parser_.categorize("detection-interval-minutes",cat_string);

   ////////////////// Required Scenario Option
   cat_string = "Required Scenario Option";
   // tsg
   descr.str(std::string());
   descr << "TSG file for specifying the injection incidents.";
   option_parser_.add("tsg",tsg_filename, descr.str());
   option_parser_.categorize("tsg",cat_string);
   // tsi
   descr.str(std::string());
   descr << "TSI file for specifying the injection incidents.";
   option_parser_.add("tsi",tsi_filename, descr.str());
   option_parser_.categorize("tsi",cat_string);
   // tsi-species-id
   descr.str(std::string());
   descr << "(*optional) The single TSI species id to use in each scenario by Merlion. "
         << "All other species will be ignored. If this option is not used and multiple "
         << "species ids are detected in the TSI file, an error will be thrown.";
   option_parser_.add("tsi-species-id",tsi_species_id, descr.str());
   option_parser_.categorize("tsi-species-id",cat_string);
   // scn 
   descr.str(std::string());
   descr << "SCN file for specifying the injection incidents.";
   option_parser_.add("scn",scn_filename, descr.str());
   option_parser_.categorize("scn",cat_string);
   // dscn 
   descr.str(std::string());
   descr << "DSCN file for specifying the injection incidents (scn file with detection times).";
   option_parser_.add("dscn",dscn_filename, descr.str());
   option_parser_.categorize("dscn",cat_string);

   ////////////////// Timing Options
   cat_string = "Timing Options";
   // report-scenario-timing  
   descr.str(std::string());
   descr << "Reports time spent on individual scenario simulations.";
   option_parser_.add("report-scenario-timing",report_scenario_timing, descr.str());
   option_parser_.categorize("report-scenario-timing",cat_string);

   ////////////////// Speed Options  
   cat_string = "Speed Options";
   // max-rhs  
   descr.str(std::string());
   descr << "Use multiple right-hand sides when simulating " <<
      "booster station injections.\n"
      "\tinteger <= 0 try all rhs for a single scenario " <<
      "\tinteger >= 1 uses min(num,all_rhs) for block size";
   option_parser_.add("max-rhs",max_rhs, descr.str());
   option_parser_.categorize("max-rhs",cat_string);

   ////////////////// Data Output Options
   cat_string = "Data Format Options";
   // output-PYOMO  
   descr.str(std::string());
   descr << "Outputs data files in a format that is efficient for " <<
      "use with the Pyomo modeling language.";
   option_parser_.add("output-PYOMO",output_PYOMO, descr.str());
   option_parser_.categorize("output-PYOMO", cat_string);
   // output-PYSP  
   descr.str(std::string());
   descr << "Outputs necesarry data files for use with the PySp " <<
      "package in Coopr.";
   option_parser_.add("output-PYSP",output_PYSP, descr.str());
   option_parser_.categorize("output-PYSP", cat_string);
   option_parser_.categorize("output-prefix", cat_string);
   
   ////////////////// Postprocessing Options
   cat_string = "Postprocessing Options";
   // postprocess-passes 
   descr.str(std::string());
   descr << "Number of passes through postprocessing algorithim (DEFAULT: 2).";
   option_parser_.add("postprocess-passes",postprocess_passes, descr.str());
   option_parser_.categorize("postprocess-passes",cat_string);
   // postprocess-tol
   descr.str(std::string());
   descr << "Tolerance used by the postprocessing algorithim (DEFAULT: 0.00001). " <<
            "The postprocessing algorithm sorts the nonzero objective function coefficients " <<
            "in ascending order and removes the first n elements whose sum is no more than " <<
            "tol fraction of the entire objective function value (0.01% by default).";
   option_parser_.add("postprocess-tol",postprocess_tol, descr.str());
   option_parser_.categorize("postprocess-tol",cat_string);

   ////////////////// Scenario Generation Options
   cat_string = "Scenario Options";
   // disable-scenario-aggregation
   descr.str(std::string());
   descr << "Injection scenarios with identical detection " << 
      "times and chlorine injection lengths will be " << 
      "collapsed into single scenarios. This option " << 
      "disables that action.";
   option_parser_.add("disable-scenario-aggregation",disable_scenario_aggregation, descr.str());
   option_parser_.categorize("disable-scenario-aggregation",cat_string);
   // detection-only  
   descr.str(std::string());
   descr << "Disable the booster station simulations and only " <<
      "apply the sensor layout to determine detection times " <<
      "for toxin scenarios.";
   option_parser_.add("detections-only",detections_only, descr.str());
   option_parser_.categorize("detections-only",cat_string);
   // scenario-weights-filename
   descr.str(std::string());
   descr << "Applies weights to individual injection scenarios. The order of " <<
      "of this file must match that of the scenarios in the scenario input file, " <<
      "otherwise scenario weights will be incorrectly assigned.";
   option_parser_.add("scenario-weights-filename",scenario_weights_filename, descr.str());
   option_parser_.categorize("scenario-weights-filename",cat_string);

   ////////////////// Developer Options
   cat_string = "Developer Options (not recommended)";
   // without-reduction
   descr.str(std::string());
   descr << "Disables partial solution of the linear system. " << 
      "Supplying this flag will significantly increase " << 
      "simulation time.";
   option_parser_.add("without-reduction",no_reduce, descr.str());
   option_parser_.categorize("without-reduction",cat_string);
   // disable-reduced-problem  
   descr.str(std::string());
   descr << "Disables writing the reduced optimization problem " << 
      "after booster station simulations are performed.";
   option_parser_.add("disable-reduced-problem",disable_reduced_problem, descr.str());
   option_parser_.categorize("disable-reduced-problem",cat_string);
   // zero-conc-tol-gpm3
   descr.str(std::string());
   descr << "Zero concentration threshold for toxin or disinfectant. " <<
      "Defaults to using the sparsity tolerance used by the Merlion " <<
      "water quality model (smallest possible value).";
   option_parser_.add("zero-conc-tol-gpm3",zero_conc_tol_gpm3, descr.str());
   option_parser_.categorize("zero-conc-tol-gpm3",cat_string);
   // determine-single-impacts
   descr.str(std::string());
   descr << "Calculate the objective function impact for individual booster stations.";
   option_parser_.add("determine-single-impacts",determine_single_impacts, descr.str());
   option_parser_.categorize("determine-single-impacts",cat_string);

   ////////////////// Health Impact Parameters
   cat_string = "Health Impact Parameters";
   // demand-percapita-m3pmin
   descr.str(std::string()); 
   descr << "Per capita usage rate used to determine per-node population"
         << " (DEFAULT: 0)";
   option_parser_.add("demand-percapita-m3pmin",demand_percapita_m3pmin, descr.str());
   option_parser_.categorize("demand-percapita-m3pmin",cat_string);
   // ingestion-rate-m3pmin
   descr.str(std::string()); 
   descr << "Per capita ingestion rate used to determine population dosage impact"
         << " (DEFAULT: 0)";
   option_parser_.add("ingestion-rate-m3pmin",ingestion_rate_m3pmin, descr.str());
   option_parser_.categorize("ingestion-rate-m3pmin",cat_string);

}

void BoosterSimOptions::PrintSummary(std::ostream& out)
{
   out << "\nSummary of Input Options\n";
   option_parser_.write_values(out);
   out << ";\n";
   out << std::endl;
}

bool BoosterSimOptions::isDefault(std::string option_name) {
   return !option_parser_.initialized(option_name);
}

void BoosterSimOptions::ParseInputs(int argc, char** argv)
{

   // Parse the arguments
   utilib::OptionParser::args_t args = option_parser_.parse_args(argc,argv);

   // check for help or version request and exit  
   if (option_parser_.help_option()) {
      option_parser_.write(std::cout);
      exit(0);
   }
   if (option_parser_.version_option()) {
      option_parser_.print_version(std::cout);
      exit(0);
   }

   utilib::OptionParser::args_t::iterator curr = args.begin();
   ++curr;
   if (curr == args.end()) {
      option_parser_.write(std::cout);
      std::cerr << std::endl;
      std::cerr << "ERROR: Missing booster station spec file argument." << std::endl;
      std::cerr << std::endl;
      exit(1);
   }
   booster_filename = *curr++;
   if (curr != args.end()) {
      std::cerr << std::endl;
      std::cerr << "ERROR:   Extra command line arguments were detected after final argument." << std::endl;
      std::cerr << "         Optional arguments must go before required arguments, otherwise" << std::endl;
      std::cerr << "         they will be ignored." << std::endl;
      std::cerr << std::endl;
      exit(1);
   }
}
