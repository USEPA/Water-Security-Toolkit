#include "grab_sample_location/SampleLocationOptions.hpp"

#include <string>
#include <iostream>
#include <cstdlib>
#include <sstream>

SampleLocationOptions::SampleLocationOptions()
   :
   logging(false),
   output_merlion_labels(false),
   output_epanet_labels(false),
   disable_warnings(false),
   epanet_output_filename("epanet.rpt"),
   merlion_save_filename(""),
   inp_filename(""),
   wqm_filename(""),
   scn_filename(""),
   tsg_filename(""),
   tsi_filename(""),
   nodemap_filename(""),
   fixed_sensors_filename(""),
   allowedNodes_filename(""),
   output_prefix(""),
   output_impact_matrix(false),
   sample_time(-1),
   nSamples(1),
   sim_duration_min(-1),
   threshold(0.001),   
   qual_step_min(-1),
   decay_k(-1.0f),
   greedy(false),
   weights(false),
   merlion(false),
   RLE(false)
{
   std::stringstream descr;
   descr << "samplelocation [options] " <<
      "<Required Network Option> " <<
      "<Events Scenario Option> " <<
      "<sampling time (min) argument>";
   option_parser_.add_usage(descr.str());
   descr.str(std::string());
   descr << "A utility for impact matrix data generation " << 
      "used to determine optimal grab sample locations nodes " <<
      "in water distribution systems.";
   option_parser_.description = descr.str();
   option_parser_.version("samplelocation 1.0");
   option_parser_.alias("version","v");

   // Add Epilog 
   option_parser_.epilog  = "The samplelocation command is used to finding the optimal grab sample locations nodes ";
   option_parser_.epilog += "in water distribution systems. This executable uses Merlion to perform water quality simulations ";
   option_parser_.epilog += "and generates the required data files to solve an optimization problem. ";

   // Add arguments
   option_parser_.add_argument("Sample time", "Desired time [min] to take the grab samples");

   // Add Optional Arguments
   std::string cat_string;
   ////////////////// Required Network Option
   cat_string = "Required Network Option";
   // inp  
   descr.str(std::string());
   descr << "EPANET network file.";
   option_parser_.add("inp",inp_filename, descr.str());
   option_parser_.categorize("inp",cat_string);
   // wqm 
   descr.str(std::string());
   descr << "Merlion wqm file.";
   option_parser_.add("wqm",wqm_filename, descr.str());
   option_parser_.categorize("wqm",cat_string);
   
   ////////////////// Required Scenario Option
   cat_string = "Required Scenario Option";
   // tsg
   descr.str(std::string());
   descr << "TSG file for specifying the injection incidents.";
   option_parser_.add("tsg",tsg_filename, descr.str());
   option_parser_.categorize("tsg",cat_string);
   // tsi
   descr.str(std::string());
   descr << "TSI file for specifying the injection incidents.";
   option_parser_.add("tsi",tsi_filename, descr.str());
   option_parser_.categorize("tsi",cat_string);
   // scn 
   descr.str(std::string());
   descr << "SCN file for specifying the injection incidents.";
   option_parser_.add("scn",scn_filename, descr.str());
   option_parser_.categorize("scn",cat_string); 

   ////////////////// Save File Options
   cat_string = "Save Options";
   // epanet-rpt-file  
   descr.str(std::string());
   descr << "Output file generated by EPANET during hydraulic " <<
      "simulations." ;
   option_parser_.add("epanet-rpt-file",epanet_output_filename, descr.str());
   option_parser_.categorize("epanet-rpt-file",cat_string);
   // merlion-save-file  
   descr.str(std::string());
   descr << "Text file defining the Merlion water quality model.";
   option_parser_.add("merlion-save-file",merlion_save_filename, descr.str());
   option_parser_.categorize("merlion-save-file",cat_string);
   
   ////////////////// EPANET Input File Options
   cat_string = "EPANET Input File Options";
   // simulation-duration-minutes  
   descr.str(std::string());
   descr << "Length of simulation period to build Merlion water " << 
            "quality model. When specified, this value will " << 
            "override what is in the EPANET input file."; 
   option_parser_.add("simulation-duration-minutes",sim_duration_min, descr.str());
   option_parser_.categorize("simulation-duration-minutes",cat_string);
   // quality-timestep-minutes  
   descr.str(std::string());
   descr << "Size of water quality timestep used by Merlion to " << 
            "perform water quality simulations. When specified, " << 
            "this value will override what is in the EPANET " << 
            "input file.";
   option_parser_.add("quality-timestep-minutes",qual_step_min, descr.str());
   option_parser_.categorize("quality-timestep-minutes",cat_string);
   //Reaction decay constant
   descr.str(std::string()); 
   descr << "First-order decay coefficient(1/min)." << 
            "The default value is taken from the INP file"; 
   option_parser_.add("decay-const",decay_k, descr.str());
   option_parser_.categorize("decay-const",cat_string);
   
   ////////////////// Label Options
   cat_string = "Label Options";
   // custom-label-map  
   descr.str(std::string());
   descr << "Simple file mapping EPANET node names to custom " <<
            "labels. All data files will be written using these " << 
            "custom labels.";
   option_parser_.add("custom-label-map",nodemap_filename, descr.str());
   option_parser_.categorize("custom-label-map",cat_string);
   // output-merlion-labels  
   descr.str(std::string());
   descr << "Node names will be translated into integer node IDs " <<
            "to reduce file sizes for large networks. A node map " <<
            "is provided to map node IDs back to node names " <<
            "(LABEL_MAP.txt). This option is overridden  " <<
            "by the --custome-label-map flag.";
   option_parser_.add("output-merlion-labels",output_merlion_labels, descr.str());
   option_parser_.categorize("output-merlion-labels",cat_string);
   // output-epanet-labels  
   descr.str(std::string());
   descr << "Node names will be translated into integer node IDs " <<
            "to reduce file sizes for large networks. A node map " <<
            "is provided to map node IDs back to node names " <<
            "(LABEL_MAP.txt). This option is overridden  " <<
            "by the --custome-label-map flag.";
   option_parser_.add("output-epanet-labels",output_epanet_labels, descr.str());
   option_parser_.categorize("output-epanet-labels",cat_string);
   
   ////////////////// Data Output Options
   cat_string = "Data Format Options";
   // output-prefix  
   descr.str(std::string());
   descr << "Prepend all output filenames with a string.";
   option_parser_.add("output-prefix",output_prefix, descr.str());
   option_parser_.categorize("output-prefix", cat_string);
   
   ////////////////// Developer Options
   cat_string = "Developer Options (not recommended)";
   // enable-logging
   descr.str(std::string());
   descr << "Generates a logfile with verbose runtime information.";
   option_parser_.add("enable-logging",logging, descr.str());
   option_parser_.categorize("enable-logging",cat_string);
   // merlion
   descr.str(std::string());
   descr << "Use merlion to perform contaminant simulation.";
   option_parser_.add("merlion",merlion, descr.str());
   option_parser_.categorize("merlion",cat_string);
   // RLE
   descr.str(std::string());
   descr << "Use RLE compression for EPANET simulations.";
   option_parser_.add("rle",RLE, descr.str());
   option_parser_.categorize("rle",cat_string);
   // greedy-selection 
   descr.str(std::string());
   descr << "Uses Greedy approach to select locations. No optimization required.";
   option_parser_.add("greedy-selection",greedy, descr.str());
   option_parser_.categorize("greedy-selection",cat_string);
   // with-weights
   descr.str(std::string());
   descr << "Uses weights in the objective function.";
   option_parser_.add("with-weights",weights, descr.str());
   option_parser_.categorize("with-weights",cat_string);
   // disable-warnings 
   descr.str(std::string());
   descr << "Disables printing of warning statements to stderr.";
   option_parser_.add("disable-warnings",disable_warnings, descr.str());
   option_parser_.categorize("disable-warnings",cat_string);
   // ignore-merlion-warnings
   descr.str(std::string());
   descr << "Ignores warnings about unsupported features of Merlion.";
   option_parser_.add("ignore-merlion-warnings",ignore_merlion_warnings, descr.str());
   option_parser_.categorize("ignore-merlion-warnings",cat_string);
   // output-full-system
   descr.str(std::string());
   descr << "Simple file provinding information about the sample" <<
            "locations. The impact matrix is printed (ImpactMatrix.dat)" ;
   option_parser_.add("impact-matrix",output_impact_matrix, descr.str());   
   option_parser_.categorize("impact-matrix", cat_string);
   // fixed-sensor-filename
   descr.str(std::string());
   descr << "File providing list of fixed sensor locations" <<
            " that are always used for distinguishing b/w events." ;
   option_parser_.add("fixed-sensors",fixed_sensors_filename, descr.str());   
   option_parser_.categorize("fixed-sensors", cat_string);
   // allowed-nodes
   descr.str(std::string());
   descr << "File providing list of allowed grabsamplelocations" <<
            " that are always used for distinguishing b/w events." ;
   option_parser_.add("allowed-nodes",allowedNodes_filename, descr.str());   
   option_parser_.categorize("allowed-nodes", cat_string);
   ////////////////// Threshold Option
   cat_string = "Threshold Option";
   // simulation-duration-minutes  
   descr.str(std::string());
   descr << "Value to determine a contaminated entry of the impact matrix. " << 
            "The default value is 0.001"; 
   option_parser_.add("threshold",threshold, descr.str());
   option_parser_.categorize("threshold",cat_string);
   
   ////////////////// Number of samples option
   cat_string = "Number of Samples";
   // simulation-duration-minutes  
   descr.str(std::string());
   descr << "Number of samples to be taken. " << 
            "The default is 1"; 
   option_parser_.add("number-samples",nSamples, descr.str());
   option_parser_.categorize("number-samples",cat_string);
   }
   
   void SampleLocationOptions::print_summary(std::ostream& out)
   {
      out << "\nSummary of Input Options\n";
      option_parser_.write_values(out);
      out << ";\n";
      out << std::endl; 
   }
   
   void SampleLocationOptions::parse_inputs(int argc, char** argv)
   {
      // Parse the arguments
      utilib::OptionParser::args_t args = option_parser_.parse_args(argc,argv);
      std::string temp(""); 
      if (option_parser_.help_option()) {
         option_parser_.write(std::cout);
         exit(0);
      }
      if (option_parser_.version_option()) {
         option_parser_.print_version(std::cout);
         exit(0);
      }
      utilib::OptionParser::args_t::iterator curr = args.begin();
      ++curr;
      if (curr == args.end()) {
         option_parser_.write(std::cout);
         std::cerr << std::endl;
         std::cerr << "ERROR: Missing sample time." << std::endl;
         std::cerr << std::endl;
         exit(1);
      }
      temp=*curr++;      
      sample_time=atoi(temp.c_str());
      if (curr != args.end()) {
         std::cerr << std::endl;
         std::cerr << "WARNING: Extra command line arguments were detected after final argument." << std::endl;
         std::cerr << "         Optional arguments must go before required arguments, otherwise" << std::endl;
         std::cerr << "         they will be ignored." << std::endl;
         std::cerr << std::endl;
      }
   }
