#include <event_detection/EventDetectionOptions.hpp>

#include <string>
#include <iostream>
#include <vector>
#include <cstdlib>

EventDetectionOptions::EventDetectionOptions()
   :
   logging(false),
   yaml(false),
   json(false),
   detected_scn(false),
   disable_warnings(false),
   ignore_merlion_warnings(false),
   save_wqm_inverse(false),
   epanet_output_filename("epanet.rpt"),
   uniform_random_detection_times(false),
   multiple_detection_times(false),
   merlion_save_filename(""),
   inp_filename(""),
   wqm_filename(""),
   tsg_filename(""),
   tsi_filename(""),
   scn_filename(""),
   sensor_filename(""),
   output_prefix(""),
   wqm_inverse_filename(""),
   random_seed(0),
   tsi_species_id(-1),
   detection_interval_min(-1),
   sensor_interval_min(-1),
   sim_duration_min(-1),
   qual_step_min(-1),
   detection_tol_gpm3(-1),
   decay_k(-1.0f),
   detection_window_lower_min(-1),
   detection_window_upper_min(-1)
{
   std::stringstream descr;
   descr << "eventDetection [Options] " << 
            "<Required Network Option> " << 
            "<Required Scenario Option> " << 
            "<Required Detection Option>";
   option_parser_.add_usage(descr.str());
   descr.str(std::string());
   descr << "A utility for finding scenario detection times " << 
            "within a water distribution system with a fixed " <<
            "layout of sensor nodes and grab samples.";
   option_parser_.description = descr.str();
   option_parser_.version("eventDetection 1.0");
   option_parser_.alias("version","v");

   // Add Epilog 
   option_parser_.epilog  = "The eventDetction command is used to generate detection times for an ensemble of scenarios using ";
   option_parser_.epilog += "a list of sensor node locations. ";

   // Add Optional Arguments
   std::string cat_string;
   ////////////////// Required Network Option
   cat_string = "Required Network Option";
   // inp  
   descr.str(std::string());
   descr << "EPANET network file.";
   option_parser_.add("inp",inp_filename, descr.str());
   option_parser_.categorize("inp",cat_string);
   // wqm 
   descr.str(std::string());
   descr << "Merlion wqm file.";
   option_parser_.add("wqm",wqm_filename, descr.str());
   option_parser_.categorize("wqm",cat_string);

   ////////////////// Required Scenario Option
   cat_string = "Required Scenario Option";
   // tsg
   descr.str(std::string());
   descr << "TSG file for specifying the injection incidents.";
   option_parser_.add("tsg",tsg_filename, descr.str());
   option_parser_.categorize("tsg",cat_string);
   // tsi
   descr.str(std::string());
   descr << "TSI file for specifying the injection incidents.";
   option_parser_.add("tsi",tsi_filename, descr.str());
   option_parser_.categorize("tsi",cat_string);
   // tsi-species-id
   descr.str(std::string());
   descr << "(*optional) The single TSI species id to use in each scenario by Merlion. "
         << "All other species will be ignored. If this option is not used and multiple "
         << "species ids are detected in the TSI file, an error will be thrown.";
   option_parser_.add("tsi-species-id",tsi_species_id, descr.str());
   option_parser_.categorize("tsi-species-id",cat_string);
   // scn 
   descr.str(std::string());
   descr << "SCN file for specifying the injection incidents.";
   option_parser_.add("scn",scn_filename, descr.str());
   option_parser_.categorize("scn",cat_string);

   ////////////////// Data Output Options
   cat_string = "Data Format Options";
   // yaml  
   descr.str(std::string());
   descr << "Uses yaml file format for output file.";
   option_parser_.add("yaml",yaml, descr.str());
   option_parser_.categorize("yaml", cat_string);
   // json
   descr.str(std::string());
   descr << "Uses json file format for output file.";
   option_parser_.add("json",json, descr.str());
   option_parser_.categorize("json", cat_string);
   // dscn
   descr.str(std::string());
   descr << "Uses dscn file format for output file (scn file with detection times).";
   option_parser_.add("dscn",detected_scn, descr.str());
   option_parser_.categorize("dscn", cat_string);
   // output-prefix  
   descr.str(std::string());
   descr << "Prepend all output filenames with a string.";
   option_parser_.add("output-prefix",output_prefix, descr.str());
   option_parser_.categorize("output-prefix", cat_string);

   ////////////////// Save File Options
   cat_string = "Save Options";
   // epanet-rpt-file  
   descr.str(std::string());
   descr << "Output file generated by EPANET during hydraulic " <<
            "simulations." ;
   option_parser_.add("epanet-rpt-file",epanet_output_filename, descr.str());
   option_parser_.categorize("epanet-rpt-file",cat_string);
   // merlion-save-file  
   descr.str(std::string());
   descr << "Text file defining the Merlion water quality model.";
   option_parser_.add("merlion-save-file",merlion_save_filename, descr.str());
   option_parser_.categorize("merlion-save-file",cat_string);

   ////////////////// EPANET Input File Options
   cat_string = "EPANET Input File Options";
   // simulation-duration-minutes  
   descr.str(std::string());
   descr << "Length of simulation period to build Merlion water " << 
            "quality model. When specified, this value will " << 
            "override what is in the EPANET input file."; 
   option_parser_.add("simulation-duration-minutes",sim_duration_min, descr.str());
   option_parser_.categorize("simulation-duration-minutes",cat_string);
   // quality-timestep-minutes  
   descr.str(std::string());
   descr << "Size of water quality timestep used by Merlion to " << 
            "perform water quality simulations. When specified, " << 
            "this value will override what is in the EPANET " << 
            "input file.";
   option_parser_.add("quality-timestep-minutes",qual_step_min, descr.str());
   option_parser_.categorize("quality-timestep-minutes",cat_string);

   ////////////////// Required Detection Option
   cat_string = "Required Detection Option";
   // sensors
   descr.str(std::string());
   descr << "A file with a list of sensor node names and/or grab sample node-times.";
   option_parser_.add("sensors",sensor_filename, descr.str());
   option_parser_.categorize("sensors",cat_string);
   // wqm-inverse
   descr.str(std::string());
   descr << "Reads a Merlion water quality model reduced inverse file (prebuilt for a list of sensors).";
   option_parser_.add("wqm-inverse",wqm_inverse_filename, descr.str());
   option_parser_.categorize("wqm-inverse",cat_string);
   // uniform-random-detection-times
   descr.str(std::string());
   descr << "Assigns uniformly distributed random detection times"
	 << "to scenarios starting at the initial injection time.";
   option_parser_.add("uniform-random-detection-times",uniform_random_detection_times, descr.str());
   option_parser_.categorize("uniform-random-detection-times",cat_string);
   // multiple-detection-times
   descr.str(std::string());
   descr << "Assigns multiple detection times to scenarios starting at the initial injection time.";
   option_parser_.add("multiple-detection-times",multiple_detection_times, descr.str());
   option_parser_.categorize("multiple-detection-times",cat_string);
   // detection-window-upper-minutes
   descr.str(std::string());
   descr << "The amount of time after the initial injection time for a scenario "
         << "for which a detection time is allowed. "
         << "** Required when using multiple or uniform random detection time generation (ignored otherwise) **";
   option_parser_.add("detection-window-upper-minutes",detection_window_upper_min, descr.str());
   option_parser_.categorize("detection-window-upper-minutes",cat_string);
   // detection-window-lower-minutes
   descr.str(std::string());
   descr << "The amount of time after the initial injection time for a scenario "
         << "above which a detection time is allowed. "
         << "** Required when using multiple or uniform random detection time generation. (ignored otherwise) **";
   option_parser_.add("detection-window-lower-minutes",detection_window_lower_min, descr.str());
   option_parser_.categorize("detection-window-lower-minutes",cat_string);

   ////////////////// Other Options
   cat_string = "Other Options";
   // disable-warnings 
   descr.str(std::string());
   descr << "Disables printing of warning statements to stderr.";
   option_parser_.add("disable-warnings",disable_warnings, descr.str());
   option_parser_.categorize("disable-warnings",cat_string);
   // tox-decay-const
   descr.str(std::string()); 
   descr << "First-order decay coefficient for species(1/min).";
   option_parser_.add("decay-const",decay_k, descr.str());
   option_parser_.categorize("decay-const",cat_string);
   // ignore-merlion-warnings
   descr.str(std::string());
   descr << "Ignores warnings about unsupported features of Merlion.";
   option_parser_.add("ignore-merlion-warnings",ignore_merlion_warnings, descr.str());
   option_parser_.categorize("ignore-merlion-warnings",cat_string);
   // save-wqm-inverse
   descr.str(std::string());
   descr << "Saves Merlion water quality model reduced inverse.";
   option_parser_.add("save-wqm-inverse",save_wqm_inverse, descr.str());
   option_parser_.categorize("save-wqm-inverse",cat_string);
   // detection-tol-gpm3
   descr.str(std::string());
   descr << "Concentration threshold for required for detection. " <<
      "Defaults to using the sparsity tolerance used by the Merlion " <<
      "water quality model (smallest possible value).";
   option_parser_.add("detection-tol-gpm3",detection_tol_gpm3, descr.str());
   option_parser_.categorize("detection-tol-gpm3",cat_string);
   // detection-interval-minutes
   descr.str(std::string());
   descr << "An interval in minutes over which all detection times are " <<
      "rounded to.";
   option_parser_.add("detection-interval-minutes",detection_interval_min, descr.str());
   option_parser_.categorize("detection-interval-minutes",cat_string);
   // sensor-interval-minutes
   descr.str(std::string());
   descr << "An interval in minutes over which all sensor times are " <<
      "generated.";
   option_parser_.add("sensor-interval-minutes",sensor_interval_min, descr.str());
   option_parser_.categorize("sensor-interval-minutes",cat_string);
   // enable-logging
   descr.str(std::string());
   descr << "Generates a logfile with verbose runtime information.";
   option_parser_.add("enable-logging",logging, descr.str());
   option_parser_.categorize("enable-logging",cat_string);
   // random-seed
   descr.str(std::string());
   descr << "A seed used to generate random detection times.";
   option_parser_.add("random-seed",random_seed, descr.str());
   option_parser_.categorize("random-seed",cat_string);

}

void EventDetectionOptions::PrintSummary(std::ostream& out)
{
   out << "\nSummary of Input Options\n";
   option_parser_.write_values(out);
   out << ";\n";
   out << std::endl;
}

bool EventDetectionOptions::isDefault(std::string option_name) {
   return !option_parser_.initialized(option_name);
}

void EventDetectionOptions::ParseInputs(int argc, char** argv)
{
   // Parse the arguments
   utilib::OptionParser::args_t args = option_parser_.parse_args(argc,argv);

   // check for help or version request and exit  
   if (option_parser_.help_option()) {
      option_parser_.write(std::cout);
      exit(0);
   }
   if (option_parser_.version_option()) {
      option_parser_.print_version(std::cout);
      exit(0);
   }

   utilib::OptionParser::args_t::iterator curr = args.begin();
   ++curr;
   if (curr != args.end()) {
      std::cerr << std::endl;
      std::cerr << "WARNING: Extra command line arguments were detected after final argument." << std::endl;
      std::cerr << "         Optional arguments must go before required arguments, otherwise" << std::endl;
      std::cerr << "         they will be ignored." << std::endl;
      std::cerr << std::endl;
   }

   if (((uniform_random_detection_times == true) || (multiple_detection_times == true)) &&
       (isDefault("detection-window-lower-minutes") || isDefault("detection-window-upper-minutes"))) {
      std::cerr << std::endl;
      std::cerr << "ERROR: The \"detection-window-upper-minutes\" and \"detection-window-lower-minutes\" options are required "
                << "when using the \"multiple-detection-times\" or \"uniform-random-detection-times\" boolean flag." << std::endl;
      std::cerr << std::endl;
      exit(1);
   }

   if ((!isDefault("detection-window-lower-minutes")) && (!isDefault("detection-window-upper-minutes"))) {
      if (detection_window_upper_min <= detection_window_lower_min) {
         std::cerr << std::endl;
         std::cerr << "ERROR: The \"detection-window-upper-minutes\" option needs to be "
                   << "greater than \"detection-window-lower-minutes\"." << std::endl;
         std::cerr << std::endl;
         exit(1);
      }
   }


}
