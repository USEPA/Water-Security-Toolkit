import timeimport stringimport subprocessimport osimport mathimport tempfilefrom multiprocessing import Processimport _guiimport json # Python 2.6 or laterdef parseXYLine(line):	line = line.strip(string.whitespace)		# remove leading and trailing whitespace	line = line.expandtabs(1)					# change internal tabs into spaces	arr = line.split(";")						# remove any comments	arr = arr[0].split()						# create a string array with any whitespace as the delimiter	return arr[0:3]def parseXY(text):	data = []									# this will store our results	Lines = text.splitlines()					# make a string array from all the text in the inp file	sCOORDINATES = "[COORDINATES]"				# this is our target search string	bParseXY = False							# this is a flag that says we have reached the target area in the inp file	for line in Lines:							# cycle through each line in the file		sline = line.strip(string.whitespace)	# strip all white space from the start and end of this line		index = sline.find(";")					# search for the comment descriptor		if index == 0: continue					# if the comment descriptor is the first character move to next line		index = sline.find("[")					# each section heading in the inp file starts with an open bracket		if index == 0 and bParseXY: break		# if we found a new section AND we already started parsing coordinates, stop parsing coordinates		if bParseXY:							# if we are in the coordinates section...			arr = parseXYLine(line)				# get an array of items on that line			if len(arr) > 0:					# if the array contains at least one element...				data.append(arr)				# then add it to the data results array		if len(sline) == 0:	continue			# if this line only contains whitespace... then move on to the next line		index = sline.find(sCOORDINATES)		# is the coordinates header on this line?		if index > -1: bParseXY = True			# if we found the coordinates heading, begin parsing x's and y's at the next line	return data                                # once we have reached the end of this section... return the results # this routine runs the executable, jsonreader (compiled from json_reader.cpp).# it calls the EPANET API to read the INP file contents.def getData(sText, sExe):	temp = tempfile.NamedTemporaryFile()	temp.write(sText)	args = []	args.append(sExe)	args.append(temp.name)	sData = _gui.startProcess(args)	temp.close()	return json.loads(sData)def hasError(data):	if type(data) is str:		try:			d = json.loads(data)		except:			return 0	else:		d = data	try:		if d["error"]:			#_gui.respondJSON(json.dumps(d))			return 1	except:		pass	return 0def uploadJsonFile(sUuid, sFile, resString):	sFilename = os.path.splitext(sFile)[0] + ".json"	_gui.uploadFile(sUuid, sFilename, "text/plain", resString, bBinary=False)	return sFilenamedef _float(l):	l.extend(l)	y = float(l.pop())	x = float(l.pop())	id = l.pop()	return {"id":id,"x":x,"y":y}def sortXY_x(val):	return val["x"]def sortXY_y(val):	return val["y"]def runInp(sUuid, sFile, sDir):	Debug = []	if True:		nStart = time.time()		sExe = _gui.getConfig("config_inp_exe")		doc = _gui.getDoc(sUuid)		doc["status"] = "Loading"		_gui.setDoc(sUuid, doc)		#		sText = _gui.getFile(sUuid, sFile)		if len(sText) == 0:			error_text = "the http GET request for the INP file text returned a zero length string: \n\n        " + sFile			keys = ["status", "error", "Debug", "debug_sText"]			values = ["Error", error_text, Debug, sText]			_gui.setValues(sUuid, keys, values)			return		if hasError(sText):			error_text = "problem reading the INP file text from the couch document: \n\n        " + sFile			keys = ["status", "error", "Debug", "debug_sText"]			values = ["Error", error_text, Debug, sText]			_gui.setValues(sUuid, keys, values)			return		dataXY = parseXY(sText)		#		data = getData(sText, sExe)		if hasError(data):			error_text = "problem parsing the INP file text: \n\n        " + sFile			keys = ["status", "error", "Debug", "debug_data"]			values = ["Error", error_text, Debug, data]			_gui.setValues(sUuid, keys, values)			return		#		Nodes = data["Nodes"]		#Nodes = sorted(Nodes.iteritems())		for line in dataXY:			Nodes[line[0]]["id"] = line[0]			Nodes[line[0]]["x" ] = line[1]			Nodes[line[0]]["y" ] = line[2]			#Nodes[line[0]]["x" ] = float(line[1]) # use this if you want to store the			#Nodes[line[0]]["y" ] = float(line[2]) # coordinates as floats instead of strings			#Nodes[line[0]]["x" ] = float(line[1]) - 500			#Nodes[line[0]]["y" ] = float(line[2]) - 500		#		Missing = []				for id in Nodes:			bMissingX = False			bMissingY = False			try:				temp = Nodes[id]["x"]			except:				bMissingX = True			try:				temp = Nodes[id]["y"]			except:				bMissingY = True			#			if bMissingX or bMissingY:				Missing.append(id)		sMissing = ""		for i,id in enumerate(Missing):			if i == 0:				sMissing = id			else:				sMissing = sMissing + ", " + id		if len(Missing) > 50:			error_text = "Error: There are " + str(len(Missing)) + " nodes wihout coordinates. The case was not loaded."			keys = ["status", "error"]			values = ["Error", error_text]			_gui.setValues(sUuid, keys, values)			return		elif len(Missing) > 1:			error_text = "Error: There are " + str(len(Missing)) + " nodes wihout coordinates: \n\n" + sMissing + "\n\nThe case was not loaded."			keys = ["status", "error"]			values = ["Error", error_text]			_gui.setValues(sUuid, keys, values)			return		elif len(Missing) > 0:			error_text = "Error: There is one node without coordinates (" + sMissing + "). The case was not loaded."			keys = ["status", "error"]			values = ["Error", error_text]			_gui.setValues(sUuid, keys, values)			return		#		MissingXY,Xs,Ys,i = [],[],[],0		linkLengths = []		sumLengths = 0		Links = data["Links"]		Pipes = []		Pumps = []		Valves = []		LinkIds = {}		for link in Links:			LinkIds[link["ID"]] = i			link["index"] = i			i = i + 1		#	nFailed1 = 0			x1,y1,x2,y2 = None,None,None,None		#	try:			sx = Nodes[link["Node1"]]["x"]			link["x1"] = sx			x1 = float(sx)			Xs.append(x1)		#	except:		#		nFailed1 = 1		#		link["x1"] = 0		#	try:			sy = Nodes[link["Node1"]]["y"]			link["y1"] = sy			y1 = float(sy)			Ys.append(y1)		#	except:		#		nFailed1 = 1		#		link["y1"] = 0		#	if nFailed1 > 0:		#		MissingXY.append(link["Node1"])		#	#		#	nFailed2 = 0		#	try:			sx = Nodes[link["Node2"]]["x"]			link["x2"] = sx			x2 = float(sx)			Xs.append(x2)		#	except:		#		nFailed2 = 2		#		link["x2"] = 0		#	try:			sy = Nodes[link["Node2"]]["y"]			link["y2"] = sy			y2 = float(sy)			Ys.append(y2)		#	except:		#		nFailed2 = 2		#		link["y2"] = 0		#	if nFailed2 > 0:		#		MissingXY.append(link["Node2"])		#	#		#	link["MissingXY"] = nFailed1 + nFailed2			#			if x1 == None:break			if y1 == None:break			if x2 == None:break			if y2 == None:break			a2 = pow(x2-x1,2)			b2 = pow(y2-y1,2)			c2 = pow(a2+b2,0.5)			linkLengths.append(c2)			sumLengths += c2			#			if link["Type"] == "Pipe":				Pipes.append(link)			if link["Type"] == "Pump":				Pumps.append(link)			if link["Type"] == "Valve":				Valves.append(link)			#		MissingXY = list(set(MissingXY))		x_min = min(Xs)		y_min = min(Ys)		x_max = max(Xs)		y_max = max(Ys)		x_range = x_max - x_min		y_range = y_max - y_min		min_range = min(x_range,y_range)		max_range = max(x_range, y_range)				zFactor = 1		for i in range(0, -13, -1):			r = math.pow(10, i)			if min_range < r: zFactor = math.pow(10, math.ceil(-math.log(r, 10)) + 4)		#		if (zFactor < 2) :			xFactor = 0			yFactor = 0		else:			xFactor = x_min * zFactor			yFactor = y_min * zFactor		#		Factors = {"a": zFactor, "bx": xFactor, "by": yFactor}				x_min = x_min * zFactor - xFactor		y_min = y_min * zFactor - yFactor		x_max = x_max * zFactor - xFactor		y_max = y_max * zFactor - yFactor		x_range = x_max - x_min		y_range = y_max - y_min		min_range = min(x_range, y_range)		max_range = max(x_range, y_range)		#		for link in Links:			link["x1"] = str(float(link["x1"]) * zFactor - xFactor)			link["y1"] = str(float(link["y1"]) * zFactor - yFactor)			link["x2"] = str(float(link["x2"]) * zFactor - xFactor)			link["y2"] = str(float(link["y2"]) * zFactor - yFactor)		#		x_center = x_min + x_range / 2		y_center = y_min + y_range / 2		Bounds = {"min":{"x":x_min,"y":y_min},"max":{"x":x_max,"y":y_max}, "range":{"x":x_range,"y":y_range,"min":min_range,"max":max_range}}		Center = {"x":x_center,"y":y_center,"zoom":1}		nNodes = len(Nodes)		nLinks = len(Links)		avgLength = sumLengths / nLinks		#		linkLengths.sort()		#		Nodes = []		Junctions = []		Reservoirs = []		Tanks = []		idLength = []		NodeIds = {}		i = 0		for key, value in sorted(data["Nodes"].iteritems()):						value["x"] = str(float(value["x"]) * zFactor - xFactor)			value["y"] = str(float(value["y"]) * zFactor - yFactor)					Nodes.append(value)			if value["Type"] == "Junction":				Junctions.append(value)			if value["Type"] == "Reservoir":				Reservoirs.append(value)			if value["Type"] == "Tank":				Tanks.append(value)			idLength.append(len(value["id"]))			NodeIds[value["id"]] = i			i = i + 1		maxLength = max(idLength)		StringLen = {"Nodes":{"max":maxLength}}		#		#XY = map(_float, dataXY)		#XY.sort(key = sortXY_x)		#minR = 1e9		#for p1 in XY:		#	for p2 in XY:		#		if p1["id"] == p2["id"]:		#			continue		#		r = pow(pow(p1["x"]-p2["x"],2) + pow(p1["y"]-p2["y"],2),0.5)		#		if r < minR:		#			minR = r		#		#sum_length = 0		#for link in Links:		#	length = pow(pow(link["x1"]-link["x2"],2) + pow(link["y1"]-link["y2"],2),0.5)		#	sum_length += length		#length = sum_length / len(Links)		#		stdev = math.sqrt(sum((x - avgLength)**2 for x in linkLengths) / nLinks)		new_list = []		for x in linkLengths:			if x > avgLength + stdev:				continue			if x < avgLength - stdev:				continue			new_list.append(x)		#		new_len = len(new_list)		if new_len > 0:			new_avg = sum(new_list) / new_len		else:			new_avg = 0		r_min = 1.2 * max_range / 400		r_max = 1.2 * max_range / 50		r = math.sqrt(x_range * y_range / nNodes) / 3		if r < r_max: r_max = r		if r < r_min: r_max = r_min		r = new_avg / 4		if r > r_max: r = r_max		if r < r_min: r = r_min		#		doc = _gui.getDoc(sUuid)		doc["dotSize"] = r		doc["drawTransform"] = None # "rotate(180) scale(-1,1) translate(0,-0)"		_gui.setDoc(doc)		#		#		# opening tags		svgStart = "<svg><rect></rect><g id='gNetworkViewView_1' class='NetworkView1' transform===view_transform===>"		svgFile = svgStart		#		# pipes as individual paths		svgPipes = ""		path = "<path id='Pipe_{0}' data-id='{0}' data-type='Pipe' class='Link Pipe' d='{1}' stroke-width===pipe_stroke_width=== stroke='#000000' stroke-opacity='0.6' stroke-linecap='round' fill='none'></path>"		for link in Pipes:			d = "M " + link["x1"] + " " + link["y1"] + " L " + link["x2"] + " " + link["y2"]			svgPipes += path.format(link["ID"], d)		#		# pipes as one large path object		svgPipePath = "<path id='Pipes_1' class='Link Pipe' d='{0}' stroke-width===pipe_stroke_width=== stroke='#000000' stroke-opacity='0.6' stroke-linecap='round' fill='none'></path>"		d = ""		for link in Pipes:			d += " M " + link["x1"] + " " + link["y1"] + " L " + link["x2"] + " " + link["y2"]		svgPipePath = svgPipePath.format(d)		svgFile += svgPipePath		#		# nodes as individual circles		svgNodes = ""		circle = "<circle class='Node Junction' id='Node_{0}' data-id='{0}' data-type='Junction' r===junction_radius=== transform='translate({1},{2})' fill='#000000' fill-opacity='0.6'></circle>"		for node in Junctions:			svgNodes += circle.format(node["id"], node["x"], node["y"])		svgFile += svgNodes		#		# nodes as one large path object		svgNodePath = "<path id='Node_1' class='Node Junction' d='{0}' stroke='none' fill='#000000' fill-opacity='0.6'></path>"		d = ""		for node in Junctions:			x = float(node["x"])			y = float(node["y"])			M1 = " M " + node["x"] + " " + node["y"]			M2 = " m ===junction_radius=== 0"			A3 = " a ===junction_radius=== ===junction_radius=== 0 0 0 -===junction_radius_times_2=== 0"			A4 = " a ===junction_radius=== ===junction_radius=== 0 0 0 ===junction_radius_times_2=== 0"			d += M1 + M2 + A3 + A4		svgNodePath = svgNodePath.format(d)		#		svgTanks = ""		pathTank = "<path class='Node Tank' id='Node_{0}' data-id='{0}' data-type='Tank' d='{1}' stroke='none' fill='#000099' fill-opacity='0.6'></path>"		for node in Tanks:			svgTanks += pathTank.format(node["id"], getTankPath(node["x"], node["y"], r))		svgFile += svgTanks		#		svgReservoirs = ""		pathReservoir = "<path class='Node Reservoir' id='Node_{0}' data-id='{0}' data-type='Reservoir' d='{1}' stroke='none' fill='#009900' fill-opacity='0.6'></path>"		for node in Reservoirs:			svgReservoirs += pathReservoir.format(node["id"], getReservoirPath(node["x"], node["y"], r))		svgFile += svgReservoirs		#		svgPumps = ""		pathPump = "<path class='Link Pump' id='Pump_{0}' data-id='{0}' data-type='Pump' d='{1}' stroke='none' fill='#999900' fill-opacity='0.6'></path>"		for link in Pumps:			svgPumps += pathPump.format(link["ID"], getPumpPath(link["x1"], link["y1"], link["x2"], link["y2"], r))		svgFile += svgPumps		#		svgValves = ""		pathValve = "<path class='Link Valve' id='Valve_{0}' data-id='{0}' data-type='Valve' d='{1}' stroke='none' fill='#009999' fill-opacity='0.6'></path>"		for link in Valves:			svgValves += pathValve.format(link["ID"], getValvePath(link["x1"], link["y1"], link["x2"], link["y2"], r))		svgFile += svgValves		#		# closing tags		svgEnd = "</g></svg>"		#		# concat of all the pieces		svgFile = svgStart + svgPipePath + svgNodes + svgTanks + svgReservoirs + svgPumps + svgValves + svgEnd				#		filterList = "<select id='m_List_1' size='18' multiple>"		option = "<option id='m_List_1_{3}_{4}' class='m_List_1-option' data-value='{0}' data-x='{1}' data-y='{2}' data-type='{3}' data-id='{4}'>{4}</option>"		for i, node in enumerate(Junctions):			filterList += option.format(i, node["x"], node["y"], node["Type"], node["id"])		for i, node in enumerate(Reservoirs):			filterList += option.format(i, node["x"], node["y"], node["Type"], node["id"])		for i, node in enumerate(Tanks):			filterList += option.format(i, node["x"], node["y"], node["Type"], node["id"])		filterList += "</select>"		#		nodeList = "<select id='m_listInjNode' data-infrontof='poly2' style='width:107.5px;'>"		nodeList += "<option id data-value></option>"		option = "<option id='m_listInjNode_{0}' class='m_listInjNode-option' data-value='{1}'>{1}</option>"		for i, node in enumerate(Nodes):			nodeList += option.format(i, node["id"])		nodeList += "</select>"		#		items = []		items.append(createDictionaryItem("TimeData",      data["TimeData"] ))		items.append(createDictionaryItem("SimList",       data["SimList"]  ))		items.append(createDictionaryItem("zFactor",       Factors          ))		items.append(createDictionaryItem("NodeIds",       NodeIds          ))		items.append(createDictionaryItem("LinkIds",       LinkIds          ))		items.append(createDictionaryItem("StringLen",     StringLen        ))		items.append(createDictionaryItem("Center",        Center           ))		items.append(createDictionaryItem("Bounds",        Bounds           ))		items.append(createDictionaryItem("MissingXY",     MissingXY        ))		items.append(createDictionaryItem("Links",         Links            ))		items.append(createDictionaryItem("Nodes",         Nodes            ))		items.append(createDictionaryItem("Pipes",         Pipes            ))		items.append(createDictionaryItem("Valves",        Valves           ))		items.append(createDictionaryItem("Pumps",         Pumps            ))		items.append(createDictionaryItem("Tanks",         Tanks            ))		items.append(createDictionaryItem("Reservoirs",    Reservoirs       ))		items.append(createDictionaryItem("Junctions",     Junctions        ))		items.append(createDictionaryItem("Name",          sFile            ))		items.append(createDictionaryItem("nodeList",      nodeList         ))		items.append(createDictionaryItem("filterList",    filterList       ))		items.append(createDictionaryItem("svgStart",      svgStart         ))		items.append(createDictionaryItem("svgPipes",      svgPipes         ))		items.append(createDictionaryItem("svgPipePath",   svgPipePath      ))		items.append(createDictionaryItem("svgNodes",      svgNodes         ))		items.append(createDictionaryItem("svgNodePath",   svgNodePath      ))		items.append(createDictionaryItem("svgTanks",      svgTanks         ))		items.append(createDictionaryItem("svgReservoirs", svgReservoirs    ))		items.append(createDictionaryItem("svgPumps",      svgPumps         ))		items.append(createDictionaryItem("svgValves",     svgValves        ))		items.append(createDictionaryItem("svgEnd",        svgEnd           ))		resString = ",".join(items)		resString = "{" + resString + "}"		sFileJson = uploadJsonFile(sUuid, sFile, resString)		#		doc = _gui.getDoc(sUuid)		ObjectCount = {}		ObjectCount["Junctions"] = len(Junctions)		ObjectCount["Reservoirs"] = len(Reservoirs)		ObjectCount["Tanks"] = len(Tanks)		ObjectCount["Pumps"] = len(Pumps)		ObjectCount["Valves"] = len(Valves)		ObjectCount["Pipes"] = len(Pipes)		doc["ObjectCount"] = ObjectCount		doc["TimeData"] = data["TimeData"]		doc["jsonFile"] = sFileJson		doc["statusOld"] = doc["status"]		doc["status"] = "Complete"		#		######################################################		#		doc = _gui.setGetDoc(doc)		nTimer1 = time.time() - nStart		nStart2 = time.time()		#		doc["status"] = "Loading"		doc = _gui.setGetDoc(doc)		#		sDir = tempfile.gettempdir()		os.chdir(sDir)		fINP = tempfile.NamedTemporaryFile(delete=False, suffix='.inp')		fINP.write(sText)		fINP.close()		fMES = tempfile.NamedTemporaryFile(delete=False, suffix='.mes')		fMES.write(" ")		fMES.close()		sFileWqm = os.path.splitext(sFile)[0] + ".wqm"		args = []		sInstallDir = _gui.getInstallDir()		args.append(sInstallDir + "packages/sim/merlion/applications/inversionsim")		args.append("--inp")		args.append(fINP.name)		args.append("--merlion-save-file")		args.append(sFileWqm)		args.append(fMES.name)		sRetVal = _gui.startProcess(args)		sTemp = sDir + "/" + sFileWqm		try:			fWQM = open(sTemp, "rb")			sText = fWQM.read()			_gui.addAttachment(doc, sFileWqm, "wst-water-quality-model", sText)			Error = None		except:			fWQM = None			Error = "Error reading WQM file: " + sTemp		if _gui.bDeleteTempFiles(override=None):			_gui.removeFiles([fINP, fMES, fWQM])			_gui.removeFile("inversionsim.log")			_gui.removeFile("epanet.rpt")		#		doc = _gui.getDoc(sUuid)		if Error == None:			doc["status"] = "Complete"		else:			doc["status"] = "Error"			doc["Error"] = Error		doc["wqmFile"] = sFileWqm		doc["timer"] = time.time() - nStart		doc["timer1"] = nTimer1		doc["timer2"] = time.time() - nStart2		doc["Debug"] = Debug		_gui.setDoc(doc)	returndef runThreaded(sUuid, sFile, sDir, bThreaded=True):	if bThreaded:		p = Process(target=runInp, args=(sUuid, sFile, sDir, ))		p.start()	else:		runInp(sUuid, sFile, sDir)	returndef run(sUuid, sFile, bThreaded=True):	sDir = tempfile.gettempdir()	os.chdir(sDir)	runThreaded(sUuid, sFile, sDir, bThreaded=True)	return _gui.respondJSON(json.dumps({}))def main():	_gui.setHost()	for req in _gui.getRequests():		sDb = _gui.getQuery(req, "db")		_gui.setDatabase(sDb)		sUuid = _gui.getQuery(req, "uuid")		sFile = _gui.getQuery(req, "fileName")		bRetVal = run(sUuid, sFile, bThreaded=True)		if bRetVal: continue		_gui.respondJSON(json.dumps({}))		continuedef createDictionaryItem(key, value):	if type(value) == dict or type(value) == list:		return "\"" + key + "\":" + json.dumps(value)	elif type(value) == str or type(value) == unicode:		return "\"" + key + "\":\"" + value + "\""	else:		_gui.raiseDebugError("This argument is not a dict or a str: " + str(value) + ". type = " + str(type(value)))def getTankPath(_x, _y, r):	x = float(_x)	y = float(_y)	path = ""	path += " M " + str(x-0.7*r) + " " + str(y-1.0*r)	path += " l " + str(0-0.0*r) + " " + str(0+2.0*r)	path += " l " + str(0+0.1*r) + " " + str(0+0.0*r)	path += " l " + str(0+0.2*r) + " " + str(0-0.2*r)	path += " l " + str(0+0.2*r) + " " + str(0+0.2*r)	path += " l " + str(0+0.2*r) + " " + str(0-0.2*r)	path += " l " + str(0+0.2*r) + " " + str(0+0.2*r)	path += " l " + str(0+0.2*r) + " " + str(0-0.2*r)	path += " l " + str(0+0.2*r) + " " + str(0+0.2*r)	path += " l " + str(0+0.1*r) + " " + str(0+0.0*r)	path += " l " + str(0-0.0*r) + " " + str(0-2.0*r)	path += " a " + str(      r) + " " + str(      r) + " 0 0 0 " + str(0-1.4*r) + " " + str(0+0.0*r)	return pathdef getReservoirPath(_x, _y, r):	x = float(_x)	y = float(_y)	path = ""	path += " M " + str(x+0.0*r) + " " + str(y-0.6*r)	path += " A " + str(  0.5*r) + " " + str(  0.5*r) + " 0 1 1 " + str(x+0.57*r) + " " + str(y-0.19*r)	path += " A " + str(  0.5*r) + " " + str(  0.5*r) + " 0 1 1 " + str(x+0.35*r) + " " + str(y+0.49*r)	path += " A " + str(  0.5*r) + " " + str(  0.5*r) + " 0 1 1 " + str(x-0.35*r) + " " + str(y+0.49*r)	path += " A " + str(  0.5*r) + " " + str(  0.5*r) + " 0 1 1 " + str(x-0.57*r) + " " + str(y-0.19*r)	path += " A " + str(  0.5*r) + " " + str(  0.5*r) + " 0 1 1 " + str(x+0.00*r) + " " + str(y-0.60*r)	return pathdef getPumpPath(_x1, _y1, _x2, _y2, _r):	x1 = float(_x1)	y1 = float(_y1)	x2 = float(_x2)	y2 = float(_y2)	cx = 0.5 * (x1 + x2)	cy = 0.5 * (y1 + y2)	lx = x2 - x1	ly = y2 - y1	l = math.sqrt(lx * lx + ly * ly)	w = 0.2 * _r	n = 1.2 * w	try:		nx = lx * n / l		ny = ly * n / l	except:		nx = 0		ny = 0	r = 3 * n;	path = ""	path += " M " + str(cx - r) + " " + str(cy)	path += " a " + str(     r) + " " + str( r) + " 0 0 0 " + str(+r) + " " + str(+r)	path += " h " + str( 1.60 * r)	path += " v " + str(-0.80 * r)	path += " h " + str(-0.60 * r)	path += " v " + str(-0.20 * r)	path += " a " + str(r) + " " + str(r) + " 0 0 0 " + str(-0.5*r) + " " + str(-0.87*r)	path += " l " + str( 0.8 * r) + " " + str(-0.38*r)	path += " v " + str(-0.2 * r)	path += " h " + str(-2.6 * r)	path += " v " + str( 0.2 * r)	path += " l " + str( 0.8 * r) + " " + str( 0.38*r)	path += " a " + str(r) + " " + str(r) + " 0 0 0 " + str(-0.5*r) + " " + str(+0.87*r)	path += " M " + str(cx   ) + " " + str(cy   )	path += " L " + str(x1+ny) + " " + str(y1-nx)	path += " A " + str(n/2)   + " " + str(n/2)   + " 0 0 0 " + str(x1-ny) + " " + str(y1+nx)	path += " L " + str(cx   ) + " " + str(cy   )	path += " L " + str(x2+ny) + " " + str(y2-nx)	path += " A " + str(n/2)   + " " + str(n/2)   + " 0 0 1 " + str(x2-ny) + " " + str(y2+nx)	path += " L " + str(cx   ) + " " + str(cy   )	return pathdef getValvePath(_x1, _y1, _x2, _y2, _r):	x1 = float(_x1)	y1 = float(_y1)	x2 = float(_x2)	y2 = float(_y2)	w = 0.2 * _r	lx = x2 - x1	ly = y2 - y1	l = math.sqrt(lx * lx + ly * ly)	n = 4 * w	try:		nx = lx * n / l		ny = ly * n / l	except:		nx = 0		ny = 0	cx = 0.5 * (x1 + x2)	cy = 0.5 * (y1 + y2)	path = ""	path += " M " + str(cx+0.0*nx+0.2*ny) + " " + str(cy+0.0*ny-0.2*nx)	path += " L " + str(cx+1.0*nx+1.0*ny) + " " + str(cy+1.0*ny-1.0*nx)	path += " L " + str(cx+1.4*nx+1.0*ny) + " " + str(cy+1.4*ny-1.0*nx)	path += " L " + str(cx+1.4*nx+0.1*ny) + " " + str(cy+1.4*ny-0.1*nx)	path += " L " + str(x2+0.0*nx+0.3*ny) + " " + str(y2+0.0*ny-0.3*nx)	path += " A " + str(0.3*n) + " " + str(0.3*n) + " 0 0 1 " + str(x2+0.0*nx-0.3*ny) + " " + str(y2+0.0*ny+0.3*nx)	path += " L " + str(cx+1.4*nx-0.1*ny) + " " + str(cy+1.4*ny+0.1*nx)	path += " L " + str(cx+1.4*nx-1.0*ny) + " " + str(cy+1.4*ny+1.0*nx)	path += " L " + str(cx+1.0*nx-1.0*ny) + " " + str(cy+1.0*ny+1.0*nx)	path += " L " + str(cx+0.0*nx-0.2*ny) + " " + str(cy+0.0*ny+0.2*nx)	path += " L " + str(cx-0.0*nx-0.2*ny) + " " + str(cy-0.0*ny+0.2*nx)	path += " L " + str(cx-1.0*nx-1.0*ny) + " " + str(cy-1.0*ny+1.0*nx)	path += " L " + str(cx-1.4*nx-1.0*ny) + " " + str(cy-1.4*ny+1.0*nx)	path += " L " + str(cx-1.4*nx-0.1*ny) + " " + str(cy-1.4*ny+0.1*nx)	path += " L " + str(x1-0.0*nx-0.3*ny) + " " + str(y1-0.0*ny+0.3*nx)	path += " A " + str(0.3*n) + " " + str(0.3*n) + " 0 1 1 " + str(x1-0.0*nx+0.3*ny) + " " + str(y1-0.0*ny-0.3*nx)	path += " L " + str(cx-1.4*nx+0.1*ny) + " " + str(cy-1.4*ny-0.1*nx)	path += " L " + str(cx-1.4*nx+1.0*ny) + " " + str(cy-1.4*ny-1.0*nx)	path += " L " + str(cx-1.0*nx+1.0*ny) + " " + str(cy-1.0*ny-1.0*nx)	path += " L " + str(cx-0.0*nx+0.2*ny) + " " + str(cy-0.0*ny-0.2*nx)	path += " Z "	return pathif __name__ == "__main__":	main()