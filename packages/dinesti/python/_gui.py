# Copyright (2013) Sandia Corporation. Under the terms of Contract# DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government # retains certain rights in this software.## This software is released under the FreeBSD license as described # in License.txtimport sysimport httplibimport osimport datetimeimport subprocessimport time as Timerimport datetimeimport base64import tempfileimport _uuidimport json # Python 2.6 or laterfrom cStringIO import StringIOimport sys################################################# Global datasHost = ""sDb = ""################################################class DebugError(Exception):	def __init__(self, value):		self.value = value	def __str__(self):			return repr(self.value)def raiseDebugError(s):	raise DebugError(s)def getInstallDir(): # this is stored in couchdb in the gui doc under config_install_dir	return getConfig("config_install_dir")def getDbName():	return sDbdef getDesDocName():	return "gui"def getGuiDocName():	return "gui"def getGuiHtml():	return "gui.html"def getInstallDir():	sInstallDir = getConfig("config_install_dir")	return sInstallDirdef setHost(value = "127.0.0.1:5984"):	global sHost	sHost = valuedef getHost():	return sHostdef setDatabase(value):	global sDb	sDb = value	def respond(s):	if type(s) == str:		sys.stdout.write(s + "\n")		sys.stdout.flush()		return True	respondJSON(s)	return Truedef respondJSON(s):	if type(s) == str:		respond("{\"json\": " + s + "}")		return True	respond("{\"json\": " + json.dumps(s) + "}")	return Truedef httpConnection():	return httplib.HTTPConnection(sHost)def httpRequest(sType, sConn, sBody, headers):	http = httpConnection()	http.request(sType, sConn, sBody, headers)	res = http.getresponse()	http.close()		return resdef httpPut(conStr, sBody="", headers={}, bBinary=False):	http = httpConnection()	old_stdout = sys.stdout	sys.stdout = mystdout = StringIO()	if bBinary:		sBody64 = base64.b64encode(sBody)		http.request("PUT", conStr, sBody64, headers)	else:		http.request("PUT", conStr, sBody, headers)	res = http.getresponse()	text = res.read()	http.close()	sys.stdout = old_stdout	return textdef httpDelete(conStr):	http = httpConnection()	http.request("DELETE", conStr)	res = http.getresponse()	http.close()	return res	def httpGetHead(conStr):	http = httpConnection()	http.request("HEAD", conStr)	res = http.getresponse()	text = res.read()	http.close()	return res.getheaders()def httpGet(conStr, bBinary=False):	http = httpConnection()	http.request("GET", conStr)	res = http.getresponse()	text = res.read()	http.close()	if bBinary:		text = base64.b64decode(text)	return textdef getRes(sres):	try:		jres = json.loads(sres)	except:		#jres = {"Error": "Error retrieving document, \"" + doc + "\"."}		jres = {"Result": sres}	return jresdef getDoc(uuid):	if len(uuid) == 0:		return {}#{"Error": "the specified document id was blank"}	url = "/" + getDbName() + "/" + uuid	#url += "?_DEBUG_SERVER_GET_"	sres = httpGet(url)	return getRes(sres)def setDoc(doc, data=None):	if data == None:		data = doc		doc = data["_id"]	if len(doc) == 0:		return {}#{"Error": "the specified document id was blank"}	url = "/" + getDbName() + "/" + doc	#url += "?_DEBUG_SERVER_PUT_"	sres = httpPut(url, json.dumps(data))	return getRes(sres)def setValue(uuid, key, value):	doc = getDoc(uuid)	doc[key] = value	setDoc(uuid, doc)	returndef setValues(uuid, keys, values):	doc = getDoc(uuid)	for i in range(0,len(keys)):		key = keys[i]		value = values[i]		doc[key] = value	setDoc(uuid, doc)	returndef setGetDoc(doc, data=None):	if data == None:		uuid = doc["_id"]		data = doc	else:		uuid = doc	setDoc(uuid, data)	return getDoc(uuid)	def getView(view):	url = "/_design/" + getDesDocName() + "/_view/"	data = getDoc(url + view)	return datadef getFile(uuid, sFilename):	return httpGet("/" + getDbName() + "/" + uuid + "/" + sFilename)def getFileDoc(uuid, sFilename):	text = httpGet("/" + getDbName() + "/" + uuid + "/" + sFilename)	return getRes(text)def addAttachment(doc_or_uuid, sName, sContentType, sText):	#TODO - implement uuid stuff	doc = doc_or_uuid	sText64 = base64.b64encode(sText)	attachments = doc.get("_attachments", {})	attachments[sName] = {"content_type": sContentType, "data": sText64}	doc["_attachments"] = attachments	setDoc(doc)	return getDoc(doc["_id"])def uploadFileFromDisk(sUuid, sDir, sFilename, sContentType, bBinary=False):	flags = "r"	if bBinary: flags = "rb"	sPath = sDir + "/" + sFilename	if not os.path.exists(sPath):		return {"error": "_gui.UploadFileFromDisk(): can't open file. file does not exist. " + sPath} 	f = open(sPath, flags)	res = uploadFileFromObject(sUuid, f, sContentType, bBinary)	return resdef uploadFileFromObject(sUuid, f, sContentType, bBinary=False):	sFilename = os.path.split(f.name)[1]	sText = f.read()	res = uploadFile(sUuid, sFilename, sContentType, sText, bBinary)	return resdef uploadFile(sUuid, sFilename, sContentType, sText, bBinary=False):	sDb = "/" + getDbName() + "/"	res = httpGetHead(sDb + sUuid)	sRev = None	for item in res:		if item[0] == "etag":			sRev = json.loads(res[2][1])	if sRev == None: raiseDebugError("document does not exist.")	headers = {"Content-type": sContentType, "Accept": sContentType}	res = httpPut(sDb + sUuid + "/" + sFilename + "?rev=" + sRev, sText, headers, bBinary)	return resdef getConfig(key=None):	config = getDoc(getGuiDocName())	if key == None:		return config	return config[key]def getValue(doc, key, default=None):	try:		return doc[key]	except:		return defaultdef getDate():	t = datetime.datetime.utcnow()	s = t.strftime("%Y-%m-%dT%H:%M:%S")	date = s + "." + str(int(t.microsecond/1000)) + "Z"	return date	def debugPrint(s):	t = datetime.datetime.utcnow()	date = t.strftime("%Y-%m-%d-%H-%M-%S-%f")	getDoc("--DEBUG-"+ date + "---" + str(s) + "---")def readJsonFile(sFilename, default=None):	if os.path.exists(sFilename):		f = open(sFilename, "r")		try:			results = json.load(f)		except:			_gui.raiseDebugError(f.read())	else:		results = default	return resultsdef readFile(sFilename, default=None):	if os.path.exists(sFilename):		f = open(sFilename, "r")		results = f.read()	else:		results = default	return resultsdef removeAllFiles(sDir):	if os.path.exists(sDir):		for file in os.listdir(sDir):			os.remove(sDir + file)def closeFiles(files):	for f in files:		if f == None: continue		closeFile(f)def closeFile(f):	#if type(f) == file: # for some reason type(f) is returning "instance" not "file"	try:		f.close()	except:		passdef removeFiles(files):	for f in files:		if f == None: continue		removeFile(f)def removeFile(f):	try:		sFilename = f.name	except:		sFilename = f	removeIfExists(sFilename)def removeIfExists(sFile):	if sFile == None: return False	if os.path.exists(sFile):		os.remove(sFile)		return True	return Falsedef removeDir(sDir):	removeAllFiles(sDir)	if os.path.exists(sDir):		os.rmdir(sDir)def recreateDir(sDir):	if os.path.exists(sDir):		removeAllFiles(sDir)	else:		os.makedirs(sDir)def renameDir(sDirOld, sDirNew):	bOldExists = os.path.exists(sDirOld)	bNewExists = os.path.exists(sDirNew)	if bOldExists:		if bNewExists:			if sDirOld.lower() == sDirNew.lower():				os.renames(sDirOld, sDirNew)			else:				removeDir(sDirOld)		else:			os.renames(sDirOld, sDirNew)def bDeleteTempFiles(override):	if override <> None: return override	bDelete = False	bDelete = True	bDelete = not getConfig("config_server_save_temp")	return bDelete#sort-of-extends the file object# f = file# s = string to writedef writeLine(f,s): 	f.write(s)	f.write("\n")def getQuery(req, key, default=""):	try:		return req["query"][key]	except:		return defaultdef getRequests():	line = sys.stdin.readline()	while line:		yield json.loads(line)		line = sys.stdin.readline()def startProcess(args):	p = subprocess.Popen(args, stdout=subprocess.PIPE)	com = p.communicate();	return com[0]def convertTimeToSec(str):	return int(str) # TODO - when time is 00:00:00, change this!def getSensorStatus(value):	if value == 1: return   "Abnormal"	return "Background"	#if value > 0.5: return  "Abnormal"	#if value >= 0: return "Background"	#return ""def getSensorValue(status):	if status == "Abnormal"  : return 1	if status == "Background": return 0	return -1def getOppositeStatus(status):	value = getSensorValue(status)	if value == 1:		return getSensorStatus(0)	else:		return getSensorStatus(1)def getSensorAlarm(status_or_value):	typeof = type(status_or_value)	if typeof == float:		status = getSensorStatus(status_or_value)		value = getSensorValue(status)	elif typeof == str or typeof == unicode:		value = getSensorValue(status_or_value)	if value == 1: return True	return Falsedef getGrabSampleLimits(value):	value["chlorinemin"] = 0.3	value["chlorinemax"] = 2	value["phmax"      ] = 9	value["phmin"      ] = 7.5	value["condmax"    ] = 300	value["condmin"    ] = 100	value["turbmax"    ] = 1	#	config = getConfig()	value["chlorinemax"] = config.get("config_event_cl_max")	value["chlorinemin"] = config.get("config_event_cl_min")	value["phmax"      ] = config.get("config_event_ph_max")	value["phmin"      ] = config.get("config_event_ph_min")	value["condmax"    ] = config.get("config_event_cond_max")	value["condmin"    ] = config.get("config_event_cond_min")	value["turbmax"    ] = config.get("config_event_turb_max")	return valuedef getTimeZero():	#return datetime.datetime(2013, 4, 15) # TODO - switch this back to 1970 when we have data in the canary database	return datetime.datetime(1970, 1, 1)def getEpoch():	return Timer.time()def getEpochMilliseconds():	return Timer.time() * 1000def getGrabSampleTimeStamp():	time_stamp = datetime.datetime.now()	return time_stamp.strftime("%y-%m-%d %H:%M:%S.%f")def getEventStartTimeStamp():	return getEpochMilliseconds()def getTraining(doc):	bTraining = doc.get("m_TrainingList")	bEvents = doc.get("m_EventsList")	if bTraining: return True	if bEvents: return False	_gui.raiseDebugError("_gui.getTraining(): this document is neither part of the training list or the events list")def convertRealTimeToSimTime(time):	return timedef createWqmFile(docFile_INP):		return createFile(docFile_INP["docId"], docFile_INP["wqmFile"], ".wqm")def createFile(sUuid, sFilename, sExtension):	if sUuid      == None: return None	if sFilename  == None: return None	text = getFile(sUuid, sFilename)	temp = tempfile.NamedTemporaryFile(delete=False, suffix=sExtension)	temp.write(text)	return tempdef getTotalSeconds(diff):	try:		return int(diff.total_seconds())	except:		return int(diff.microseconds + (diff.seconds + diff.days * 24 * 3600) * 1e6) / 1e6def debugStr(anything):	s = str(anything)	return s.replace(" ", "_")class FakeFile:	name = "None"	def close(self):		return	