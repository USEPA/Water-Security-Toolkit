# Copyright (2013) Sandia Corporation. Under the terms of Contract# DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government # retains certain rights in this software.## This software is released under the FreeBSD license as described # in License.txtimport time as Timerimport stringimport subprocessimport osimport tempfileimport datetimefrom multiprocessing import Processimport MySQLdbimport _guifrom _gui import FakeFileimport _inversionimport _grabimport _uuidimport _timeimport json # Python 2.6 or laterdef databaseExists(db_name):	try:		db = MySQLdb.connect("localhost", "dinesti", "dinesti", db_name)		return True, db	except:		return False, Nonedef initializeSqlDb():	bExists, db = databaseExists("dinesti")	if not bExists:		bExists, db = databaseExists("wst")	cursor = db.cursor()	return db,cursordef tableExists(cursor, table_name):	res = cursor.execute("show tables like '{0}'".format(table_name))	return res > 0def deleteTable(cursor, table):	if tableExists(cursor, table):		cursor.execute("drop table {0}".format(table))	returndef getDateFromEpoch(epoch):	return datetime.datetime.fromtimestamp(epoch)def getDateStringFromEpoch(epoch):	return datetime.datetime.fromtimestamp(epoch).strftime("%Y-%m-%d_%H:%M")def getStartTime():	config  = _gui.getConfig()	repeat  = config["config_event_epoch_repeat"]	start   = config["config_event_epoch_start"]	horizon = config["config_event_horizon_hours"] * 3600	time    = _gui.getDoc("_time?call=get&db=dinesti")	now     = time["epoch"]	_gui.debugPrint("-----------------------start="+getDateStringFromEpoch(start))	_gui.debugPrint("---------------------horizon="+str(horizon))	_gui.debugPrint("----------------------repeat="+str(repeat))	_gui.debugPrint("-------------------------now="+getDateStringFromEpoch(now))	_gui.debugPrint("---------------move-forward?="+str(now > start + horizon))	if now > start + horizon: # start time is in the past. move forward in time.		_gui.debugPrint("---------------------------2="+str(start + horizon + repeat < now))		while start + horizon + repeat < now:			start += repeat			_gui.debugPrint("-----------------------start="+getDateStringFromEpoch(start))			_gui.debugPrint("-----------------------------"+str(start + horizon + repeat < now))	else:		_gui.debugPrint("---------------------------3="+str(start + horizon > now))		while start + horizon > now:			start -= repeat					_gui.debugPrint("-----------------------start="+getDateStringFromEpoch(start))			_gui.debugPrint("---------------------------3="+str(start + horizon > now))	return startdef updateCanaryData(doc, startTime):	canary_uuid = doc["canaryId"]	canary_doc = _gui.getDoc(canary_uuid)	db,cursor = initializeSqlDb()	#sCanaryDb = "BDGIJHKBIHFAJRHYOLWJVLZRPQXSY" # TODO - switch back to the canary database when we are ready to test this thing	sCanaryDb = "canary"	alarm = None	if tableExists(cursor, sCanaryDb):		canary = canary_doc.get("canary", [])		nHorizon = _gui.getConfig("config_event_horizon_hours") * 3600		time = _gui.getDoc("_time?call=get&db=dinesti")		now  = time["epoch"]		TimeNow = getDateFromEpoch(now);		TimeDiff = datetime.timedelta(seconds=nHorizon)		sTime = str(TimeNow)		sTimeOld = str(TimeNow - TimeDiff)		timeCondition = "time_stamp >= '" + sTimeOld + "' and time_stamp <= '" + sTime + "'"		command = " select name, time_stamp, event_code from " + sCanaryDb + " where " + timeCondition		nres = cursor.execute(command)		canary = []		_gui.debugPrint("sCanaryDb=" + _gui.debugStr(sCanaryDb))		_gui.debugPrint("command="   + _gui.debugStr(command)  )		_gui.debugPrint("nres="      + _gui.debugStr(nres)     )		_gui.debugPrint("TimeNow="   + _gui.debugStr(TimeNow)  )		_gui.debugPrint("TimeDiff="  + _gui.debugStr(TimeDiff) )		_gui.debugPrint("sTimeOld="  + _gui.debugStr(sTimeOld) )		_gui.debugPrint("sTime="     + _gui.debugStr(sTime)    )		if nres > 0:			res = cursor.fetchall()			cursor.close()			db.close()			#			alarm = doc.get("alarm")			#			for i in range(0, nres):				location   = res[i][0]				DateTime   = res[i][1]				event_code = res[i][2]				_gui.debugPrint("location=" + _gui.debugStr(location))				_gui.debugPrint("DateTime=" + _gui.debugStr(DateTime))				_gui.debugPrint("event_code=" + _gui.debugStr(event_code))				diff = DateTime - _gui.getTimeZero()				_gui.debugPrint("diff=" + _gui.debugStr(diff))				nSeconds = _gui.getTotalSeconds(diff)				_gui.debugPrint("diff=" + _gui.debugStr(nSeconds))				nSeconds = int(DateTime.strftime("%s"))				_gui.debugPrint("diff=" + _gui.debugStr(nSeconds))				#				if event_code == 1:					if alarm == None:						alarm = {}					if alarm.get("sensors") == None:						alarm["sensors"] = []					if alarm.get("time") == None:						alarm["time"] = nSeconds						alarm["sensors"].append(location)					#				#nSeconds = int(DateTime.strftime("%s")) - startTime # TODO - the start time is important once we get real dates and times into the mysql database.				# right now in the training we are filling the sql database with dates that start on Jan 1 1970.				status = _gui.getSensorStatus(event_code)				value = {"location": location, "time": nSeconds, "status": status}				canary.append({"value": value})	else:		canary = []	#	canary_doc["canary"] = canary	_gui.setDoc(canary_uuid, canary_doc)	return alarmdef runInit(doc):	startTime = getStartTime()	alarm = updateCanaryData(doc, startTime)	doc["alarm"] = alarm	doc["startTime"] = startTime	doc["statusOld"] = doc["status"]	doc["status"] = "Initialized"	_gui.setDoc(doc)	passdef create_docFile_INP(inp_uuid):	inp_doc = _gui.getDoc(inp_uuid)	data = {}	data["docId"] = inp_uuid	data["fileName"] = inp_doc["fileName"]	data["wqmFile"] = inp_doc["wqmFile"]	TimeData = inp_doc.get("TimeData")	data["duration"] = TimeData["Duration"]	data["step"] = TimeData["WaterQualityStep"]	return data# also called by _training.pydef createMeasureFileGrabText(doc, startTime=0):	bTraining = _gui.getTraining(doc)	#	inp_uuid = doc["inpId"]	inp_doc = _gui.getDoc(inp_uuid)	data = _gui.getDoc(inp_uuid + "/" + inp_doc["jsonFile"])	NodeIds = data["NodeIds"]	#	grab_uuid = doc["grabId"]	grab_doc = _gui.getDoc(grab_uuid)	sGrabSamples = ""	for item in grab_doc["grab"]:		item = item.get("value", None)		if item == None: continue		location = item.get("location", None)		time     = item.get("time", None)		status   = item.get("status", None)		index    = NodeIds.get(location, None)		value    = _gui.getSensorValue(status)		if location == None: continue		if time     == None: continue		if status   == None: continue		if index    == None: continue		if value    <  0   : continue		value = _gui.getSensorValue(status)		if type(time) == unicode: continue		if type(time) == str: continue		time = time - startTime		_gui.debugPrint("----------------------GrabSample-startTime=" + str(time))		if time < 0: continue		sGrabSamples += str(location) + " " + str(time) + " " + str(value) + "\n"	return sGrabSamplesdef createMeasureFileCanaryText(doc, startTime=0):	canary_uuid = doc["canaryId"]	canary_doc = _gui.getDoc(canary_uuid)	sCanary = ""	for item in canary_doc["canary"]:		item = item.get("value", None)		if item == None: continue		location = item.get("location", None)		time     = item.get("time", None)		status   = item.get("status", None)		value    = _gui.getSensorValue(status)		if location == None: continue		if time     == None: continue		if status   == None: continue		if value    <  0   : continue		time = time - startTime		_gui.debugPrint("----------------------Canary-startTime=" + str(time))		if time < 0: continue		sCanary += str(location) + " " + str(time) + " " + str(value) + "\n"	return sCanary# also called by _training.pydef createMeasureFileDoc(event_uuid, inv_uuid, nCycle, TextArray):	mes_uuid = _uuid.run()	data = {}	data["Date"] = _gui.getDate()	data["m_MeasureList"] = True	data["m_hide"] = True	data["eventId"] = event_uuid	data["uuidInversion"] = inv_uuid	sFilename = "Cycle" + str(nCycle) + ".txt"	data["fileName"] = sFilename	sText = ""	for item in TextArray:		if len(item) == 0: continue		sText += item + "\n"	if len(sText) > 0:		_gui.setDoc(mes_uuid, data)		_gui.uploadFile(mes_uuid, sFilename, "text/plain", sText)		return True	else:		return Falsedef createNewInversionDoc(inv_uuid, doc):	inp_uuid = doc["inpId"]	docFile_INP = create_docFile_INP(inp_uuid)	data = {}	data["Date"] = _gui.getDate()	data["name"] = doc["name"]	data["m_InversionList"] = True	data["m_hide"] = True	data["eventId"] = doc["_id"]	data["docFile_INP"] = docFile_INP	data["status"] = "Inversion"	_gui.setDoc(inv_uuid, data)	return _gui.getDoc(inv_uuid)def runInversion(doc):	startTime = getStartTime()	updateCanaryData(doc, startTime)	doc["startTime"] = startTime	statusOld = doc["statusOld"]	doc["statusOld"] = doc["status"]	doc["status"] = "Inversion"	_gui.setDoc(doc)	#	event_uuid = doc["_id"]	#	config = _gui.getConfig()	inp_uuid = config["config_event_inp_uuid"]	doc["inpId"] = inp_uuid	log_uuid = doc["logId"]	#	nCycle = doc.get("cycle", 0)	nCycle = nCycle + 1	#	startDate = datetime.datetime.fromtimestamp(startTime).strftime("%Y-%m-%d_%H:%M")	_gui.debugPrint("----------------------Inversion-startTime=" + startDate)	sGrabText = createMeasureFileGrabText(doc, startTime)	sCanaryText = createMeasureFileCanaryText(doc, startTime)	inv_uuid = _uuid.run()	bSuccess = createMeasureFileDoc(event_uuid, inv_uuid, nCycle, [sGrabText, sCanaryText])	if bSuccess:		inv_doc = createNewInversionDoc(inv_uuid, doc)		inv_doc = _inversion.runThreaded(inv_doc, sOutputPrefix=inv_uuid, bThreaded=False)		#		sTSG = inv_doc["results_for_grab_sample"]		results = inv_doc["results"]		view = "network"		statusOld = "Inversion"		status = "Inverted"		res_list = results.get("list", [])		count = len(res_list)		runLog(log_uuid, "    Success (count = " + str(count) + ", max = " + str(results["max"]) + ")")	else:		results = {"Error": "There are no measurements to invert!"}		sTSG = "Error: there are no messurements to invert!"		view = "data"		status = statusOld		statusOld = "Inversion"		runLog(log_uuid, "    Error: no measurements to invert (cycle = " + str(nCycle) + ")!")		#	doc = _gui.getDoc(event_uuid)	doc["results" + str(nCycle)] = results	doc["inversion" + str(nCycle)] = sTSG	doc["view"] = view	doc["statusOld"] = statusOld	doc["status"] = status	if bSuccess:		doc["cycle"] = nCycle	else:		doc["cycle"] = nCycle - 1	_gui.setDoc(doc)	returndef runLocate(doc):	event_uuid = doc["_id"]	nCycle = doc["cycle"]	log_uuid = doc["logId"]	config = _gui.getConfig()	inp_uuid = config["config_event_inp_uuid"]	sampleCount = config["config_event_sample_count"]	sampleCount = doc.get("sampleCount", sampleCount)	sampleTime = doc.get("sampleTime", 0)	startTime = doc.get("startTime", 0)	startDate = datetime.datetime.fromtimestamp(startTime).strftime("%Y-%m-%d_%H:%M")	_gui.debugPrint("----------------------GrabSample-startTime=" + startDate)	sampleDate = datetime.datetime.fromtimestamp(sampleTime).strftime("%Y-%m-%d_%H:%M")	_gui.debugPrint("----------------------GrabSample-sampleTime=" + sampleDate)	sampleTime = sampleTime - startTime	_gui.debugPrint("----------------------GrabSample-sampleTime=" + str(sampleTime/3600.0))	sSampleUuid = _uuid.run()	docFile_INP = create_docFile_INP(inp_uuid)	scenarios = doc["inversion" + str(nCycle)]	createScenariosFile(event_uuid, sSampleUuid, nCycle, scenarios)	data = {}	data["name"] = doc["name"]	data["sampleTime"] = sampleTime	data["sampleCount"] = sampleCount	data["sensors"] = doc["sensors"]	data["Date"] = _gui.getDate()	data["eventId"] = event_uuid	data["m_GrabList"] = True	data["m_hide"] = True	data["docFile_INP"] = docFile_INP	data["Nodes"] = doc["results" + str(nCycle)]["ids"]	_gui.setDoc(sSampleUuid, data)	doc = _gui.getDoc(sSampleUuid)	doc = _grab.runThreaded(doc, sOutputPrefix=sSampleUuid, bThreaded=False)	results = doc.get("results", {})	Samples = results.get("Nodes", [])	Error = results.get("Error", None)	#	doc = _gui.getDoc(event_uuid)	doc["results" + str(nCycle) + "g"] = results	grab_uuid = doc["grabId"]	grab_doc = _gui.getDoc(grab_uuid)	grab = grab_doc["grab"]	if Error == None:		nCount = len(Samples)		time = results["sampleTime"] + startTime		sLog = []		sLog.append("    Success (count = " + str(nCount) + ", time = " + str(time) + ")")		for i in range(0, nCount):			value = {}			value["opt"      ] = "*"			value["location"] = Samples[i]["id"]			value["time"    ] = time			value["status"  ] = ""			value["uuid"] = _gui.getGrabSampleTimeStamp()			value = _gui.getGrabSampleLimits(value)			grab.append({"value": value})			sLog.append("    " + str(i + 1) + ") unique id = " + value["uuid"] + ", location = " + value["location"])		runLog(log_uuid, sLog)	else:		value = {}		value["uuid"  ] = _gui.getGrabSampleTimeStamp()		value["opt"   ] = "*"		value["Error" ] = "Error: " + Error		value["status"] = "Error"		value["team"  ] = "Error: " + Error		grab.append({"value": value})		runLog(log_uuid, "Error: " + Error)		#	grab_doc["grab"] = grab	_gui.setDoc(grab_doc)	doc["Error"] = Error	doc["statusOld"] = doc["status"]	doc["status"] = "Located"	_gui.setDoc(doc)	returndef createScenariosFile(sEventUuid, sSampleUuid, nCycle, scenarios):	sUuid = _uuid.run()	sFilename = "Cycle" + str(nCycle) + ".txt"	data = {}	data["Date"] = _gui.getDate()	data["m_ScenariosList"] = True	data["m_hide"] = True	data["eventId"] = sEventUuid	data["uuidGrab"] = sSampleUuid	data["fileName"] = sFilename	_gui.setDoc(sUuid, data)	_gui.uploadFile(sUuid, sFilename, "text/plain", scenarios)	returndef runDelete(sUuid):	returndef runNewGrab(doc):	grab_uuid = doc["grabId"]	grab_doc = _gui.getDoc(grab_uuid)	grab = grab_doc.get("grab", []);	value = {}	value["opt"      ] = " "	value["uuid"     ] = _gui.getGrabSampleTimeStamp()	value["team"     ] = ""	value["time"     ] = ""	value["location" ] = ""	value["status"   ] = ""	value["suggested"] = ""	value["chlorine" ] = ""	value["ph"       ] = ""	value["cond"     ] = ""	value["turb"     ] = ""	value = _gui.getGrabSampleLimits(value)	grab.append({"value": value});	grab_doc["grab"] = grab	grab_doc["index"] = len(grab) - 1	_gui.setDoc(grab_doc)	returndef run(sCall, sUuid):	doc = _gui.getDoc(sUuid)	#	if sCall == "init":		p = Process(target=runInit,args=(doc,))		p.start()		return _gui.respond({})	#	if sCall == "inversion":		p = Process(target=runInversion,args=(doc,))					p.start()		return _gui.respond({})	#	if sCall == "locate":		p = Process(target=runLocate,args=(doc,))		p.start()		return _gui.respond({})	#	if sCall == "delete":		p = Process(target=runDelete,args=(sUuid,))		p.start()		return _gui.respond({})	#	if sCall == "newgrab":		p = Process(target=runNewGrab,args=(doc,))		p.start()		return _gui.respond({})	#	if sCall == "download":		p = Process(target=runDownload,args=(doc,))		p.start()		return _gui.respond({})	return# this call will not spin off a new process# so we can know when the process is done and # retrieve the log file on the client sidedef runDownload(sUuid):	doc = _gui.getDoc(sUuid)	log_uuid = doc["logId"]	log_doc = _gui.getDoc(log_uuid)	log = log_doc["log"]	sDate = _gui.getGrabSampleTimeStamp() + "> "	log.append(sDate + "Download log")	log_doc["log"] = log	log_doc = _gui.setGetDoc(log_doc)	log = log_doc["log"]	text = ""	CRLF = "\n"	CRLF = "\r\n"	for line in log:		if len(text) > 0: text += CRLF		text += line	_gui.uploadFile(log_uuid, "Log.txt", "application/octet-stream", text)	return _gui.respond({"uuid": log_uuid, "fileName": "Log.txt"})# this call will not spin off a new process# so the next call will wait for the current call to end# before trying to read from and write to the log docdef runLog(log_uuid, sLog):	doc = _gui.getDoc(log_uuid)	log = doc.get("log", [])	try:		logs = json.loads(sLog)	except:		t = type(sLog)		if t == str or t == unicode:			logs = []			logs.append(sLog)		elif t == list:			logs = sLog		#	sDate = _gui.getGrabSampleTimeStamp() + "> "	for s in logs:		log.append( sDate + s)	doc["log"] = log	_gui.setDoc(doc)	returndef main():	_gui.setHost()	for req in _gui.getRequests():		sDb = _gui.getQuery(req, "db")		_gui.setDatabase(sDb)		sCall = _gui.getQuery(req, "call")		sUuid = _gui.getQuery(req, "uuid")		sLog  = _gui.getQuery(req, "log")		if sCall == "log":			runLog(sUuid, sLog)			_gui.respond({})			continue		if sCall == "download":			runDownload(sUuid)			continue					sDir = tempfile.gettempdir()		os.chdir(sDir)		bRetVal = run(sCall, sUuid)		if bRetVal: continue		_gui.respond({})if __name__ == "__main__":	main()