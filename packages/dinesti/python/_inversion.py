# Copyright (2013) Sandia Corporation. Under the terms of Contract# DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government # retains certain rights in this software.## This software is released under the FreeBSD license as described # in License.txtimport timeimport stringimport subprocessimport osimport tempfilefrom multiprocessing import Processimport _guifrom _gui import FakeFileimport randomimport json # Python 2.6 or laterdef createYmlFile(fGrab, fINP, fWQM, fNodes, sOutputPrefix):	file = tempfile.NamedTemporaryFile(delete=False, suffix='.yml')	_gui.writeLine(file,"# written using dinesti web gui")	_gui.writeLine(file,"network:")	_gui.writeLine(file,"  epanet file: " + fINP.name)	#_gui.writeLine(file,"  hydraulic timestep: None") # missing?	_gui.writeLine(file,"  water quality timestep: INP")	_gui.writeLine(file,"  simulation duration: INP")	#_gui.writeLine(file,"  erd compression: RLE") # RLE or LZMA # missing	_gui.writeLine(file,"")	_gui.writeLine(file,"measurements:")	_gui.writeLine(file,"  grab samples: " + fGrab.name)	_gui.writeLine(file,"")	_gui.writeLine(file,"inversion:")	#_gui.writeLine(file,"  model type: STEP")# LP, MIP, or STEP	#_gui.writeLine(file,"  model format: AMPL")# AMPL or PYOMO	#_gui.writeLine(file,"  algorithm: optimization") # or probability	_gui.writeLine(file,"  algorithm: probability") # or optimization	_gui.writeLine(file,"  meas failure: 0.01") # default = 0.05 ? (probability only) apparently zero doesnt work sometimes	_gui.writeLine(file,"  confidence: 0.95") # default = 0.95 ? (probability only)	#_gui.writeLine(file,"  horizon: None") # horizon time	#_gui.writeLine(file,"  N_injections: 1")	#_gui.writeLine(file,"  start inversion: None") # start time	#_gui.writeLine(file,"  pos_threshold: 100") # (optimization only)	#_gui.writeLine(file,"  neg_threshold: 0.1") # (optimization only)	_gui.writeLine(file,"  Allowed nodes file: None") # + fNodes.name)	#_gui.writeLine(file,"  Candidates_threshold: None") # 0.8") # None, def = 0.95, (optimization only)	#_gui.writeLine(file,"  meas_threshold: 0") # None	#_gui.writeLine(file,"  wqm_zero_tol: None") # 0.0	_gui.writeLine(file,"  output impact nodes: None") # False	_gui.writeLine(file,"  wqm file: " + fWQM.name)	_gui.writeLine(file,"")	#_gui.writeLine(file,"solver:")	#_gui.writeLine(file,"  cplex:")	#_gui.writeLine(file,"    mipgap: 0.02")	#_gui.writeLine(file,"    threads: 1")	_gui.writeLine(file,"")	_gui.writeLine(file,"configure:")	#_gui.writeLine(file,"  ampl executable: ampl")	_gui.writeLine(file,"  pyomo executable: pyomo")	_gui.writeLine(file,"  output prefix: " + sOutputPrefix)	_gui.writeLine(file,"")	#_gui.writeLine(file,"internal:")	#_gui.writeLine(file,"  nodeNames: []")	#_gui.writeLine(file,"  nodeIndices: []")	return filedef createInpFile(data):	uuid = data.get("docId", None)	if uuid == None: return FakeFile()	name = data.get("fileName", None)	if name == None: return FakeFile()	text = _gui.getFile(uuid, name)	temp = tempfile.NamedTemporaryFile(delete=False, suffix='.inp')	temp.write(text)	return tempdef createWqmFile(data):	uuid = data.get("docId", None)	if uuid == None: return FakeFile()	name = data.get("wqmFile", None)	if name == None: return FakeFile()	text = _gui.getFile(uuid, name)	temp = tempfile.NamedTemporaryFile(delete=False, suffix='.wqm')	temp.write(text)	return tempdef createGrabFile(uuid):	temp = tempfile.NamedTemporaryFile(delete=False, suffix='.grab')	data = _gui.getView("m_MeasureList?key=\"" + uuid + "\"")	for row in data["rows"]:		text = _gui.getFile(row["id"], row["value"]["fileName"])		temp.write(text + "\n")	return tempdef createNodesFile(Nodes):	if len(Nodes) == 0:		return FakeFile()	temp = tempfile.NamedTemporaryFile(delete=False, suffix='.nodes')	for node in Nodes:		temp.write(str(node) + "\n")	return tempdef runWst(fGrab, fINP, fWQM, fNodes, fYML, sUuid, sInstallDir, sOutputPrefix):	nStart = time.time()	args = [sInstallDir + "python/bin/wst", "inversion", fYML.name]	#	p = subprocess.Popen(args, stdout = subprocess.PIPE)	doc = _gui.getDoc(sUuid)	doc["pid"] = str(p.pid)	doc["status"] = "Running"	_gui.setDoc(sUuid, doc)	#doc = _gui.getDoc(sUuid)	com = p.communicate()	sOut = com[0]	#	doc = _gui.getDoc(sUuid)	results = _gui.readJsonFile(sOutputPrefix + "_inversion_results.json", "")	#	ids = {}	max = 0	for i,result in enumerate(results):		ids[result["Nodes"][0]["Name"]] = i		dVal = result["Objective"]		if dVal > max: max = dVal	#	doc["results"] = {"list":results, "ids":ids, "max": max}	#	sOUT = _gui.readFile(sOutputPrefix + "_inversionsim.out", "")	doc["debug_text_out_file"] = sOUT	sTSG = _gui.readFile(sOutputPrefix + "_profile.tsg", "")	doc["results_for_grab_sample"] = sTSG	#	doc["debug_fileGrab"] = fGrab.name	doc["debug_stdout"] = com[0]	doc["returnCode"] = p.returncode	if com[1] == None:		doc["debug_stderr"] = "\0"	else:		doc["debug_stderr"] = com[1]	#	sKill = "Signal handler called from"	index = string.find(sOut, sKill)	doc["debug_stdout_find_error_index"] = index	#	if _gui.bDeleteTempFiles(override=None):		_gui.removeFiles([fGrab, fINP, fWQM, fNodes, fYML])		_gui.removeFile(sOutputPrefix + "_epanet")		_gui.removeFile(sOutputPrefix + "_merlion")		_gui.removeFile(sOutputPrefix + "_MERLION_LABEL_MAP.txt")		_gui.removeFile(sOutputPrefix + "_inversionsim.out")		_gui.removeFile(sOutputPrefix + "_inversionsim.log")		_gui.removeFile(sOutputPrefix + "_inversion_results.json")		_gui.removeFile(sOutputPrefix + "_profile.tsg")		_gui.removeFile(sOutputPrefix + "_Likely_Nodes.dat")	#	if results == "":		doc["status"] = "Error"	elif index == -1 and p.returncode == 0:		doc["status"] = "Complete"	elif index == -1:		doc["status"] = "Error"	else:		doc["status"] = "Stopped"	#	doc["timer"] = time.time() - nStart	return _gui.setGetDoc(sUuid, doc)def runThreaded(doc, sOutputPrefix, bThreaded=True):	sUuid = doc["_id"]	sInstallDir = _gui.getInstallDir()	docFile_INP = _gui.getValue(doc, "docFile_INP")	Nodes = _gui.getValue(doc, "Nodes", [])	fGrab = createGrabFile(sUuid)	fWQM = createWqmFile(docFile_INP)	if fWQM.name == "None":		fINP = createInpFile(docFile_INP)	else:		fINP = FakeFile()	fNodes = createNodesFile(Nodes)	fYML = createYmlFile(fGrab, fINP, fWQM, fNodes, sOutputPrefix)	_gui.closeFiles([fGrab, fINP, fNodes, fYML])	#	if bThreaded:		p = Process(target=runWst, args=(fGrab, fINP, fWQM, fNodes, fYML, sUuid, sInstallDir, sOutputPrefix, ))		p.start()	else:		return runWst(fGrab, fINP, fWQM, fNodes, fYML, sUuid, sInstallDir, sOutputPrefix)			returndef run(sCall, sUuid, bThreaded=True):	if sCall == "rename":		return False	if sCall == "delete":		return False	sDir = tempfile.gettempdir()	os.chdir(sDir)	doc = _gui.getDoc(sUuid)	runThreaded(doc, sUuid, True)	return _gui.respondJSON(json.dumps({}))def main():	_gui.setHost()	for req in _gui.getRequests():		sDb = _gui.getQuery(req, "db")		_gui.setDatabase(sDb)		sCall = _gui.getQuery(req, "call")		sUuid = _gui.getQuery(req, "uuid")		bRetVal = run(sCall, sUuid, True)		if bRetVal: continue		_gui.respondJSON(json.dumps({}))if __name__ == "__main__":	main()