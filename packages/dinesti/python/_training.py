# Copyright (2013) Sandia Corporation. Under the terms of Contract# DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government # retains certain rights in this software.## This software is released under the FreeBSD license as described # in License.txtimport time as Timerimport stringimport pickleimport subprocessimport osimport tempfileimport datetimefrom multiprocessing import Processimport MySQLdbimport _guifrom _gui import FakeFileimport _eventsimport _measureimport _inversionimport _grabimport _uuidimport json # Python 2.6 and laterdef populateSqlTable(cursor, table, nodes, nStep, t0, t1):	data = []	for itime in range(t0, t1):		for node in nodes:			try:				conc = nodes[node]				if len(conc) == 0: return False				c = conc[itime]				if c > 0: code = 1				else: code = 0				nSeconds = itime * nStep				delta = datetime.timedelta(seconds=nSeconds)				DateTime = _gui.getTimeZero() + delta				data.append((node, code, DateTime))			except:				_gui.raiseDebugError(node + ": " + str(itime))	command = "insert into " + table + " (name, event_code, time_stamp) values(%s, %s, %s)"	cursor.executemany(command, data)	return Truedef initializeSqlTable(table):	db,cursor = _events.initializeSqlDb()	_events.deleteTable(cursor, table)	#cursor.execute("create table {0} select * from template".format(table)) # smm_datetime	cursor.execute("create table {0} select * from template_date".format(table))	cursor.execute("alter table {0} change column id id int auto_increment primary key".format(table))	return db,cursordef processSensorList(list):	sensors = list.split("\n")	sensors = map(map_null_blanks, sensors)	sensors = [ i for i in sensors if i <> None ]	return sensorsdef map_null_blanks(array_element):	s = array_element.strip()	if len(s) == 0: return None	return array_elementdef runInit(doc):	nStart = Timer.time()	config = _gui.getConfig()		sUuid = doc["_id"]	#	grab_uuid = doc["grabId"]	grab_doc = _gui.getDoc(grab_uuid)	grab_doc["grab"] = []	_gui.setDoc(grab_doc)	#	db,cursor = initializeSqlTable(sUuid)	sensors = processSensorList(doc.get("sensors", []))	if len(sensors) > 0:		sSimUuid = doc["scenario"]		doc2 = _gui.getDoc(sSimUuid)		dataInp = doc2["docFile_INP"]		fINP = _measure.createInpFile(dataInp)		fWQM = _gui.createWqmFile(dataInp)		dataTsg = doc2["input_TSG"]		nDuration = dataInp.get("duration", 0)		fTSG = _measure.createTsgFile(dataTsg, nDuration)		fSEN = _measure.createSensorFile(sensors)		_gui.closeFiles([fINP, fWQM, fTSG, fSEN])		sInpUuid = dataInp["docId"]		doc3 = _gui.getDoc(sInpUuid)		#		nHorizon = config["config_training_horizon_hours"] * 3600 # convert to seconds		nIncr = config["config_training_mph"] # mph = measures per hour # TODO - this should be saved in the simulation document? an option in the gui?		nStep = 3600 / nIncr		measurements = {}		measurements["timeStep"] = nStep		measurements["perHour"] = nIncr		doc["measurements"] = measurements		#		nTotal = doc3["TimeData"]["Duration"] # TODO - use this one or dataInp.get("duration") ?		nTotal = nDuration		if nTotal == 0:			nTotal = 86400 # 24 hours # TODO - remove this?		doc["measurements"]["timeTotal"] = nTotal		#		canary = []		canary_uuid = doc["canaryId"]		canary_doc = _gui.getDoc(canary_uuid)		#		data = {"_id": "", "sensorStart": 0, "sensorStop": None, "sensorPerHour": nIncr, "sensorThreshold": 0, "prefix": sUuid}		data = _measure.runExe(fINP, fWQM, fTSG, fSEN, data)		conc = data["results"].get("Concentrations", None)		if conc == None:			canary.append({"value": {"location":" ","time":" ","status":"Error"}})			canary_doc["canary"] = canary			_gui.setDoc(canary_doc)		else:			nAlarm = int(nTotal / nStep) + 1			nTotal = 0			for itime in range(0, 9999):				for sensor in sensors:					if sensor == None: continue					try:						c = conc[sensor][itime]						event_code = 1 if c > 0 else 0						nTotal = itime					except:											break					if itime <= nAlarm:						status = _gui.getSensorStatus(event_code)						alarm = _gui.getSensorAlarm(status)						if alarm: nAlarm = itime						canary.append({"value": {"location":sensor,"time":str(itime * nStep),"status":status}})				if itime <= nAlarm:					for i in range(len(canary) - 1, -1, -1):						item = canary[i]						time = int(item["value"]["time"])						if time < itime * nStep - nHorizon:							canary.remove(item)					canary_doc["canary"] = canary					canary_doc = _gui.setGetDoc(canary_doc)			populateSqlTable(cursor, sUuid, conc, nStep, 0, nTotal + 1)		#		cursor.close()		db.commit()		db.close()	#	sStatus = doc["status"]	doc["status"] = "Initialized"	doc["statusOld"] = sStatus	doc["cycle"] = 0	if len(sensors) > 0:		doc = getAlarm(doc)	doc["timer0"] = Timer.time() - nStart	for i in range(1,999):		key = "inversion" + str(i)		value = doc.get(key, "")		if len(value) == 0: break		del doc[key]	for i in range(1,999):		key = "results" + str(i)		value = doc.get(key, "")		if len(value) == 0: break		del doc[key]	for i in range(1,999):		key = "timer" + str(i) + "-1"		value = doc.get(key, None)		if value == None: break		del doc[key]	for i in range(1,999):		key = "timer" + str(i) + "-2"		value = doc.get(key, None)		if value == None: break		del doc[key]	for i in range(1,999):		key = "timer" + str(i) + "-3"		value = doc.get(key, None)		if value == None: break		del doc[key]	return _gui.setGetDoc(sUuid, doc)def getSensors(doc):	all = doc["sensors"]	all = all.splitlines()	sensors = []	for sensor in all:		sensor = sensor.strip()		if len(sensor) > 0:			sensors.append(sensor)	return sensorsdef getSensorCondition(doc):	sensors = getSensors(doc)	if len(sensors) == 0: return ""	return getCondition("name =", sensors, "or")def getCondition(sName, list, sBool):	condition = "("	bFirst = True	for i in range(0, len(list)):		if len(list[i]) == 0:			continue		if bFirst:			bFirst = False		else:			condition += " " + sBool + " "		condition += sName + " '" + list[i] + "'"	condition += ")"	return conditiondef getAlarm(doc):	sUuid = doc["_id"]	#	db,cursor = _events.initializeSqlDb()	sensorCondition = getSensorCondition(doc)	eventCondition = "event_code = 1"	command = "select min(time_stamp) from " + sUuid + " where " + eventCondition + " and " + sensorCondition	nres = cursor.execute(command)	res = cursor.fetchall()		#	bAlarm = False	nodes = []	if nres == 1:		alarm_time = res[0][0]		if alarm_time <> None:			if alarm_time >= _gui.getTimeZero():				timeCondition = "time_stamp = '" + str(alarm_time) + "'"				command = "select name from " + sUuid + " where " + eventCondition + " and " + sensorCondition + " and " + timeCondition				nres = cursor.execute(command)				res = cursor.fetchall()				for i in range(0, nres):					bAlarm = True					nodes.append(res[i][0])	#	cursor.close()	db.commit()	db.close()	#	if bAlarm:		time_zero = _gui.getTimeZero()		diff = alarm_time - time_zero		dSeconds = _gui.getTotalSeconds(diff)		nSeconds = int(dSeconds)		doc["time"] = nSeconds		doc["alarm"] = {"time": nSeconds, "sensors": nodes}		sStatus = doc["status"]		doc["status"] = "Alerted"		doc["statusOld"] = sStatus	return docdef createMeasureFileCanaryText(doc, nTime):#def createMeasureFileCanaryText(doc, nTime, startTime):	table = doc["_id"]	nHorizon = _gui.getConfig("config_training_horizon_hours") * 3600 # convert to seconds	db,cursor = _events.initializeSqlDb()	sensorCondition = getSensorCondition(doc)	sCanaryText = ""	if sensorCondition == "true":		pass	else:		command = ""		command += " select name, time_stamp, event_code "		command += " from " + table		sStart = _gui.getTimeZero() + datetime.timedelta(seconds=nTime - nHorizon)		sEnd   = _gui.getTimeZero() + datetime.timedelta(seconds=nTime)		command += " where time_stamp >= '" + str(sStart) + "' and time_stamp <= '" + str(sEnd) + "'"		if len(sensorCondition) > 0:			command += " and " + sensorCondition		command += " order by name,time_stamp"		nres = cursor.execute(command)		measurements = cursor.fetchall()		cursor.close()		db.commit()		db.close()		#		for i in range(0, nres):			sNode = str(measurements[i][0])			DateTime = measurements[i][1]			diff = DateTime - _gui.getTimeZero()			dSeconds = _gui.getTotalSeconds(diff)			sTime = str(dSeconds)			sVal  = str(measurements[i][2])			sCanaryText += sNode + " " + sTime + " " + sVal + "\n"		#	#	return sCanaryTextdef runInversion(doc):	nTimerStart = Timer.time()	statusOld = doc["statusOld"]	doc["statusOld"] = doc["status"]	doc["status"] = "Inversion"	_gui.setDoc(doc)	#	sUuid = doc["_id"]	nCycle = doc["cycle"]	nTime = doc["sampleTime"] if nCycle > 0 else doc["alarm"]["time"]	#	sSimUuid = doc["scenario"]	doc2 = _gui.getDoc(sSimUuid)	#	dataInp = doc2["docFile_INP"]	inp_uuid = dataInp["docId"]	doc["inpId"] = inp_uuid	log_uuid = doc["logId"]	#	nCycle = nCycle + 1	#	sGrabText = _events.createMeasureFileGrabText(doc)	sCanaryText = createMeasureFileCanaryText(doc, nTime)	sInvUuid = _uuid.run()	bSuccess = _events.createMeasureFileDoc(sUuid, sInvUuid, nCycle, [sGrabText, sCanaryText])	#	if bSuccess:		data = {}		data["Date"] = _gui.getDate()		data["name"] = sInvUuid[:15]		data["name"] = doc["name"]		data["m_InversionList"] = True		data["m_hide"] = True		data["eventId"] = sUuid		data["docFile_INP"] = doc2["docFile_INP"]		data["status"] = "Inversion"		_gui.setDoc(sInvUuid, data)		doc = _gui.getDoc(sInvUuid)		doc = _inversion.runThreaded(doc, sOutputPrefix=sInvUuid, bThreaded=False)		#		sTSG = doc["results_for_grab_sample"]		results = doc["results"]		view = "network"		statusOld = "Inversion"		status = "Inverted"		res_list = results.get("list", [])		count = len(res_list)		_events.runLog(log_uuid, "    Success (count = " + str(count) + ", max = " + str(results["max"]) + ")")	else:		results = {"Error": "There are no measurements to invert!"}		sTSG = "Error: there are no messurements to invert!"		view = "data"		status = statusOld		statusOld = "Inversion"		_events.runLog(log_uuid, "    Error: no measurements to invert (cycle = " + str(nCycle) + ")!")	#	doc = _gui.getDoc(sUuid)	doc["results" + str(nCycle)] = results	doc["inversion" + str(nCycle)] = sTSG	doc["status"] = status	doc["statusOld"] = statusOld	doc["sampleTime"] = nTime	#doc["startTime"] = startTime	doc["view"] = view	doc["timer" + str(nCycle) + "-1"] = Timer.time() - nTimerStart	if bSuccess:		doc["cycle"] = nCycle	else:		doc["cycle"] = nCycle - 1	return _gui.setGetDoc(sUuid, doc)def runLocate(doc):	nStart = Timer.time()	sUuid = doc["_id"]	nCycle = doc["cycle"]	log_uuid = doc["logId"]	sampleCount = _gui.getConfig("config_training_sample_count")	sampleTime = doc.get("sampleTime", None)	#startTime = doc.get("startTime", 0)	sSimUuid = doc["scenario"]	doc2 = _gui.getDoc(sSimUuid)	#	sSampleUuid = _uuid.run()	scenarios = doc["inversion" + str(nCycle)]	if type(scenarios) == list:		Samples = scenarios		nTime = doc["time"]		results = None	elif sampleTime == None or sampleCount == None:		if sampleTime == None and sampleCount == None:			Error = "sample time and sample count was not specified"		elif sampleTime == None:			Error = "sample time was not specified"		elif sampleCount == None:			Error = "sample count was not specified"		nTime = doc["time"]		results = None		doc["sampleTime"] = doc["time"]		_gui.setDoc(doc)	else:		_events.createScenariosFile(sUuid, sSampleUuid, nCycle, scenarios)		data = {}		data["name"] = doc["name"]		data["sampleTime"] = sampleTime		#data["sampleTime"] = sampleTime - startTime		data["sampleCount"] = int(doc.get("sampleCount", sampleCount))		data["sensors"] = doc["sensors"]		data["Date"] = _gui.getDate()		data["eventId"] = sUuid		data["m_GrabList"] = True		data["m_hide"] = True		data["docFile_INP"] = doc2["docFile_INP"]		data["Nodes"] = doc["results" + str(nCycle)]["ids"]		_gui.setDoc(sSampleUuid, data)		doc = _gui.getDoc(sSampleUuid)		doc = _grab.runThreaded(doc, sOutputPrefix=sSampleUuid, bThreaded=False)		Error = doc["results"].get("Error", None)		results = doc.get("results", {})		Samples = results.get("Nodes")		nTime   = results.get("sampleTime")		#nTime   = results.get("sampleTime") + startTime	#	doc = _gui.getDoc(sUuid)	doc["results" + str(nCycle) + "g"] = results	if Error == None:		doc = getMeasureGenData(doc, nTime, Samples, nCycle)	else:		value = {}		value["uuid"  ] = _gui.getGrabSampleTimeStamp()		value["opt"   ] = "*"		value["Error" ] = "Error: " + Error		value["status"] = "Error"		value["team"  ] = "Error: " + Error		grab_uuid = doc["grabId"]		grab_doc = _gui.getDoc(grab_uuid)		grab = grab_doc["grab"]		grab.append({"value": value})		grab_doc["grab"] = grab		_gui.setDoc(grab_doc)		_events.runLog(log_uuid, "Error: " + Error)		doc["Error"] = Error	#	doc["time"] = nTime	sStatus = doc["status"]	doc["status"] = "Located"	doc["statusOld"] = sStatus	doc["timer" + str(nCycle) + "-2"] = Timer.time() - nStart	return _gui.setGetDoc(sUuid, doc)# get the next canary data points from the mysql database and the results for the grab samplesdef getMeasureGenData(doc, nTime, Samples, nCycle):	sUuid = doc["_id"]	log_uuid = doc["logId"]	config = _gui.getConfig()	nHorizon = config["config_training_horizon_hours"] * 3600 # convert to seconds	nTimeOld = doc.get("time", 0) # smm_horizon	nTimeOld = nTime - nHorizon # smm_horizon	nIncr = config["config_training_mph"] # mph = measures per hour # TODO - this should be saved in the simulation document? an option in the gui?		nStep = 3600 / nIncr	if nTime < nTimeOld + nStep: return	sSimUuid = doc["scenario"]	doc2 = _gui.getDoc(sSimUuid)	dataInp = doc2["docFile_INP"]	fINP = _measure.createInpFile(dataInp)	fWQM = _gui.createWqmFile(dataInp)	dataTsg = doc2["input_TSG"]	nDuration = int(dataInp.get("duration", 0))	fTSG = _measure.createTsgFile(dataTsg, nDuration)	_gui.closeFiles([fINP, fWQM, fTSG])	#	db,cursor = _events.initializeSqlDb()	time_zero = _gui.getTimeZero()	diff0 = datetime.timedelta(seconds=nTimeOld)	diff1 = datetime.timedelta(seconds=nTime)	Time0 = time_zero + diff0	Time1 = time_zero + diff1	sTimeOld = str(Time0)	sTime = str(Time1)	timeCondition = "(time_stamp >= '" + sTimeOld + "' and time_stamp <= '" + sTime + "')"	command = "select time_stamp, name, event_code from " + sUuid + " where " + timeCondition	nres = cursor.execute(command)	res = cursor.fetchall()	canary_uuid = doc["canaryId"]	canary_doc = _gui.getDoc(canary_uuid)	canary = canary_doc["canary"] # smm_horizon 3600	canary = [] # smm_horizon	for i in range(0, nres):		time = res[i][0]		location = res[i][1]		event_code = res[i][2]		status = _gui.getSensorStatus(event_code)		time = time - time_zero		dSeconds = _gui.getTotalSeconds(time)		value = {"time": dSeconds, "location": location, "status": status}		canary.append({"value":value})	canary_doc["canary"] = canary	_gui.setDoc(canary_doc)	#	grab_uuid = doc["grabId"]	grab_doc = _gui.getDoc(grab_uuid)	grab = grab_doc["grab"]	if len(Samples) > 0:		samples = []		for item in Samples:			samples.append(item["id"])		fSEN = _measure.createSensorFile(samples)		if fSEN <> None: fSEN.close()		#		t0 = nTime		t1 = nTime + nStep		if t1 > nDuration: t1 = None		#		sPrefix = sUuid + "_grab_" + str(nTime)		data = {"_id": "", "sensorStart": t0, "sensorStop": t1, "sensorPerHour": nIncr, "sensorThreshold": 0, "prefix": sPrefix}		data = _measure.runExe(fINP, fWQM, fTSG, fSEN, data)		conc = data["results"].get("Concentrations", None)		if conc == None:			sError = "Error: no results received from the measuregen executable."			value = {}			value["opt"  ] = "*"			value["Error"] = sError			value["team" ] = sError			grab.append({"value": {"status" :" "}})			_events.runLog(log_uuid, sError)		else:			sLog = []			nCount = len(Samples)			sLog.append("    Success (count = " + str(nCount) + ", time = " + str(nTime) + ")")			i = 0			for result in Samples:				name = result["id"]				concentrations = conc[name]				if len(concentrations) > 0:					event_code = 1 if concentrations[0] > 0 else 0					suggested = _gui.getSensorStatus(event_code)					status = ""				else:					suggested = ""					status = "Error"				value = {}				value["opt"        ] = "*"				value["team"       ] = str(nCycle) + "-" + str(result["rank"])				value["time"       ] = nTime				value["location"   ] = name				value["status"     ] = status				value["suggested"  ] = suggested				value["downstream" ] = result["downstreamPipeIds"]				value["uuid"] = _gui.getGrabSampleTimeStamp()				value = _gui.getGrabSampleLimits(value)				grab.append({"value": value})				sLog.append("    " + str(i + 1) + ") unique id = " + value["uuid"] + ", location = " + value["location"])				i = i + 1			_events.runLog(log_uuid, sLog)	#		grab_doc = _gui.getDoc(grab_uuid)	grab_doc["grab"] = grab	_gui.setDoc(grab_doc)	doc = _gui.setGetDoc(doc)	return docdef runSample(doc):	nStart = Timer.time()	sUuid = doc["_id"]	nCycle = doc["cycle"]	grab_uuid = doc["grabId"]	grab_doc = _gui.getDoc(grab_uuid)	grab = grab_doc["grab"]	#index = doc["grabIndex"]	index = grab_doc["index"]	sample = grab[index]["value"]	suggested, override = getSample(doc, sample)	sample["suggested"] = suggested	sample["override"] = override	if override == None:		sample["status"] = sample["suggested"]	elif sample["overridden"]:		sample["status"] = sample["override"]	else:		sample["status"] = sample["suggested"]	sample["modified"] = False #?????	alarm = doc.get("alarm", None)	if alarm == None or alarm.get("time", None) == None:		if _gui.getSensorAlarm(sample["status"]):			sample_loc  = sample["location"]			sample_time = int(sample["time"])			alarm = {"time": sample_time, "sensor": [sample_loc]}	sStatus = doc["status"]	save = sample.get("save")	if save <> None: del sample["save"]	save = sample.copy()	sample["save"] = save	grab[index]["value"] = sample	grab_doc = _gui.getDoc(grab_uuid)	grab_doc["grab"] = grab	_gui.setDoc(grab_doc)	doc = _gui.getDoc(sUuid)	#doc["time"] = time	doc["alarm"] = alarm	doc["statusOld"] = sStatus	doc["status"] = "Sampled"	doc["timer" + str(nCycle) + "-3"] = Timer.time() - nStart	return _gui.setGetDoc(doc)def getSample(doc, sample):	time = sample.get("time", None)	if time == None: return "Error: Time", None	sUuid = doc["_id"]	sSimUuid = doc["scenario"]	doc2 = _gui.getDoc(sSimUuid)	#	dataInp = doc2["docFile_INP"]	fINP = _measure.createInpFile(dataInp)	fWQM = _gui.createWqmFile(dataInp)	dataTsg = doc2["input_TSG"]	fTSG = _measure.createTsgFile(dataTsg, dataInp.get("duration", 0))	sInpUuid = dataInp["docId"]	node_name = sample.get("location", None)	if node_name == None: return "Error: Location", None	sPrefix = sUuid + "_Grab_" + node_name + "_" + str(sample.get("time", ""))	grab = []	grab.append(node_name)	fSEN = _measure.createSensorFile(grab)	_gui.closeFiles([fINP, fWQM, fTSG, fSEN])	# 'sensorThreshold' used here must be the same as 'meas_threshold' used in inversion	if type(time) == unicode and len(time) == 0: return "Error", None	data = {"_id": "", "sensorStart": int(time), "sensorStop": None, "sensorPerHour": 1, "sensorThreshold": 0, "prefix": sPrefix}	data = _measure.runExe(fINP, fWQM, fTSG, fSEN, data)	results = data.get("results", None)	if results == None: return "Error", None	values = results.get("Concentrations", None)	if values == None: return "Error: Location", None	node_values = values.get(node_name, None)	if node_values == None: return "Error: Location", None	if len(node_values) == 0: return "Error: Day/Time", None	status = _gui.getSensorStatus(node_values[0])	opposite = _gui.getOppositeStatus(status)	return status, oppositedef getTotalTime(doc):	total = 0	timer = doc.get("timer0", None)	if timer == None: return total	total = total + timer	for icycle in range(1, 99):		timer = doc.get("timer" + str(icycle) + "-1", None)		if timer == None: return total		total = total + timer		timer = doc.get("timer" + str(icycle) + "-2", None)		if timer == None: return total		total = total + timer	returndef runAll(doc):		imax = 30	doc = runInit(doc)	if doc.get("alarm", None) == None:		doc["statusOld"] = doc["status"]		doc["status"] = "Fail-NoAlarm"		_gui.setDoc(doc)		return	nDelay = _gui.getConfig("config_training_sample_delay")	for icycle in range(1, imax + 1):		doc["status"] = "Inversion " + str(icycle)		doc = _gui.setGetDoc(doc)		doc = runInversion(doc)                                # inversion		doc["timerTotal"] = getTotalTime(doc)		length = len(doc["results" + str(icycle)]["list"])		if icycle == 1:			doc["results_length"] = [length]		else:			doc["results_length"].append(length)		if length == 1:			doc["statusOld"] = doc["status"]			status = ""			status += str(doc["cycle"]) + "-"			status += str(int(doc["timerTotal"])) + "-"			status += doc["results" + str(icycle)]["list"][0]["Nodes"][0]["Name"]			doc["status"] = status			_gui.setDoc(doc)			return		if icycle == imax:			doc["statusOld"] = doc["status"]			doc["status"] = "Fail-Max-" + str(doc["cycle"]) + "-" + str(int(doc["timerTotal"]))			_gui.setDoc(doc)			return		doc["status"] = "Locating " + str(icycle)		doc = _gui.setGetDoc(doc)		sampleTime = doc["sampleTime"] + nDelay		doc["sampleTime"] = sampleTime		doc = runLocate(doc)                                   # grab sample		doc["timerTotal"] = getTotalTime(doc)		doc["sampleTime"] = sampleTime		#doc["time"] = sampleTime		grab_uuid = doc["grabId"]		grab_doc = _gui.getDoc(grab_uuid)		for item in grab_doc["grab"]:			item["value"]["status"] = item["value"]["suggested"]		_gui.setDoc(grab_doc)	returndef runSave(doc):	grab_uuid = doc["grabId"]	grab_doc = _gui.getDoc(grab_uuid)	grab_doc["grab"] = []	_gui.setDoc(grab_doc)	canary_uuid = doc["canaryId"]	canary_doc = _gui.getDoc(canary_uuid)	canary_doc["canary"] = []	_gui.setDoc(canary_doc)	table = doc["_id"]	db,cursor = _events.initializeSqlDb()	_events.deleteTable(cursor, table)	returndef runDelete(sUuid):	table = sUuid	db,cursor = _events.initializeSqlDb()	_events.deleteTable(cursor, table)	returndef run(sCall, sUuid):	doc = _gui.getDoc(sUuid)	#	if sCall == "init":		p = Process(target=runInit,args=(doc,))		p.start()		return _gui.respond({})	#	if sCall == "inversion":		p = Process(target=runInversion,args=(doc,))					p.start()		return _gui.respond({})	#	if sCall == "locate":		p = Process(target=runLocate,args=(doc,))		p.start()		return _gui.respond({})	#	if sCall == "sample":		p = Process(target=runSample,args=(doc,))		p.start()		return _gui.respond({})	#	if sCall == "all":		p = Process(target=runAll,args=(doc,))		p.start()		return _gui.respond({})	#	if sCall == "save":		p = Process(target=runSave,args=(doc,))		p.start()		return _gui.respond({})	#	if sCall == "delete":		p = Process(target=runDelete,args=(sUuid,))		p.start()		return _gui.respond({})	#	returndef main():	_gui.setHost()	for req in _gui.getRequests():		sDb = _gui.getQuery(req, "db")		_gui.setDatabase(sDb)		sCall = _gui.getQuery(req, "call")		sUuid = _gui.getQuery(req, "uuid")		sDir = tempfile.gettempdir()		os.chdir(sDir)		bRetVal = run(sCall, sUuid)		if bRetVal: continue		_gui.respondJSON(json.dumps({}))if __name__ == "__main__":	main()