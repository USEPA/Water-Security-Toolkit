# Copyright (2013) Sandia Corporation. Under the terms of Contract# DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government # retains certain rights in this software.## This software is released under the FreeBSD license as described # in License.txtimport timeimport stringimport subprocessimport osimport tempfilefrom multiprocessing import Processimport _guiimport _tevasimimport json # Python 2.6 and higherdef runImpactSim(sUuid, sDir):	doc = _gui.getDoc(sUuid)	#	inp_info = doc["docFile_INP"]	duration = inp_info["duration"]	# Get the basis for all injection scenarios	a1 = doc["input_TSG"][0].get("a1")	a2 = doc["input_TSG"][0].get("a2")	a3 = doc["input_TSG"][0].get("a3")	a4 = doc["input_TSG"][0].get("a4")	if a1 == ""  : a1 = "FLOWPACED"	if a2 == None: a2 = 100	if a3 == None: a3 = 0	if a4 == None: a4 = duration	#	injections = doc["injections"]	if injections == None: injections = [""]	if len(injections) == 1 and len(injections[0]) == 0:		# Create with "ALL", plus tanks and reservoirs		sInpUuid = inp_info["docId"]		docInp = _gui.getDoc(sInpUuid)		sJsonFile = docInp["jsonFile"]		docJson = _gui.getFileDoc(sInpUuid, sJsonFile)		Reservoirs = docJson["Reservoirs"]		Tanks = docJson["Tanks"]		#		doc["input_TSG"][0]["a0"] = "ALL"		doc["input_TSG"][0]["a1"] = a1		doc["input_TSG"][0]["a2"] = a2		doc["input_TSG"][0]["a3"] = a3		doc["input_TSG"][0]["a4"] = a4		others = Reservoirs + Tanks		for other in others:			doc["input_TSG"].append({"a0":other["id"],"a1":a1,"a2":a2,"a3":a3,"a4":a4})	else:		# Use the user-specified injection scenarios		doc["input_TSG"] = []		for injection in injections:			if len(injection.strip()) > 0:				doc["input_TSG"].append({"a0":injection,"a1":a1,"a2":a2,"a3":a3,"a4":a4})	#	# Run tevasim (dont spawn another the thread)	_tevasim.runThreaded(doc, sUuid, sDir, bThreaded=False)	#	doc = _gui.getDoc(sUuid)	status = doc["status"]	if status == "Error": return False	if status == "Stopped": return False	doc["status"] = "Running"	_gui.setDoc(sUuid, doc)	return Truedef runInversionExe(sUuid):	nStart = time.time()	doc = _gui.getDoc(sUuid)	sExe = _gui.getConfig("config_erd_exe")	sName = sUuid + ".erd"	args = [sExe, sName, "inversion"]	sText = _gui.startProcess(args)		doc["timer2"] = time.time() - nStart	returndef runImpactExe(sUuid):	nStart = time.time()	doc = _gui.getDoc(sUuid)	sExe = _gui.getConfig("config_erd_exe")	Error = []	if not os.path.exists(sExe):		Error.append("config_erd_exe path does not exists:")		Error.append("    '" + sExe + "'")	sName = sUuid + ".erd"	if not os.path.exists(sName):		Error.append("the tevasim erd output file is missing:")		Error.append("    '" + sName + "'")	#	args = [sExe, sName, "impact"]	#	inp_info = doc.get("docFile_INP", {})	duration = inp_info.get("duration", -1)	stopTime = doc.get("stopTime", duration)	args.append(str(stopTime))	#	n = 0	try:		sensors = doc["sensors"]		if sensors == None:			n = 0		else:			n = len(sensors)	except KeyError:		pass	n2 = 0	for i in range(0, n):		if len(sensors[i].strip()) > 0:			n2 += 1	args.append(str(n2))	for i in range(0, n):		if len(sensors[i].strip()) > 0:			args.append(sensors[i])	n = 0	try:		assets = doc["assets"]		if assets == None:			n = 0		else:			n = len(assets)	except KeyError:		pass	n2 = 0	for i in range(0, n):		if len(assets[i].strip()) > 0:			n2 += 1	#	# if the user specified ALL in the assets field 	# and its the only thing specified	# act like it wasnt specified at all.	# the impact executable will generate the asset list	# from the entire list of nodes	#	if n2 == 1:		for i in range(0, n):			if assets[i].upper() == "ALL":				n = 0				n2 = 0	#	args.append(str(n2))	#	for i in range(0, n):		if len(assets[i].strip()) > 0:			args.append(assets[i])	#	sText = _gui.startProcess(args)	#	try:		data = json.loads(sText)	except ValueError:		Error.append("the results string returned from erd exe is not json serializable:")		Error.append("    '" + sText + "'")		data = {}	try:		doc["Impact"] = data["Impact"]		doc["status"] = "Complete"	except:		pass		doc["Impact"] = data		doc["status"] = "Error"		doc["Error" ] = Error	doc["timer2"] = time.time() - nStart	_gui.setDoc(sUuid, doc)	return docdef runImpact(sUuid, sDir):	bContinue = runImpactSim(sUuid, sDir)	if bContinue == False: return	runImpactExe(sUuid)	#	if _gui.bDeleteTempFiles(override=None):#		_gui.removeFile(sDir + "/" + "hydraulics.hyd")		sFiles = os.listdir(sDir)		n = len(sUuid)		for sFile in sFiles:			if sFile[:n] == sUuid:				_gui.removeFile(sDir + "/" + sFile)	returndef runThreaded(sUuid, sDir, bThreaded=True):	if bThreaded:		p = Process(target=runImpact, args=(sUuid, sDir, ))		p.start()	else:		return runImpact(sUuid, sDir)	return	def run(sCall, sUuid, bThreaded=True):	if sCall == "rename":		return False	if sCall == "delete":		return False	sDir = tempfile.gettempdir()	os.chdir(sDir)	runThreaded(sUuid, sDir)	return _gui.respondJSON(json.dumps({}))def main():	_gui.setHost()	for req in _gui.getRequests():		sDb = _gui.getQuery(req, "db")		_gui.setDatabase(sDb)		sCall = _gui.getQuery(req, "call")		sUuid = _gui.getQuery(req, "uuid")		sType = _gui.getQuery(req, "type")		bRetVal = run(sCall, sUuid, True)		if bRetVal: continue		_gui.respondJSON(json.dumps({}))if __name__ == "__main__":	main()