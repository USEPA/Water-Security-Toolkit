# Copyright (2013) Sandia Corporation. Under the terms of Contract# DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government # retains certain rights in this software.## This software is released under the FreeBSD license as described # in License.txtimport timeimport stringimport subprocessimport osimport tempfilefrom multiprocessing import Processimport _guifrom _gui import FakeFileimport json # Python 2.6 or laterdef createYmlFile(fINP, fWQM, fSCN, fTSG, fSEN, fNodes, dSampleTime, nSampleCount, sOutputPrefix):	file = tempfile.NamedTemporaryFile(delete=False, suffix='.yml')	_gui.writeLine(file,"# written using dinesti web gui")	_gui.writeLine(file,"")	_gui.writeLine(file,"network:")	_gui.writeLine(file,"  epanet file: " + fINP.name)	#_gui.writeLine(file,"  wqm file: " + fWQM.name) # moved to grabsample section	#_gui.writeLine(file,"  hydraulic timestep: None") # no longer available	_gui.writeLine(file,"  water quality timestep: None")	_gui.writeLine(file,"  simulation duration: None")	_gui.writeLine(file,"")	_gui.writeLine(file,"scenario:") # used to be called 'events'	_gui.writeLine(file,"  scn file: " + fSCN.name) # for _inversion LP (optimization)	_gui.writeLine(file,"  tsg file: " + fTSG.name) # for _inversion STEP (optmization)	_gui.writeLine(file,"  ignore merlion warnings: False") # moved from network section	_gui.writeLine(file,"")	#_gui.writeLine(file,"solver:")	#_gui.writeLine(file,"  cplex:")	#_gui.writeLine(file,"    mipgap: 0.02")	#_gui.writeLine(file,"    threads: 1")	_gui.writeLine(file,"")	#_gui.writeLine(file,"samplelocation:")	_gui.writeLine(file,"grabsample:")	_gui.writeLine(file,"  wqm file: " + fWQM.name) # moved from network section	_gui.writeLine(file,"  model format: PYOMO") # AMPL or PYOMO	_gui.writeLine(file,"  sample time: " + str(dSampleTime / 60)) # minutes	_gui.writeLine(file,"  threshold: 0.01") # default = 0.001	_gui.writeLine(file,"  fixed sensor file: " + fSEN.name)	#_gui.writeLine(file,"  not allowed locations file: None") # no longer available	_gui.writeLine(file,"  allowed locations file: " + fNodes.name) # TODO	_gui.writeLine(file,"  N samples: " + str(nSampleCount)) # default = 3	_gui.writeLine(file,"  greedy selection: True")	_gui.writeLine(file,"")	_gui.writeLine(file,"configure:")	_gui.writeLine(file,"  ampl executable: ampl")#" + sInstallDir + "bin/ampl")	_gui.writeLine(file,"  pyomo executable: pyomo")#" + sInstallDir + "bin/pyomo")	_gui.writeLine(file,"  output prefix: " + sOutputPrefix)	_gui.writeLine(file,"")	#_gui.writeLine(file,"internal:")	#_gui.writeLine(file,"  nodeNames: None")	#_gui.writeLine(file,"  nodeIndices: None")	return filedef createInpFile(data):	text = _gui.getFile(data["docId"], data["fileName"])	temp = tempfile.NamedTemporaryFile(delete=False, suffix='.inp')	temp.write(text)	return tempdef createScnFile(uuid):	return FakeFile()def createTsgFile(uuid):	temp = tempfile.NamedTemporaryFile(delete=False, suffix='.tsg')	data = _gui.getView("m_ScenariosList?key=\"" + uuid + "\"")	for row in data["rows"]:		text = _gui.getFile(row["id"], row["value"]["fileName"])		temp.write(text + "\n")	return tempdef createSenFile(uuid):	temp = tempfile.NamedTemporaryFile(delete=False, suffix='.sen')	doc = _gui.getDoc(uuid)	sensors = _gui.getValue(doc, "sensors", "")	sensors = sensors.split("\n")	bFirst = True	for line in sensors:		s = line.strip()		if len(s) > 0:			if not bFirst:				temp.write("\n")			bFirst = False			temp.write(s)	return tempdef createNodesFile(Nodes):	temp = tempfile.NamedTemporaryFile(delete=False, suffix='.nodes')	for node in Nodes:		temp.write(node + "\n")	return tempdef runWst(fINP, fWQM, fSCN, fTSG, fSEN, fNodes, fYML, sUuid, sOutputPrefix):	nStart = time.time()	sInstallDir = _gui.getInstallDir()	args = [sInstallDir + "python/bin/wst", "grabsample", fYML.name]	#	p = subprocess.Popen(args, stdout=subprocess.PIPE)	doc = _gui.getDoc(sUuid)	sampleTime = doc.get("sampleTime")	inp_info = doc.get("docFile_INP")	duration = inp_info.get("duration")	bErrorOverTime = False	if sampleTime <> None and duration <> None:		if sampleTime > duration:			bErrorOverTime = True	doc["pid"] = str(p.pid)	doc["status"] = "Running"	res = _gui.setDoc(doc)	#doc = _gui.getDoc(sUuid)	com = p.communicate()	sOut = com[0]	#	sFile = sOutputPrefix + "_grabsample_results.json"	results = _gui.readJsonFile(sFile, {"Error": "output file was not created: " + sFile})	sOUT = sOutputPrefix + "_samplelocation.out"	debug_text_out_file = _gui.readFile(sOUT)	doc = _gui.getDoc(sUuid)	bError = False	if bErrorOverTime:		sError = "the sample time is after the end of the simulation."		results = {"Error": sError}		doc["Error"] = sError		bError = True	elif results.get("Error") <> None:		doc["Error"] = results["Error"]		bError = True	doc["results"] = results	doc["results"]["sampleTime"] = results.get("sampleTime", 0) * 60 # TODO - this should be changed in the grabsample executable	doc["debug_fileSCN"] = fSCN.name	doc["debug_fileTSG"] = fTSG.name	doc["debug_stdout"] = com[0]	doc["returnCode"] = p.returncode	doc["debug_text_out_file"] = debug_text_out_file	#	if com[1] == None:		doc["debug_stderr"] = "\0"	else:		doc["debug_stderr"] = com[1]	#	sKill = "Signal handler called from"	index = string.find(sOut, sKill)	doc["debug_stdout_find_error_index"] = index	#	if _gui.bDeleteTempFiles(override=None):		_gui.removeFiles([fWQM, fTSG, fSCN, fINP, fSEN, fNodes, fYML])		_gui.removeFile(sOutputPrefix + "_epanet.rpt")		_gui.removeFile(sOutputPrefix + "_samplelocation.out")		_gui.removeFile(sOutputPrefix + "_samplelocation.log")		_gui.removeFile(sOutputPrefix + "_MERLION_LABEL_MAP.txt")		_gui.removeFile(sOutputPrefix + "_GSP.dat")		_gui.removeFile(sOutputPrefix + "_ampl.run")		_gui.removeFile(sOutputPrefix + "_ampl.out")		_gui.removeFile(sOutputPrefix + "_grabsample_results.dat")		_gui.removeFile(sOutputPrefix + "_grabsample_results.json")	#	if index == -1 and 	p.returncode == 0:		doc["status"] = "Complete"	elif index == -1 or bError:		doc["status"] = "Error"	else:		doc["status"] = "Stopped"	#	doc["timer"] = time.time() - nStart	_gui.setDoc(sUuid, doc)	return docdef runThreaded(doc, sOutputPrefix, bThreaded=True):	sUuid = doc["_id"]	dSampleTime  = doc.get("sampleTime",  0) 	nSampleCount = doc.get("sampleCount", 3)	docFile_INP  = doc.get("docFile_INP")	Nodes        = doc.get("Nodes"      )	fWQM = _gui.createWqmFile(docFile_INP)	if fWQM == None:		fINP = createInpFile(docFile_INP)		fWQM = FakeFile()	else:		fINP = FakeFile()	fSCN = createScnFile(sUuid) # FakeFile	fTSG = createTsgFile(sUuid)	fSEN = createSenFile(sUuid)	if Nodes == None:		fNodes = FakeFile()	else:		fNodes = createNodesFile(Nodes)	fYML = createYmlFile(fINP, fWQM, fSCN, fTSG, fSEN, fNodes, dSampleTime, nSampleCount, sOutputPrefix)	_gui.closeFiles([fINP, fWQM, fSCN, fTSG, fSEN, fNodes, fYML])	#	if bThreaded:		p = Process(target=runWst, args=(fINP, fWQM, fSCN, fTSG, fSEN, fNodes, fYML, sUuid, sOutputPrefix, ))		p.start()	else:		return runWst(fINP, fWQM, fSCN, fTSG, fSEN, fNodes, fYML, sUuid, sOutputPrefix)	returndef run(sCall, sUuid, bThreaded=True):	if sCall == "delete":		return False	if sCall == "rename":		return False	sDir = tempfile.gettempdir()	os.chdir(sDir)	doc = _gui.getDoc(sUuid)	runThreaded(doc, sUuid, True)	return _gui.respondJSON(json.dumps({}))def main():	_gui.setHost()	for req in _gui.getRequests():		sDb = _gui.getQuery(req, "db")		_gui.setDatabase(sDb)		sCall = _gui.getQuery(req, "call")		sUuid = _gui.getQuery(req, "uuid")		bRetVal = run(sCall, sUuid, True)		if bRetVal: continue		_gui.respondJSON(json.dumps({}))if __name__ == "__main__":	main()