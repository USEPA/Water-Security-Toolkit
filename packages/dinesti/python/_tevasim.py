# Copyright (2013) Sandia Corporation. Under the terms of Contract# DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government # retains certain rights in this software.## This software is released under the FreeBSD license as described # in License.txtimport timeimport stringimport subprocessimport osimport tempfilefrom multiprocessing import Processimport _guiimport json # Python 2.6 or laterdef createYmlFile(fTSG, fINP, sInstallDir, sOutputPrefix):	temp = tempfile.NamedTemporaryFile(delete=False, suffix='.yml')	_gui.writeLine(temp,"# written using dinesti web gui")	_gui.writeLine(temp,"network:")	_gui.writeLine(temp,"  epanet file: " + fINP.name)	#_gui.writeLine(temp,"  simulation duration: " + str(2 * 60))	_gui.writeLine(temp,"")	_gui.writeLine(temp,"scenario:")	_gui.writeLine(temp,"  tsg file: " + fTSG.name)	_gui.writeLine(temp,"  dvf file: None")	_gui.writeLine(temp,"  msx file: None")	_gui.writeLine(temp,"  msx species: None")	_gui.writeLine(temp,"  merlion: True")	_gui.writeLine(temp,"  erd compression: None") # RLE or LZMA	#_gui.writeLine(temp,"  merlion nsims: 100")    #_gui.WriteLine(temp,"  ignore merlion warnings: False")	_gui.writeLine(temp,"")	_gui.writeLine(temp,"configure:")	_gui.writeLine(temp,"  tevasim executable: " + sInstallDir + "bin/tevasim")	_gui.writeLine(temp,"  output prefix: " + sOutputPrefix)	return tempdef createInpFile(data):	text = _gui.getFile(data["docId"], data["fileName"])	temp = tempfile.NamedTemporaryFile(delete=False, suffix='.inp')	temp.write(text)	return tempdef createTsgFile(data, duration=0):	temp = tempfile.NamedTemporaryFile(delete=False, suffix='.tsg')	for row in data:		a0 = row.get("a0")		a1 = row.get("a1", "")		a2 = row.get("a2", 100)		a3 = row.get("a3", 0)		a4 = row.get("a4", duration)		if a1 == ""  : a1 = "FLOWPACED"		temp.write(str(a0) + "    ")		temp.write(str(a1) + "    ")		temp.write(str(a2) + "    ")		temp.write(str(a3) + "    ")		temp.write(str(a4) + "    ")		temp.write("\n")	return tempdef runWst(fTSG, fINP, fYML, sUuid, sInstallDir, sDir):	error = "unknown"	try:	#if True:		nStart = time.time()		#		args = [sInstallDir + "python/bin/wst", "tevasim", fYML.name]		p = subprocess.Popen(args, stdout = subprocess.PIPE)		#		doc = _gui.getDoc(sUuid)		doc["pid"] = str(p.pid)		doc["status"] = "Running"		_gui.setDoc(sUuid, doc)		com = p.communicate()		sOut = com[0]		#		#out_arr = string.split(sOut,"\n")		#for iline in range(0, len(out_arr)):			#doc["stdout" + str(iline) = out_arr[iline]		doc = _gui.getDoc(sUuid)		doc["debug_stdout"] = com[0]		doc["debug_stderr"] = com[1]		doc["debug_return_code"] = str(p.returncode)		#		sKill = "Signal handler called from"		index = string.find(sOut, sKill)		doc["debug_stdout_find_error_index"] = str(index)		#		if _gui.bDeleteTempFiles(override=None):			_gui.removeFiles([fTSG, fINP, fYML])		#		sExe = _gui.getConfig("config_erd_exe")		sAttribute = "Concentration"		sNodeId = doc["input_TSG"][0]["a0"]		sSourceId = doc["input_TSG"][0]["a0"]		if sSourceId <> None:			sName = sDir + "/" + sUuid + ".erd"			if os.path.exists(sName):				error = "unknown"			else:				error = "Output file is missing: " + sName			sText = _gui.startProcess([sExe, sName, "static", sAttribute, sNodeId, sSourceId])			data = json.loads(sText)			dMax = data.get(sAttribute + "Max", -1)			sMax = str(dMax)			sText = _gui.startProcess([sExe, sDir + "/" + sUuid + ".erd", "dynamic5", sAttribute, "", sSourceId])			data2 = json.loads(sText)			dynamic = data2.get("Dynamic", {"error": "call to jsonwriter2 returned nothing", "numSteps": 0})			t1 = dynamic["numSteps"]			sZero = str(0.0)			sBands = str(8)			sText = _gui.startProcess([sExe, sDir + "/" + sUuid + ".erd", "dynamic5", sAttribute, "", sSourceId, "0", str(t1), sZero, sMax, sBands])			data2 = json.loads(sText)			data = {}			dynamic = data2.get("Dynamic", {"error": "call to jsonwriter2 returned nothing", "numSteps": 0})			data["Dynamic"] = dynamic			doc["results"] = data				_gui.setDoc(doc)			#			sFiles = [sUuid + ".rpt", sUuid + ".erd", sUuid + ".index.erd", sUuid + "-1.qual.erd", sUuid + "-1.hyd.erd", sUuid + "_tevasim.json"]			binary = [False, True, True, True, True, False]			for i,sFile in enumerate(sFiles):				doc = _gui.getDoc(sUuid)				sType = "text/plain"				if binary[i]: sType = "application/octet-stream"				res = _gui.uploadFileFromDisk(sUuid, sDir, sFile, sType, binary[i])				res_type = type(res)				if res_type == str:					try:						objRes = json.loads(res)						error = objRes.get("error", None)					except:						error = None				elif res_type == dict:					error = res.get("error", None)				else:					error = None				if error <> None:					_gui.raiseDebugError(error)			#			if _gui.bDeleteTempFiles(override=None):				_gui.removeFile(sDir + "/" + "hydraulics.hyd")				for sFile in sFiles:					_gui.removeFile(sDir + "/" + sFile)			#		doc = _gui.getDoc(sUuid)		doc["timer"] = time.time() - nStart		if index == -1:			doc["status"] = "Complete"		else:			doc["status"] = "Stopped"		#		_gui.setDoc(sUuid, doc)	#else:pass	#	#try:pass	except Exception as e:		doc = _gui.getDoc(sUuid)		doc["status"] = "Error"		doc["Error"] = error		_gui.setDoc(doc)	returndef runThreaded(doc, sOutputPrefix, sDir, bThreaded=True):	sUuid = doc["_id"]	sInstallDir = _gui.getConfig("config_install_dir")	#	input_TSG = doc["input_TSG"]	docFile_INP = doc["docFile_INP"]	duration = docFile_INP.get("duration")	fTSG = createTsgFile(input_TSG, duration)	fINP = createInpFile(docFile_INP)	fYML = createYmlFile(fTSG, fINP, sInstallDir, sOutputPrefix)	_gui.closeFiles([fTSG, fINP, fYML])	#	if bThreaded:		p = Process(target = runWst, args = (fTSG, fINP, fYML, sUuid, sInstallDir, sDir, ))		p.start()	else:		return runWst(fTSG, fINP, fYML, sUuid, sInstallDir, sDir, )	returndef run(sCall, sUuid, bThreaded=True):	if sCall == "rename":		return False	if sCall == "delete":		return False	sDir = tempfile.gettempdir()	os.chdir(sDir)	doc = _gui.getDoc(sUuid)	runThreaded(doc, sUuid, sDir, True)	return _gui.respondJSON(json.dumps({}))def main():	_gui.setHost()	for req in _gui.getRequests():		sDb = _gui.getQuery(req, "db")		_gui.setDatabase(sDb)		sCall = _gui.getQuery(req, "call")		sUuid = _gui.getQuery(req, "uuid")		bRetVal = run(sCall, sUuid, True)		if bRetVal: continue		_gui.respondJSON(json.dumps({}))if __name__ == "__main__":	main()