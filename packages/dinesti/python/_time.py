# Copyright (2013) Sandia Corporation. Under the terms of Contract# DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government # retains certain rights in this software.## This software is released under the FreeBSD license as described # in License.txtimport time as Timerimport datetimeimport stringimport subprocessimport osimport tempfilefrom multiprocessing import Processimport MySQLdbimport _guifrom _gui import FakeFileimport _measureimport _inversionimport _grabimport _uuidimport json # Python 2.6 or laterm_nFFDiffStart = Nonedef getFastForward():	#return True	return Falsedef getFFSpeed():	return 60 * 2def getFFStartTime():	return m_MonMay6 + 3600 * (12 + 0./60.)def getFFDiffStart():	global m_nFFDiffStart	if m_nFFDiffStart == None:		m_nFFDiffStart = _gui.getEpoch()	return m_nFFDiffStartdef getUuid():	return "time"def runGet():	config = _gui.getConfig()	current_time = {}	if config.get("config_clock_testing", False):		if getFastForward():			# use to speed up real time			nStartTime = getFFStartTime()			nDiffStart = getFFDiffStart()			nSpeed     = getFFSpeed()			nNow       = _gui.getEpoch()			nDiff      = (nNow - nDiffStart) * nSpeed			epoch      = nStartTime + nDiff 		else:			# use to make time stand still at any point in time			epoch = int(datetime.datetime(2013,5,6).strftime("%s"))			epoch = epoch + 3600 * (14 + 15./60.)			epoch = config.get("config_clock_test_start", 0)			#		current_time["time"] = 1000 * epoch		current_time["epoch"] = epoch	else:		# use to move real time forward or backward days or hours		nDiff = -1 * (24 * 3600 * 4 + 3600 * 17)		nDiff = -1 * (24 * 3600 * 0 + 3600 *  2)		nDiff =  0 * (24 * 3600 * 0 + 3600 *  2)				current_time["time"] = _gui.getEpochMilliseconds() + nDiff * 1000		current_time["epoch"] = int(_gui.getEpoch()) + nDiff		#	current_time["repeat"]   = config.get("config_clock_repeat", None)	current_time["interval"] = config.get("config_clock_interval", None)	return current_timedef runLoop():	instance = _uuid.run()	uuid = getUuid()	doc = _gui.getDoc(uuid)	bContinue = True	while True:		if bContinue:			interval = doc["interval"]			current_time = runGet()			doc["time"] = current_time["time"]			doc["epoch"] = current_time["epoch"]			doc["instance"] = instance			_gui.setDoc(doc)		Timer.sleep(interval)		doc = _gui.getDoc(uuid)		bContinue = _gui.getConfig("config_time_continue")		if not bContinue:			break		instance_new = doc["instance"]		if instance <> instance_new:			break	returndef run(sCall):	if sCall == "get":		current_time = runGet()		return _gui.respond(current_time)	#	if sCall == "loop":		p = Process(target=runLoop, args=())		p.start()		return _gui.respond({})def main():	_gui.setHost()	for req in _gui.getRequests():		sDb = _gui.getQuery(req, "db")		_gui.setDatabase(sDb)		sCall = _gui.getQuery(req, "call")		bRetVal = run(sCall)		if bRetVal: continue		_gui.respond({})if __name__ == "__main__":	main()