\subsection{Overview}\label{lagrangianExecutable_lagrangianOverview}
The {\bfseries ufl} executable heuristically solves p-\/median formulations of the sensor placement problem while also computing a valid lower bound on the best possible sensor placement value.

\subsection{Usage}\label{lagrangianExecutable_uflUsage}
\begin{verb}
   ufl <sp-configuration-file> <p> [--gap=<fraction>][<goal-constraint-data-file> <upper-bound>]
\end{verb}

\subsection{Options}\label{lagrangianExecutable_uflOptions}
\begin{verbatim} 
    --gap=<fraction> 
    This option tells the solver to stop when the solution is within a certain percentage 
    of optimal.  Let \b icost be the current best integer solution found and \b lb be the 
    current lower bound. The solver will stop with <b> (icost - lb)/lb </b> is less that 
    the gap.  For example, if the gap is 0.1, then the solver will stop when it has a 
    solution that is within 10 percent of optimality.
\end{verbatim}
\subsection{Arguments}\label{lagrangianExecutable_uflArgs}
\begin{verbatim} 
    <sp-configuration-file>  
    A LAG file that defines impacts for the objective. 
    
    <p>
    The number of sensors.

    <goal-constraint-data-file>
    A LAG file that defines impacts for a side-constraint.

    <upper-bound>
    The upper bound for this side constraint.
\end{verbatim} 
\subsection{Description}\label{lagrangianExecutable_uflDescr}
\char`\"{}ufl\char`\"{} stands for \char`\"{}uncapacitated facility location,\char`\"{} and this code is a Sandia-\/modified version of the combination of Lagrangian relaxation and the \char`\"{}Volume Algorithm\char`\"{} that is found in the open-\/source \char`\"{}COIN\char`\"{} repository (that the PICO solver uses).

The {\bfseries sp} executable automatically generates {\bfseries ufl} commands, including those with goal constraints. The user specifies the number of sensors, and {\bfseries sp} passes to {\bfseries ufl} one more than this number. The Lagrangian heuristic implemented in {\bfseries ufl} then places the correct number of sensors, and one \char`\"{}dummy\char`\"{} sensor that catches all undetected events.

Note that the {\bfseries ufl} command uses \doxyref{LAG File}{p.}{formats_lagFile} inputs, which are a modified format of impact files. These files are generated by the \doxyref{tso2Impact}{p.}{tso2ImpactExecutable} executable.

As of teva-\/spot-\/1.2, {\bfseries ufl} handles \char`\"{}goal constraints.\char`\"{} For example, we may minimize the contaminant mass consumed subject to the goal of limiting the extent of contamination in pipe feet to a constant such as 15,000. This is different from specifying a side constraint for the \char`\"{}sideconstraints\char`\"{} local search executable. The latter will reject any solution in which the extent of contamination is greater than 15,000, even if it is only 15,001. Many goal constraints may be provided simultaneously, and the Lagrangian solver will attempt to find a solution that honors those constraints. It will report one that has a good combination of primary objective value and small violations of the goals.

This technology is young, and experience shows that user attempts to make the goal constraints too tight can confuse the solver. We offer the following guidance to avoid this problem. Suppose that we wish to use the Lagrangian heuristic to find a good solution that minimizes the average contaminant mass consumed subject to utility guidelines on the average extent of contamination, and also the average volume of contaminated water consumed.

\begin{enumerate} 
\item Using a solver of choice for the particular problem, find single-objective optimal values for each objective.
\item Using {\ttfamily evalsensor}, evaluate the single-objective sensor placements against each of the other objectives.  The result is a matrix of objective values.
\item Determine goal constraints for the secondary objectives by selecting a value between the optimal single-objective value for that secondary objective, and its value under the sensor placement obtained by solving the single-objective problem for the primary objective.
\end{enumerate}

For example, for a real test problem, minimizing the average contaminant mass consumed yielded an objective value of 638,344 units. Taking the sensor placement obtained from that solve, we found that the average extent of contamination was 78,037 feet, and the average volume of contaminated water consumed was 282,689 units.

Solving individually for these objectives, we found that the optimal solutions for extent of contamination and volume consumed were 40,867 and 217,001, respectively. From this information, we decided to apply goal constraints of 45,000 feet for the extent of contamination, and 250,000 units for the volume consumed.

Minimizing the mass consumed with these two goal constraints, the Lagrangian heuristic found a new sensor placement that incurred objective values of 678,175 units for mass consumed, 49,016 feet for the extent of contamination, and 256,615 units for volume consumed. Note that neither goal was strictly met, but each goal helped improve its related objective value.

We now compare this technology to the side-\/constrained local search heuristic (the \char`\"{}sideconstraints\char`\"{} executable). Each heuristic has advantages and disadvantages. The goal-\/constrained Lagrangian solver can handle an arbitrary number of goal constraints, producing a solution that is well balanced, as above. When we attempt to reproduce the results above using the \char`\"{}sideconstraints\char`\"{} executable, which is currently limited to only one side constraint, we see the untreated objective suffer. For example, with the same setup as above, and a side constraint of 50,000 feet for average extent of contamination, the sideconstraints heuristic produces a solution with an expected mass consumed of 670,399 units, an expected extent of contamination of 49,827 feet, and an expected volume consumed of 326,943. We see a similar type of result with a single side constraint on the volume consumed (the extent of contamination increases substantially). The sideconstraints code could be extended to handle multiple side constraints, of course, but the neighborhood search might have difficulty finding feasible solutions. Since Lagrangian relaxation is a global technique and slightly infeasible solutions are permitted, we are more likely to find a good trade-\/off.

However, the Lagrangian heuristic has disadvantages as well. If a particular goal constraint is set too tightly, the solution can degenerate such that all of the objectives get substantially worse. We do not understand this phenomenon well yet, and further research into the algorithm itself may be necessary to make this technology generally usable. For now, it is sometimes necessary to manipulate the values of the goal constraints manually in order to find a good solution.

